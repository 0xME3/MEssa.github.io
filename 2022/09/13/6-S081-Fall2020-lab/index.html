<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bigbug_favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.rabb1t.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="试试看自己能坚持写完吗。">
<meta property="og:type" content="article">
<meta property="og:title" content="6.S081_Fall2020_lab">
<meta property="og:url" content="http://www.rabb1t.xyz/2022/09/13/6-S081-Fall2020-lab/index.html">
<meta property="og:site_name" content="Rabbit hole">
<meta property="og:description" content="试试看自己能坚持写完吗。">
<meta property="og:locale">
<meta property="og:image" content="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMD_TK8Ar4GqWE6xfWV%2F-MMNmVfRDZSAOKze10lZ%2Fimage.png?alt=media&token=4bbfdfa6-1491-4ab8-8248-03bd0e36a8e9">
<meta property="article:published_time" content="2022-09-13T06:36:51.000Z">
<meta property="article:modified_time" content="2023-02-05T01:28:13.980Z">
<meta property="article:author" content="MEssa_Rabbit">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMD_TK8Ar4GqWE6xfWV%2F-MMNmVfRDZSAOKze10lZ%2Fimage.png?alt=media&token=4bbfdfa6-1491-4ab8-8248-03bd0e36a8e9">

<link rel="canonical" href="http://www.rabb1t.xyz/2022/09/13/6-S081-Fall2020-lab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>6.S081_Fall2020_lab | Rabbit hole</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rabbit hole</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">We don't choose who we are, but we do choose who we become.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/links/" rel="section"><i class="fa-links fa-fw"></i>friends</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://www.rabb1t.xyz/2022/09/13/6-S081-Fall2020-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myavatar.png">
      <meta itemprop="name" content="MEssa_Rabbit">
      <meta itemprop="description" content="菜狗一个">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rabbit hole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.S081_Fall2020_lab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-13 14:36:51" itemprop="dateCreated datePublished" datetime="2022-09-13T14:36:51+08:00">2022-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-05 09:28:13" itemprop="dateModified" datetime="2023-02-05T09:28:13+08:00">2023-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>试试看自己能坚持写完吗。</p>
<span id="more"></span>

<h1 id="Lab1-Xv6-and-Unix"><a href="#Lab1-Xv6-and-Unix" class="headerlink" title="Lab1: Xv6 and Unix"></a>Lab1: Xv6 and Unix</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">		sleep(tmp*<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p1[<span class="number">2</span>],p2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	</span><br><span class="line">	pipe(p1);</span><br><span class="line">	pipe(p2);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fault in fork\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">		<span class="keyword">char</span> buf=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p1[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p2[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> buf;</span><br><span class="line">		</span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p2[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p1[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> *lp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> prime,tmp;</span><br><span class="line"></span><br><span class="line">	close(lp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;prime,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">			pipe(rp);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime)</span><br><span class="line">					write(rp[<span class="number">1</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">			&#125;<span class="keyword">while</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">			pid=fork();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;failed in fork\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				primes(rp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(rp[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				close(rp[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	if(argc!=2)&#123;</span></span><br><span class="line"><span class="comment">//		printf(&quot;bad argments.\n&quot;);</span></span><br><span class="line"><span class="comment">//		exit(-1);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	else num=atoi(argv[1]);</span></span><br><span class="line"></span><br><span class="line">	pipe(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num;i++)</span><br><span class="line">		write(p[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	primes(p);</span><br><span class="line">	close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fmtname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find first character after last slash.</span></span><br><span class="line">	<span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">		;</span><br><span class="line">	p++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return blank-padded name.</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">	<span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *path,<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">		close(fd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="keyword">case</span> T_DEVICE:</span><br><span class="line">	<span class="keyword">case</span> T_FILE:</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(filename,fmtname(path)))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> T_DIR:</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">		p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">		*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">			<span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			memmove(p, de.name, DIRSIZ);</span><br><span class="line">			p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(p,<span class="string">&quot;..&quot;</span>))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			find(buf,filename);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad args\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv,<span class="keyword">int</span> bufnum,<span class="keyword">char</span> buf[][<span class="number">128</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bufnum;i++)</span><br><span class="line">		argv[argc+i]=buf[i];</span><br><span class="line">	exec(argv[<span class="number">0</span>],argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xargs</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>][<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> bufnum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i],<span class="string">&quot;-n&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span>(*argv[i+<span class="number">1</span>]&lt;<span class="string">&#x27;9&#x27;</span> &amp;&amp; *argv[i+<span class="number">1</span>]&gt;<span class="string">&#x27;0&#x27;</span> &amp;&amp; !(<span class="built_in">strlen</span>(argv[i+<span class="number">1</span>])&gt;<span class="number">1</span>))</span><br><span class="line">			n=atoi(argv[++i]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments. n &lt;10 \n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)&#123;</span><br><span class="line">			len=read(<span class="number">0</span>,&amp;buf[i][j],<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(buf[i][j]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">				buf[i][j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		bufnum++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;bufnum&gt;<span class="number">0</span>;bufnum-=n,j++)&#123;</span><br><span class="line">			pid=fork();</span><br><span class="line">			<span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				<span class="keyword">if</span>(bufnum&gt;=n)</span><br><span class="line">					solve(argc-i,&amp;argv[i],n,&amp;buf[j*n]);</span><br><span class="line">				<span class="keyword">else</span> solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* args[MAXARG];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(argc&gt;MAXARG)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;too many argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)</span><br><span class="line">			args[i<span class="number">-1</span>]=argv[i];</span><br><span class="line"></span><br><span class="line">		xargs(i<span class="number">-1</span>,args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h1><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>根据提示，一个系统调用需要：</p>
<ul>
<li>在user/user.h 中声明，系统调用的用户态原型</li>
<li>user/usys.S 中生成供调用跳转内核态执行对应系统调用的入口条目</li>
<li>kernel/syscall.h 中有系统调用对应的编号(系统调用号)</li>
<li>系统调用对应的程序代码在 kernel/sysproc.c</li>
</ul>
<p>除此之外，实现 tracing 的系统调用还需要：</p>
<ul>
<li>kernel/proc.h 中的 proc 结构体添加一个新变量，用来储存追踪中的系统调用号，而且根据实验描述，这个变量其实是个掩码。tracing 系统调用的主要任务就是获取这个新的变量。</li>
<li>这个变量是通过 argint() 获取的，因为 trap 机制会将寄存器的值先全部保存在 trapframe 中，可以通过 argXXX() 来读取寄存器里的数值。</li>
<li>最后的打印追踪目标则放在 syscall 中实现。</li>
</ul>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retfreemem</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                                           </span><br><span class="line">	<span class="comment">// 该处需要初始化freemem,否则会得到错误的数值</span></span><br><span class="line">  addr-&gt;freemem=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 看别人师傅的代码上了锁，确实应该，免得错误访问内存而程序终止了</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">for</span>(struct run *tmp=kmem.freelist;tmp;tmp=tmp-&gt;next)</span><br><span class="line">    addr-&gt;freemem+=PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retnproc</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                      </span><br><span class="line">	<span class="comment">// 同样需要初始化</span></span><br><span class="line">  addr-&gt;nproc=<span class="number">0</span>;                                                      </span><br><span class="line">  <span class="keyword">for</span>(struct proc *p=proc;p&lt;&amp;proc[NPROC];p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)</span><br><span class="line">      addr-&gt;nproc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  retfreemem(&amp;info);</span><br><span class="line">  retnproc(&amp;info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable,addr,(<span class="keyword">char</span>*)&amp;info,<span class="keyword">sizeof</span>(struct sysinfo))&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h1><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>内核态与用户态，会共享一个只读页，方便用户直接访问，能够提升速度，也是这个实验要做的。</p>
<p>根据提示，在proc_pagetable中映射地址。但是并没有说具体映射的页pa，看了别人写的，是仿造trapframe的相关代码来写的，在allocproc中给usyscall也创建一个页。接着是寻找到允许用户读的权限，权限是保存在riscv.h中，能看到一个PTE_U，他的注释是<code>user can access</code>。最后在allocproc中将其实现和初始化。</p>
<p>最后还需要完善，将释放内存和页表映射放进去，继续模仿就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct proc</span></span><br><span class="line">……</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>* <span class="title">usyscall</span>;</span>   <span class="comment">// user syscall</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//allocproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// create ussycall page</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;usyscall = (struct usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;usyscall-&gt;pid=p-&gt;pid;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// map ropage</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">                (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">……</span><br><span class="line"><span class="comment">//freeproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="keyword">void</span>*)p-&gt;usyscall);</span><br><span class="line">    p-&gt;usyscall=<span class="number">0</span>;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>跟着实验描述做，将第一个进程的页表打印出来，一看就觉得是树的遍历，再看输出格式应该是先序遍历。</p>
<p>因此vmprint应该使用递归来打印页表内容比较简单，又因为规定了需要写为vmprint仅有一个参数，所以在定义一个函数用来递归即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traceleaf</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;                                           </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> pte=pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte&amp;PTE_V)&#123;</span><br><span class="line">            uint64 child=PTE2PA(pte);</span><br><span class="line">            <span class="keyword">switch</span>(level)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">    <span class="keyword">return</span> traceleaf(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在exec中插入一个判断pid为1则执行vmprint即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>)</span><br><span class="line">      vmprint(p-&gt;pagetable);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>检验页是否被访问过。</p>
<p>根据实验提示，首先去去看pgaccess_test的函数，看看pgaccess是如何被使用的。pgaccess的参数有三个，类型分别是地址、int、地址，我猜测分别是检测的首地址(va)，被映射页数目，被使用过的页的记录(掩码的形式)。</p>
<p>然后将sys_pgaccess在kernel/sysproc.c中实现(已被声明)。然后参数还是通过argX去获取，根据上面提到的参数类型，分别使用addr, int, addr。程序运行完后将获得一个bitmask，是保存在内核内存中，需要使用copyout来将其复制到用户内存中。</p>
<p>至于页是否被使用，提示中需要我们定义一个叫PTE_A的flag在kernel/riscv.h中，让我们查看手册来查看该flag的作用:</p>
<blockquote>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared. The D bit indicates the virtual page has been written since the last time the D bit was cleared.</p>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart. Furthermore, the PTE update must appear in the global memory order no later than the explicit memory access, or any subsequent explicit memory access to that virtual page by the local hart. The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.</li>
</ul>
</blockquote>
<p>并且可以从Figure 4.15得知，PTE_A的值是6。该位是由硬件写入的，当被访问过则会置为1。</p>
<p>所以我们需要在sys_pgaccess中对每个页进行访问，检测该页的PTE_A，因此需要获取该页的pte。而根据提示，pte是通过walk获取的。最后在将该flag置零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//riscv.h</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//sysproc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_pgaccess</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  uint64 dstmask;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  argint(<span class="number">1</span>,&amp;num);                                                     </span><br><span class="line">  argaddr(<span class="number">2</span>,&amp;dstmask);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    uint64 pgva=addr+i*PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span>* pte=walk(p-&gt;pagetable,pgva,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte&amp;&amp;(*pte&amp;PTE_A))&#123;</span><br><span class="line">      mask|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">      *pte&amp;=~PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,dstmask,(<span class="keyword">char</span>*)&amp;mask,<span class="keyword">sizeof</span>(mask)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>title: 6.S081_Fall2020_lab<br>date: 2022-09-13 14:36:51<br>tags:<br>    - 笔记<br>    - 操作系统</p>
<hr>
<p>试试看自己能坚持写完吗。</p>
<!-- more -->

<h1 id="Lab1-Xv6-and-Unix-1"><a href="#Lab1-Xv6-and-Unix-1" class="headerlink" title="Lab1: Xv6 and Unix"></a>Lab1: Xv6 and Unix</h1><h2 id="sleep-1"><a href="#sleep-1" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">		sleep(tmp*<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong-1"><a href="#pingpong-1" class="headerlink" title="pingpong"></a>pingpong</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p1[<span class="number">2</span>],p2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	</span><br><span class="line">	pipe(p1);</span><br><span class="line">	pipe(p2);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fault in fork\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">		<span class="keyword">char</span> buf=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p1[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p2[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> buf;</span><br><span class="line">		</span><br><span class="line">		pid=getpid();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(buf)&#123;</span><br><span class="line">				write(p2[<span class="number">1</span>],&amp;buf,<span class="number">1</span>);</span><br><span class="line">				buf=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(!read(p1[<span class="number">0</span>],&amp;buf,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		close(p2[<span class="number">0</span>]);</span><br><span class="line">		close(p2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes-1"><a href="#primes-1" class="headerlink" title="primes"></a>primes</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> *lp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> prime,tmp;</span><br><span class="line"></span><br><span class="line">	close(lp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;prime,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&#123;</span><br><span class="line">			pipe(rp);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime)</span><br><span class="line">					write(rp[<span class="number">1</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">			&#125;<span class="keyword">while</span>(read(lp[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))==<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">			pid=fork();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;failed in fork\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				primes(rp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(rp[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				close(rp[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	if(argc!=2)&#123;</span></span><br><span class="line"><span class="comment">//		printf(&quot;bad argments.\n&quot;);</span></span><br><span class="line"><span class="comment">//		exit(-1);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	else num=atoi(argv[1]);</span></span><br><span class="line"></span><br><span class="line">	pipe(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num;i++)</span><br><span class="line">		write(p[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	primes(p);</span><br><span class="line">	close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fmtname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find first character after last slash.</span></span><br><span class="line">	<span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">		;</span><br><span class="line">	p++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return blank-padded name.</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">	<span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *path,<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">		close(fd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="keyword">case</span> T_DEVICE:</span><br><span class="line">	<span class="keyword">case</span> T_FILE:</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(filename,fmtname(path)))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> T_DIR:</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">		p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">		*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">			<span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			memmove(p, de.name, DIRSIZ);</span><br><span class="line">			p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(p,<span class="string">&quot;..&quot;</span>))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			find(buf,filename);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad args\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs-1"><a href="#xargs-1" class="headerlink" title="xargs"></a>xargs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv,<span class="keyword">int</span> bufnum,<span class="keyword">char</span> buf[][<span class="number">128</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bufnum;i++)</span><br><span class="line">		argv[argc+i]=buf[i];</span><br><span class="line">	exec(argv[<span class="number">0</span>],argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xargs</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>][<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> bufnum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[i],<span class="string">&quot;-n&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span>(*argv[i+<span class="number">1</span>]&lt;<span class="string">&#x27;9&#x27;</span> &amp;&amp; *argv[i+<span class="number">1</span>]&gt;<span class="string">&#x27;0&#x27;</span> &amp;&amp; !(<span class="built_in">strlen</span>(argv[i+<span class="number">1</span>])&gt;<span class="number">1</span>))</span><br><span class="line">			n=atoi(argv[++i]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments. n &lt;10 \n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)&#123;</span><br><span class="line">			len=read(<span class="number">0</span>,&amp;buf[i][j],<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(buf[i][j]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">				buf[i][j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		bufnum++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;bufnum&gt;<span class="number">0</span>;bufnum-=n,j++)&#123;</span><br><span class="line">			pid=fork();</span><br><span class="line">			<span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">				<span class="keyword">if</span>(bufnum&gt;=n)</span><br><span class="line">					solve(argc-i,&amp;argv[i],n,&amp;buf[j*n]);</span><br><span class="line">				<span class="keyword">else</span> solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		solve(argc-i,&amp;argv[i],bufnum,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">void</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* args[MAXARG];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;bad argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(argc&gt;MAXARG)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;too many argments.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)</span><br><span class="line">			args[i<span class="number">-1</span>]=argv[i];</span><br><span class="line"></span><br><span class="line">		xargs(i<span class="number">-1</span>,args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab2-system-calls-1"><a href="#Lab2-system-calls-1" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h1><h2 id="System-call-tracing-1"><a href="#System-call-tracing-1" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>根据提示，一个系统调用需要：</p>
<ul>
<li>在user/user.h 中声明，系统调用的用户态原型</li>
<li>user/usys.S 中生成供调用跳转内核态执行对应系统调用的入口条目</li>
<li>kernel/syscall.h 中有系统调用对应的编号(系统调用号)</li>
<li>系统调用对应的程序代码在 kernel/sysproc.c</li>
</ul>
<p>除此之外，实现 tracing 的系统调用还需要：</p>
<ul>
<li>kernel/proc.h 中的 proc 结构体添加一个新变量，用来储存追踪中的系统调用号，而且根据实验描述，这个变量其实是个掩码。tracing 系统调用的主要任务就是获取这个新的变量。</li>
<li>这个变量是通过 argint() 获取的，因为 trap 机制会将寄存器的值先全部保存在 trapframe 中，可以通过 argXXX() 来读取寄存器里的数值。</li>
<li>最后的打印追踪目标则放在 syscall 中实现。</li>
</ul>
<h2 id="Sysinfo-1"><a href="#Sysinfo-1" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retfreemem</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                                           </span><br><span class="line">	<span class="comment">// 该处需要初始化freemem,否则会得到错误的数值</span></span><br><span class="line">  addr-&gt;freemem=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 看别人师傅的代码上了锁，确实应该，免得错误访问内存而程序终止了</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">for</span>(struct run *tmp=kmem.freelist;tmp;tmp=tmp-&gt;next)</span><br><span class="line">    addr-&gt;freemem+=PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retnproc</span><span class="params">(struct sysinfo* addr)</span></span>&#123;                      </span><br><span class="line">	<span class="comment">// 同样需要初始化</span></span><br><span class="line">  addr-&gt;nproc=<span class="number">0</span>;                                                      </span><br><span class="line">  <span class="keyword">for</span>(struct proc *p=proc;p&lt;&amp;proc[NPROC];p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)</span><br><span class="line">      addr-&gt;nproc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  retfreemem(&amp;info);</span><br><span class="line">  retnproc(&amp;info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable,addr,(<span class="keyword">char</span>*)&amp;info,<span class="keyword">sizeof</span>(struct sysinfo))&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab3-page-tables-1"><a href="#Lab3-page-tables-1" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h1><h2 id="Speed-up-system-calls-1"><a href="#Speed-up-system-calls-1" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>内核态与用户态，会共享一个只读页，方便用户直接访问，能够提升速度，也是这个实验要做的。</p>
<p>根据提示，在proc_pagetable中映射地址。但是并没有说具体映射的页pa，看了别人写的，是仿造trapframe的相关代码来写的，在allocproc中给usyscall也创建一个页。接着是寻找到允许用户读的权限，权限是保存在riscv.h中，能看到一个PTE_U，他的注释是<code>user can access</code>。最后在allocproc中将其实现和初始化。</p>
<p>最后还需要完善，将释放内存和页表映射放进去，继续模仿就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct proc</span></span><br><span class="line">……</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>* <span class="title">usyscall</span>;</span>   <span class="comment">// user syscall</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//allocproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// create ussycall page</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;usyscall = (struct usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;usyscall-&gt;pid=p-&gt;pid;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    <span class="comment">// map ropage</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">                (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line"><span class="comment">//proc_pagetable</span></span><br><span class="line">……</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">……</span><br><span class="line"><span class="comment">//freeproc</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="keyword">void</span>*)p-&gt;usyscall);</span><br><span class="line">    p-&gt;usyscall=<span class="number">0</span>;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Print-a-page-table-1"><a href="#Print-a-page-table-1" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>跟着实验描述做，将第一个进程的页表打印出来，一看就觉得是树的遍历，再看输出格式应该是先序遍历。</p>
<p>因此vmprint应该使用递归来打印页表内容比较简单，又因为规定了需要写为vmprint仅有一个参数，所以在定义一个函数用来递归即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traceleaf</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;                                           </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> pte=pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte&amp;PTE_V)&#123;</span><br><span class="line">            uint64 child=PTE2PA(pte);</span><br><span class="line">            <span class="keyword">switch</span>(level)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                traceleaf((<span class="keyword">pagetable_t</span>)child,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,i,pte,child);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">    <span class="keyword">return</span> traceleaf(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在exec中插入一个判断pid为1则执行vmprint即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>)</span><br><span class="line">      vmprint(p-&gt;pagetable);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="Detect-which-pages-have-been-accessed-1"><a href="#Detect-which-pages-have-been-accessed-1" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>检验页是否被访问过。</p>
<p>根据实验提示，首先去去看pgaccess_test的函数，看看pgaccess是如何被使用的。pgaccess的参数有三个，类型分别是地址、int、地址，我猜测分别是检测的首地址(va)，被映射页数目，被使用过的页的记录(掩码的形式)。</p>
<p>然后将sys_pgaccess在kernel/sysproc.c中实现(已被声明)。然后参数还是通过argX去获取，根据上面提到的参数类型，分别使用addr, int, addr。程序运行完后将获得一个bitmask，是保存在内核内存中，需要使用copyout来将其复制到用户内存中。</p>
<p>至于页是否被使用，提示中需要我们定义一个叫PTE_A的flag在kernel/riscv.h中，让我们查看手册来查看该flag的作用:</p>
<blockquote>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared. The D bit indicates the virtual page has been written since the last time the D bit was cleared.</p>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart. Furthermore, the PTE update must appear in the global memory order no later than the explicit memory access, or any subsequent explicit memory access to that virtual page by the local hart. The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.</li>
</ul>
</blockquote>
<p>并且可以从Figure 4.15得知，PTE_A的值是6。该位是由硬件写入的，当被访问过则会置为1。</p>
<p>所以我们需要在sys_pgaccess中对每个页进行访问，检测该页的PTE_A，因此需要获取该页的pte。而根据提示，pte是通过walk获取的。最后在将该flag置零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//riscv.h</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//sysproc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_pgaccess</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  uint64 dstmask;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">  argint(<span class="number">1</span>,&amp;num);                                                     </span><br><span class="line">  argaddr(<span class="number">2</span>,&amp;dstmask);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    uint64 pgva=addr+i*PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span>* pte=walk(p-&gt;pagetable,pgva,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte&amp;&amp;(*pte&amp;PTE_A))&#123;</span><br><span class="line">      mask|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">      *pte&amp;=~PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,dstmask,(<span class="keyword">char</span>*)&amp;mask,<span class="keyword">sizeof</span>(mask)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h1><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>根据实验描述，我们需要完成函数backtrace，来遍历栈上各栈帧的返回地址。并在sys_sleep中加入对该函数的调用。</p>
<p>然后根据提示，首先在def.h中加入backtrace的声明，接着在riscv.h中添加代码(函数r_fp)，该代码是用来读取s0的值的，因为gcc会将正在执行的栈帧指针保存到s0中。</p>
<p>通过PGROUNDDOWN(fp)与PGROUNDUP(fp)来计算栈页面是否遍历尽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">  uint64 fp=r_fp();</span><br><span class="line">  uint64 ra=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;PGROUNDUP(fp)-PGROUNDDOWN(fp)==PGSIZE;)&#123;</span><br><span class="line">    ra=*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(fp<span class="number">-8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ra);</span><br><span class="line">    fp=*(uint64*)(fp<span class="number">-0x10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>根据实验提示，我们需要添加新的系统调用<code>sigalarm</code>和<code>sigreturn</code>。</p>
<p>然后再查看进行测试的代码user/alarmtest.c，发现这个sigalarm是每隔一段时间就想当前进程发送alarm信号，和定期发送信号的时间间隔，发送信号的间隔和处理函数就是sigalarm的两个参数</p>
<p>根据提示实现sigalarm：</p>
<ul>
<li>将报警间隔和指向处理程序函数的指针存储在struct proc的新字段中，该函数需要更新proc中的字段</li>
</ul>
<p>再根据提示修改user/trap.c:</p>
<ul>
<li>proc还需要一个字段，用来跟踪自上一次调用(或直到下一次调用)这个时间段之间，处理程序经历了多少次tick的计数</li>
<li>当产生了一次tick，就会强制中断一次，是在usertrap中实现的的时钟中断</li>
</ul>
<p>test0的主要任务是实现handler的调用，应该是通过时钟中断并根据当前的tick数来执行handler，再根据提示，应该是在usertrap的时钟中断部分进行修改</p>
<p>由于陷入后处于内核态，而handler是处于用户态的函数，然后根据提示，我们还需要将trapframe中的epc设置为handler</p>
<p>继续test1/test2/test3，这个需要我们完成sigreturn，也就是恢复中断的代码(我们之前仅仅是覆盖了epc)，就将返回前的trapframe保存一个副本在proc结构体中即可</p>
<p>继续实现sigalarm:</p>
<ul>
<li>proc结构体中加入一个flag，用来记录当前是否在执行alarm - 根据提示，在proc中加入一个trapframe的副本alarmframe，并在usertrap中复制trapframe的内容到其中</li>
</ul>
<p>实现sigreturn:</p>
<ul>
<li>在将之前存入的数据复制到trapframe</li>
<li>返回值填a0，不然过不了test3</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> interval;</span><br><span class="line">  <span class="keyword">void</span> (*handler)();</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>,&amp;interval);</span><br><span class="line">  argaddr(<span class="number">1</span>,(uint64*)&amp;handler);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(interval&lt;<span class="number">0</span>||handler&lt;<span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval=interval;</span><br><span class="line">  p-&gt;alarm_handler=handler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>=</span>myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;is_alarm)</span><br><span class="line">    memmove(p-&gt;trapframe, p-&gt;alarmframe, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">  p-&gt;is_alarm=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab5-device-drivers"><a href="#Lab5-device-drivers" class="headerlink" title="Lab5: device drivers"></a>Lab5: device drivers</h1><p>驱动程序是操作系统中管理特点设备的代码，用来配置硬件设备并告诉设备如何执行操作，并处理由此产生的中断，同时与正在等待设备的进程进行交互。由于需要理解硬件接口，因此需要查看文档。</p>
<p>驱动程序的代码通常分两部分执行，一部分是在系统调用中执行，还有一部分在中断时执行</p>
<h2 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h2><p>写时复制，因为fork会复制父进程的内存空间，这样效率太慢，因此改为浅拷贝，并在需要写入内存时才会进行深拷贝</p>
<p>根据实验给出的solution，需要实现的地方有，fork后获得父子进程的page对应的PTE全部设置为only-read，当进程尝试写入其中一个page时发生页中断，然后才进行一次深拷贝</p>
<p>根据实验提示，首先要修改uvmcopy，将父进程的physical page映射到子进程中，而不是分配新的page，最后清除两个进程PTE的可写权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">//char *mem;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">//if((mem = kalloc()) == 0)</span></span><br><span class="line">    <span class="comment">//  goto err;</span></span><br><span class="line">    <span class="comment">//memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line">    <span class="comment">//if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span></span><br><span class="line">    <span class="comment">//  kfree(mem);</span></span><br><span class="line">    <span class="comment">//  goto err;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    flags=flags&amp;~PTE_W;</span><br><span class="line">    *pte=PA2PTE(pa)|flags;</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>,i,PGSIZE,pa,flags)!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着修改usertrap以识别页面错误</p>
<ul>
<li><p>根据下图可以知道相应的scause是13和15，分别是load和store该page时会触发的中断<br><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMD_TK8Ar4GqWE6xfWV%2F-MMNmVfRDZSAOKze10lZ%2Fimage.png?alt=media&token=4bbfdfa6-1491-4ab8-8248-03bd0e36a8e9" alt="scause"></p>
</li>
<li><p>接着是复制对应page，那么首先就要找到产生页错误的页，即无法翻译的地址，这个地址是保存在stval寄存器中的。使用上个实验中差不多的代码r_stval返回这个寄存器中的地址。然后找到该地址对应的物理地址，使用的是walkaddr，接着还要修改两个page对应PTE。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cause==<span class="number">13</span>||cause==<span class="number">15</span>)&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> npage=kalloc();</span><br><span class="line"></span><br><span class="line">  uint64 va=r_stval();</span><br><span class="line">  uint64 pa=walkaddr(p-&gt;pagetable,va);</span><br><span class="line">  memmove(npage,pa,PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li>
<li><p>接着是要识别是否是cow，直接在PTE中加入一个flag，用来标记fork时的cow，使用保留的8为该flag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c(usertrap)</span></span><br><span class="line"> ……</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line">   va=PGROUNDDOWN(va);</span><br><span class="line"> </span><br><span class="line">   uint64 pa=walkaddr(p-&gt;pagetable,va);</span><br><span class="line">   <span class="keyword">pte_t</span>* pte=walk(p-&gt;pagetable,va,<span class="number">0</span>);</span><br><span class="line">   uint flags=PTE_FLAGS(*pte);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>((flags&amp;PTE_C)==<span class="number">0</span>)</span><br><span class="line">     setkilled(p);</span><br><span class="line"> </span><br><span class="line">   flags|=PTE_W;</span><br><span class="line">   flags&amp;=~PTE_C;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//if(refcount[(uint64)pa/PGSIZE]==1)&#123;</span></span><br><span class="line">   <span class="comment">//  *pte|=flags;</span></span><br><span class="line"><span class="number">1</span>  <span class="comment">//&#125;else&#123;</span></span><br><span class="line">     <span class="keyword">char</span>* mem;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>((mem=kalloc())==<span class="number">0</span>)</span><br><span class="line">       setkilled(p);</span><br><span class="line"> </span><br><span class="line">     *pte&amp;=~PTE_V;</span><br><span class="line"> </span><br><span class="line">     memmove(mem,(<span class="keyword">void</span>*)pa,PGSIZE);</span><br><span class="line">     <span class="keyword">if</span>((mappages(p-&gt;pagetable,va,PGSIZE,(uint64)mem,flags))!=    <span class="number">0</span>)&#123;</span><br><span class="line">       kfree(mem);</span><br><span class="line">       uvmunmap(p-&gt;pagetable,va,PGSIZE,<span class="number">1</span>);</span><br><span class="line">       *pte|=PTE_V;</span><br><span class="line">     &#125;</span><br><span class="line">     kfree((<span class="keyword">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li>
<li><p>接着pte的引用计数-1，这个引用计数需要我们自己设置，根据实验提示，这个引用计数是一个整形数组，并且这是全局变量，我定义在了kernel/kalloc.c中。数组的大小以及如何索引也给出了方案，<code>用页的物理地址除以4096对数组进行索引</code>，而数组的长度<code>等同于kalloc.c中kinit()在空闲列表中放置的所有页面的最高物理地址的元素数</code>也就是<code>PHYSTOP/4096</code>。然后在kalloc、kfree还有fork中添加对该计数的操作。需要注意的是，我们需要将该引用计数数组的初始值设置为1，否则在kinit中将不会生成freelist。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> refcount[PHYSTOP/PGSIZE]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64      )pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  refcount[(uint64)pa / PGSIZE]--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(refcount[(uint64)pa / PGSIZE] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span>                 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    refcount[(uint64)r/PGSIZE]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后一步，修改copyout。copyout会将内核空间中的内容复制到用户空间，这期间也涉及到了一个存储的过程。当我们的dst地址为PTE_C页时就需要我们申请一个新的page供复制内容。因此当我们执行与cow相同的步骤后就重新给pa0赋值这个新申请的内存即可，同样将va0重新映射pa0。所以我们把之前在usertrap中写的代码封装为一个函数，在这里使用，返回值是新申请的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">cow</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,uint64 va)</span></span>&#123;</span><br><span class="line">  uint64 pa=walkaddr(pagetable,va);</span><br><span class="line">  <span class="keyword">pte_t</span>* pte=walk(pagetable,va,<span class="number">0</span>);</span><br><span class="line">  uint flags=PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((flags&amp;PTE_C)==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  flags|=PTE_W;</span><br><span class="line">  flags&amp;=~PTE_C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((mem=kalloc())==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  *pte&amp;=~PTE_V;</span><br><span class="line"></span><br><span class="line">  memmove(mem,(<span class="keyword">void</span>*)pa,PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>((mappages(pagetable,va,PGSIZE,(uint64)mem,flags))!=<span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    uvmunmap(pagetable,va,PGSIZE,<span class="number">1</span>);</span><br><span class="line">    *pte|=PTE_V;</span><br><span class="line">  &#125; </span><br><span class="line">  kfree((<span class="keyword">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c(copyout)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64     len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">pte_t</span>* pte=walk(pagetable,va0,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> flags=PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    flags|=PTE_W;</span><br><span class="line">    flags&amp;=~PTE_C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                                                               </span><br><span class="line">    <span class="keyword">if</span>((*pte&amp;PTE_C))</span><br><span class="line">      pa0=(uint64)cow(pagetable,va0);</span><br><span class="line"></span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Lab6-Multithreading"><a href="#Lab6-Multithreading" class="headerlink" title="Lab6: Multithreading"></a>Lab6: Multithreading</h1><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>完成uthread测试，需要完成创建线程，保存和恢复寄存器内容。</p>
<p>先看看文件:</p>
<ul>
<li>user/uthread.c<ul>
<li>thread_init(): 初始化多线程，其实也就是设置全局变量current_thread。</li>
<li>thread_create(void (*func)()): 创建线程，我们的代码需要写在这里。</li>
<li>thread_schedule(): 切换线程，类似内核中的scheduler，遍历线程数组，找到状态为RUNNABLE的线程(若没有则使用数组中的第一个元素)且该线程不能是当前执行的线程，接着重新设置线程的状态为RUNNING，并修改current_thread为该线程。但很明显，这样没有什么实际作用，因此我们还需要在uthread_switch.S中添加代码来完善thread_switch()，并在这里使用。</li>
<li>thread_yeild(): 和内核中切换上下文的yeild差不多，重新设置线程的状态为RUNNALBLE并调用thread_schedule</li>
</ul>
</li>
<li>user/uthread_switch.S: 只有thread_switch函数，我们需要用汇编代码完成，感觉也应该类似内核中的swtch</li>
</ul>
<p>首先是实现线程的创建，线程是进程的一个执行单元，一个进程中可以不止一个线程。而代码在执行过程中需要自动动态分配的是栈空间，也就是说创建线程需要给每个线程创建一个不同栈空间。结果在uthread.c中的thread结构体中已经给我们分配好了栈，那还需要添加啥啊。</p>
<p>继续，thread_schedule中已经将修改状态写了，剩下只需要将thread_switch填充了就行了，可以仿造swtch来写(直接复制)，也就是保存和恢复寄存器。那我们还需要一个结构用来保存寄存器的内容(context)，那就在thread_create中添加一段代码来初始化这个context，然后在thread_switch中能够切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  memmove(&amp;t-&gt;context,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct thread_context));</span><br><span class="line">  t-&gt;context.sp=(uint64)t-&gt;<span class="built_in">stack</span>+STACK_SIZE;</span><br><span class="line">  t-&gt;context.ra=(uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于栈是从高地址向低地址生长的，因此这里的栈顶应该为栈空间的最后一个成员。</p>
<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>实验需要在一个真实的Linux中完成。</p>
<p>首先是一个哈希表的实现，notxv6/ph.c:</p>
<ul>
<li>程序需要读取一个整形参数(大于1)，作为线程数</li>
<li>哈希表的长度为5，即有5个bucket，根据不同的键将节点放入对应的bucket中。节点是entry结构体，其中包括一对键值对，还有下一个entry的地址。</li>
<li>有两个基准程序put和get<ul>
<li>put(): 将一对键值对添加到哈希表中</li>
<li>get(): 从哈希表中获取一对键值对</li>
</ul>
</li>
</ul>
<p>在编译后执行ph程序，通过不同数目的线程可以得到不同的结果，多线程会导致保存数据时不同步而出现<code>key missing</code>，单线程则不会。我们需要修改程序来避免出现丢失键的结果。</p>
<p>产生key missing的原因，是get_thread中调用get时没有获取到键。很显然是因为由于保存表中数据时产生的丢失。</p>
<p>表就是临界区，或者说是表中节点的地址，但如果直接在put前后加锁，由于其中有一个遍历的过程，所以效率太低了。我们再看的细致一点，该过程中的不变量为: 对应bucket指向当前链表头部，当key不存在于对应bucket链表中时，需要将新节点插入到链表的头部，即<strong>新节点的next指向原头部节点</strong>，然后<strong>哈希表中记录的原头部节点地址会被替换</strong>。这个不变量会在其他CPU执行insert后被违反，导致插入过程中数据被覆盖。</p>
<p>找到不变量后，insert也可以写的更凝练一点(去掉最后一个参数)，并在使用不变量前后加上锁(或者至少是在insert前后)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value, struct entry **p)</span><span class="comment">//, struct entry *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct entry)); ‣size: <span class="keyword">sizeof</span>(struct entry)</span><br><span class="line">  e-&gt;key = key;</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  pthread_mutex_lock(&amp;lock); ‣mutex: &amp;lock</span><br><span class="line">  e-&gt;next = *p;<span class="comment">//n;</span></span><br><span class="line">  *p = e;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock); ‣mutex: &amp;lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ps: 如果插入的是链表的尾部尾部就太麻烦了，还需要获取当前链表的长度，如果获取长度放在insert外，这个长度也是不变量(到达next为0节点的计数);放在insert内又是一个循环，效率降低</em></p>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>同步屏障，一种同步方法。对于一群进程或线程，程序中的一个同步屏障意味着任何线程/进程执行到此后必须等待，直到所有线程/进程都到达此点才可继续执行下文。</p>
<p>也是需要在一个真实的Linux中完成。</p>
<p>我们要实现一个barrier，在notxv6/barrier.c中有一个残缺的:</p>
<ul>
<li>接受一个参数作为线程数</li>
<li>barrier结构体中，包含一个互斥锁，一个条件变量，线程数目，当前轮数</li>
<li>barrier有几个相关函数:<ul>
<li>barrier_init(): 初始化barrier结构体</li>
<li>barrier(): 需要实现每个线程在barrier中阻塞，直到nthreads的所有线程都调用barrier</li>
</ul>
</li>
<li>thread中有一个循环，每次循环都会执行barrier</li>
</ul>
<p>需要使用到两个函数:</p>
<ul>
<li>pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex): 该函数会自动释放锁mutex并在被唤醒时重新获取，然后使调用线程在cond上休眠</li>
<li>pthread_cond_broadcast(pthread_cond_t *cond): 唤醒cond上的所有线程</li>
</ul>
<p>目标:</p>
<ul>
<li>每当所有线程执行一轮barrier，都增加一次round</li>
<li>每一个线程执行barrier时都记录一次nthread，并当nthread等于总线程时全部唤醒，一个线程重复进入barrier不会增加nthread</li>
</ul>
<p>这个实现简单多了，由于barrier结构体属于共享资源，是临界区，所以在修改nthread和round时需要上锁。然后每次执行增加nthread，并在唤醒后置0并round++。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex); ‣mutex: &amp;bstate.barrier_mutex</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread==nthread)&#123;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond); ‣cond: &amp;bstate.barrier_cond</span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex); ‣cond: &amp;<span class="function">bst</span></span><br><span class="line"><span class="function">  <span class="title">pthread_mutex_unlock</span><span class="params">(&amp;bstate.barrier_mutex)</span></span>; ‣mutex: &amp;bstate.barrier_mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lab7-Locks"><a href="#Lab7-Locks" class="headerlink" title="Lab7: Locks"></a>Lab7: Locks</h1><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><p>实现每个CPU的空闲列表，并在该列表为空是从其他地方窃取另一个CPU空闲列表的一部分。</p>
<p>根据实验描述和提示:</p>
<ol>
<li>使用freerange将空闲内存页分配到各个调用freerange的CPU中<ul>
<li>freerange就是将所有物理地址释放，kfree会将该内存也放入freelist中</li>
</ul>
<ol>
<li>也就是说，我们需要先为每个CPU创建一个空闲列表(kmem)</li>
<li>然后修改freerange和kfree，使其将释放的内存，全部放入当前CPU的freelist中</li>
</ol>
</li>
<li>接着需要从其他空闲列表中窃取空闲页，直接偷完会报错，只偷一个就好了</li>
</ol>
<p>首先是freelist，将kalloc中的kmem复制过来就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="keyword">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="keyword">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">	&#125; kmem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着说kalloc.c文件中的相关函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)</span><br><span class="line">    initlock(&amp;cpus[i].kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cur=cpuid();</span><br><span class="line">  acquire(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  r-&gt;next = cpus[cur].kmem.freelist;</span><br><span class="line">  cpus[cur].kmem.freelist = r;</span><br><span class="line">  release(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">steal</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==cur)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    acquire(&amp;cpus[i].kmem.lock);</span><br><span class="line">    r=cpus[i].kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)&#123;</span><br><span class="line">      cpus[cur].kmem.freelist=r;</span><br><span class="line">      cpus[i].kmem.freelist=r-&gt;next;</span><br><span class="line">      r-&gt;next=<span class="number">0</span>;</span><br><span class="line">      release(&amp;cpus[i].kmem.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;cpus[i].kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cur=cpuid();</span><br><span class="line">  acquire(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  r = cpus[cur].kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    cpus[cur].kmem.freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    steal(cur);</span><br><span class="line">    r = cpus[cur].kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">      cpus[cur].kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cpus[cur].kmem.lock);</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>steal功能主要是将一个节点从链表中取出并放入另一个链表。</p>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><p>该实验是要完善bcache，减少使用中发生的锁的竞争，</p>
<p>bcache是一个保存缓存字符的结构体，其中包括一个lock，用来保护不变量(head中的prev指向链表首部，next执行链表尾部)，一个缓冲区(struct buf)buf，一个链表头head用来将buf中的内容链起来，head不是指针，但里面也没有除了prev及next指针外的内容，感觉是一种浪费。</p>
<p>由于bget中使用遍历buf链表来获取指定block的缓冲区地址，若缓冲区中有保存则直接返回该缓冲区地址;若没有则会链表中插入block对应缓冲区的内容，在这个过程中需要给bcache上锁，很明显这是很奢侈的行为(临界区为循环)，所以我们可以使用粒度更细的锁或使用睡眠锁，正好head中的lock满足后者。</p>
<p>由于这时候我还没读完题目，直接就换个锁(一共就改了三行)，然后执行bcachetest确实是通过了grade，但是后来看到提示好像我想的太简单了(虽然我感觉没问题，head中的其他字段本来也是浪费的)。实验建议我们使用哈希表来存储缓冲区，通过查询块号来获取对应缓冲区与其锁。<em>使用哈希表来存储的意义在于，不用遍历整个表，而只需要得到哈希后的key即可访问对于链表，然后每个链表都有一个锁。</em></p>
<p>继续跟着提示来完成实验:</p>
<ul>
<li><p>使用固定数目的桶，而不动态调整哈希表的大小，并且使用素数个数(13)的桶来降低散列冲突的可能性</p>
</li>
<li><p>从该哈希表中查找缓冲区，并且当该缓冲区未被查找到时需要给这个缓冲区在哈希表中创建一个索引</p>
</li>
<li><p>删除缓冲区链表，并且不使用LRU(least recently used)来获取任意一个引用为0的缓冲区。</p>
<ol>
<li>首先创建一个哈希表，并清除使用的，哈希函数使用简单的取模。</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> NBKT 13</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> hash(x) (x%NBKT)</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bbucket</span>&#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="comment">//struct spinlock lock;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bbucket</span> <span class="title">btable</span>[<span class="title">NBKT</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>  bucket中的head不使用指针，是为了方便一些，可以直接使用原本代码，不需要大量修改。</p>
<ol start="2">
<li>并在binit中初始化bucket。</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"> <span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//initlock(&amp;bcache.lock, &quot;bcache&quot;);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Create linked list of buffers</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NBKT;i++)&#123;</span><br><span class="line">	  bcache.btable[i].head.prev = &amp;bcache.btable[i].head;</span><br><span class="line">	  bcache.btable[i].head.next = &amp;bcache.btable[i].head;</span><br><span class="line">	  initlock(&amp;bcache.btable[i].lock,<span class="string">&quot;btable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">	  b-&gt;prev=bcache.btable[<span class="number">0</span>].head.prev;</span><br><span class="line">	  b-&gt;next=&amp;bcache.btable[<span class="number">0</span>].head;</span><br><span class="line">	  b-&gt;prev-&gt;next=b;</span><br><span class="line">	  b-&gt;next-&gt;prev=b;</span><br><span class="line">	  initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在bget中使用串行化回收</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"> <span class="keyword">int</span> bkey=hash(blockno);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//acquire(&amp;bcache.lock);</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Is the block already cached?</span></span><br><span class="line"> acquire(&amp;bcache.btable[bkey].lock);</span><br><span class="line"> <span class="keyword">for</span>(b = bcache.btable[bkey].head.next; b != &amp;bcache.btable[bkey].head; b = b-&gt;next)&#123;</span><br><span class="line">   <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">     b-&gt;refcnt++;</span><br><span class="line">     acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">     <span class="comment">//release(&amp;bcache.lock);</span></span><br><span class="line">     release(&amp;bcache.btable[bkey].lock);</span><br><span class="line">     <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> release(&amp;bcache.btable[bkey].lock);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Not cached.</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NBKT;i++)&#123;</span><br><span class="line">   acquire(&amp;bcache.btable[i].lock);</span><br><span class="line">   <span class="keyword">for</span>(b = bcache.btable[i].head.prev; b != &amp;bcache.btable[i].head; b = b-&gt;prev)&#123;</span><br><span class="line">     <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        b-&gt;prev-&gt;next=b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev=b-&gt;prev;</span><br><span class="line">        b-&gt;prev=bcache.btable[bkey].head.prev;</span><br><span class="line">        b-&gt;next=&amp;bcache.btable[bkey].head;</span><br><span class="line">        b-&gt;prev-&gt;next=b;</span><br><span class="line">        b-&gt;next-&gt;prev=b;</span><br><span class="line"></span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="comment">//release(&amp;bcache.lock);</span></span><br><span class="line">        release(&amp;bcache.btable[i].lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;bcache.btable[i].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  串行化回收也就是同时仅有一个cpu在回收该链表，因此需要获取链表锁。</p>
</li>
<li><p>最后再修改其他函数(使用了bcache锁)</p>
</li>
</ul>
<p><em>在实验时保留bcache中的锁并且最后在给各部分加锁对于完成实验更加方便。</em></p>
<p>另外，踩了一个坑: 我一开始以为，没有了全局锁后在访问缓冲区前就需要获取缓冲区的睡眠锁。后来想明白，因为同一时刻只会有一个cpu访问一个链表(缓冲区的修改需要先获取链表锁，给忘了)，甚至于缓存区的睡眠锁在该锁外获取都行(8.3节)。而且整个实验中使用的比较多的是链表锁且不能使用缓冲区的睡眠锁(不能使用缓冲区锁的地方还有bpin和bunpin中)。对于这个缓冲区锁我还是有疑惑。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/25/musl%E5%88%9D%E8%AF%86/" rel="prev" title="musl初识">
      <i class="fa fa-chevron-left"></i> musl初识
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/25/MTCTF2022-pwn-wp/" rel="next" title="MTCTF2022_初赛pwn_wp">
      MTCTF2022_初赛pwn_wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab1-Xv6-and-Unix"><span class="nav-number">1.</span> <span class="nav-text">Lab1: Xv6 and Unix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep"><span class="nav-number">1.1.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pingpong"><span class="nav-number">1.2.</span> <span class="nav-text">pingpong</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#primes"><span class="nav-number">1.3.</span> <span class="nav-text">primes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find"><span class="nav-number">1.4.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs"><span class="nav-number">1.5.</span> <span class="nav-text">xargs</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab2-system-calls"><span class="nav-number">2.</span> <span class="nav-text">Lab2: system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System-call-tracing"><span class="nav-number">2.1.</span> <span class="nav-text">System call tracing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sysinfo"><span class="nav-number">2.2.</span> <span class="nav-text">Sysinfo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab3-page-tables"><span class="nav-number">3.</span> <span class="nav-text">Lab3: page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Speed-up-system-calls"><span class="nav-number">3.1.</span> <span class="nav-text">Speed up system calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Print-a-page-table"><span class="nav-number">3.2.</span> <span class="nav-text">Print a page table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Detect-which-pages-have-been-accessed"><span class="nav-number">3.3.</span> <span class="nav-text">Detect which pages have been accessed</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab1-Xv6-and-Unix-1"><span class="nav-number">4.</span> <span class="nav-text">Lab1: Xv6 and Unix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-1"><span class="nav-number">4.1.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pingpong-1"><span class="nav-number">4.2.</span> <span class="nav-text">pingpong</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#primes-1"><span class="nav-number">4.3.</span> <span class="nav-text">primes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find-1"><span class="nav-number">4.4.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs-1"><span class="nav-number">4.5.</span> <span class="nav-text">xargs</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab2-system-calls-1"><span class="nav-number">5.</span> <span class="nav-text">Lab2: system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System-call-tracing-1"><span class="nav-number">5.1.</span> <span class="nav-text">System call tracing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sysinfo-1"><span class="nav-number">5.2.</span> <span class="nav-text">Sysinfo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab3-page-tables-1"><span class="nav-number">6.</span> <span class="nav-text">Lab3: page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Speed-up-system-calls-1"><span class="nav-number">6.1.</span> <span class="nav-text">Speed up system calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Print-a-page-table-1"><span class="nav-number">6.2.</span> <span class="nav-text">Print a page table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Detect-which-pages-have-been-accessed-1"><span class="nav-number">6.3.</span> <span class="nav-text">Detect which pages have been accessed</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab4-traps"><span class="nav-number">7.</span> <span class="nav-text">Lab4: traps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Backtrace"><span class="nav-number">7.1.</span> <span class="nav-text">Backtrace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alarm"><span class="nav-number">7.2.</span> <span class="nav-text">Alarm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab5-device-drivers"><span class="nav-number">8.</span> <span class="nav-text">Lab5: device drivers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Implement-copy-on-write-fork"><span class="nav-number">8.1.</span> <span class="nav-text">Implement copy-on-write fork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab6-Multithreading"><span class="nav-number">9.</span> <span class="nav-text">Lab6: Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Uthread-switching-between-threads"><span class="nav-number">9.1.</span> <span class="nav-text">Uthread: switching between threads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-threads"><span class="nav-number">9.2.</span> <span class="nav-text">Using threads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Barrier"><span class="nav-number">9.3.</span> <span class="nav-text">Barrier</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab7-Locks"><span class="nav-number">10.</span> <span class="nav-text">Lab7: Locks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-allocator"><span class="nav-number">10.1.</span> <span class="nav-text">Memory allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-cache"><span class="nav-number">10.2.</span> <span class="nav-text">Buffer cache</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MEssa_Rabbit"
      src="/images/myavatar.png">
  <p class="site-author-name" itemprop="name">MEssa_Rabbit</p>
  <div class="site-description" itemprop="description">菜狗一个</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:messap2001@gmail.com" title="E-Mail → mailto:messap2001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">undefined </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEssa_Rabbit</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
