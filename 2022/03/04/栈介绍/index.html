<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>栈介绍 | Rabbit hole | We don&#39;t choose who we are, but we do choose who we become.</title>

  
  <meta name="author" content="MEssa_Rabbit">
  

  
  <meta name="description" content="菜狗一个">
  

  
  
  <meta name="keywords" content="笔记,CTF">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="栈介绍"/>

  <meta property="og:site_name" content="Rabbit hole"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rabbit hole" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Rabbit hole</a>
    </h1>
    <p class="site-description">We don&#39;t choose who we are, but we do choose who we become.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>栈介绍</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/03/04/栈介绍/" rel="bookmark">
        <time class="entry-date published" datetime="2022-03-04T01:05:42.000Z">
          2022-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>对于此数据结构，我们不过多讲述，仅以执行程序时内存中的运行时栈来简单讲讲。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>栈是一种只允许在一端插入或删除的线性表，且允许插入和删除的一端称为栈顶，另一端称为栈底。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>在执行程序时，系统会为这个程序分配一块虚拟地址空间，这块空间中的一部分为该程序对应的<strong>运行时栈</strong>。当一个<code>x86-64</code>过程需要的存储空间超过了寄存器能够存放的大小时，或需要保存局部变量时，就会在栈上分配空间。这个部分称为<strong>过程</strong>的<strong>栈帧</strong>(Stack Frame)。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。具体见下图</p>
<p><img src="https://s2.loli.net/2022/03/05/HAdJVeYC9BiNcT2.png" alt="32位模式下内存经典布局"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>后进先出(LIFO)：由于栈只允许在一端插入或删除，因此具有此特性，并称为LIFO(Last In First Out)。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>即入栈，插入新的元素作为栈顶。</p>
<h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><p>即出栈，取出栈顶元素。</p>
<p>在程序运行时栈中也是以入栈与出栈为基本操作。</p>
<h2 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h2><p>到目前为止，大部分过程都不会出现超过寄存器大小的本地存储区域了，不过有时，局部数据还是要存放在内存中，包括：寄存器不足而存放、一个变量的地址要存放、某些局部变量是数组或结构体只能存放在内存中。</p>
<p>而过程中产生的局部变量存储在栈帧中，过程的参数存储在该栈帧前。并且通过入栈顺序和数据大小能轻易计算出与栈帧的偏移，并通过<code>lea</code>指令与<code>rbp</code>寄存器中保存的栈帧地址来得到变量的地址，从而使用。<a href="https://messap.github.io/2022/03/04/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">函数调用约定</a></p>
<h2 id="函数调用栈的过程"><a href="#函数调用栈的过程" class="headerlink" title="函数调用栈的过程"></a>函数调用栈的过程</h2><p>简单介绍一下过程。</p>
<p>前面提到在程序运行中，栈会有属于自己的一块空间，并且会分配<strong>过程的栈帧</strong>。实际上，软件中将封装代码的方式称为过程，过程用一组指定参数和一个可选的返回值实现了某种功能。因此我们能想到：函数、方法、处理函数等都是<strong>过程的形式</strong>。</p>
<p>而函数调用栈的过程，实际上对应了计算机提供给过程执行的支持：<strong>传递控制、传递数据、分配和释放内存</strong>。</p>
<p>具体过程为:</p>
<ol>
<li>先是<strong>传递数据</strong>，将此函数所使用到的参数依次入栈，然后得到数据与栈帧指针的偏移来利用数据。</li>
<li>再是<strong>转移控制</strong><ol>
<li>执行了<code>call</code>指令，进行两步操作：<ol>
<li>将当前<code>ip</code>或<code>cs和ip</code>压入栈中，即<code>push ip</code></li>
<li>转移，与<code>jmp</code>原理相同</li>
</ol>
</li>
</ol>
</li>
<li>接着执行函数<strong>分配内存</strong>：<ol>
<li>将<code>bp</code>压入栈，即<code>push bp</code></li>
<li>减小栈指针，即<code>sub sp,idata</code>，分配了足够大的栈帧空间</li>
</ol>
</li>
<li>函数终止，开始<strong>释放内存</strong>：<ol>
<li>执行<code>leave</code>指令，进行两步操作：<ol>
<li>释放栈空间，即<code>mov sp,bp</code></li>
<li>恢复栈帧，即<code>pop bp</code></li>
</ol>
</li>
<li>最后<strong>恢复控制</strong>，执行<code>ret</code>指令：<ul>
<li>修改<code>ip</code>内容为栈顶中的内容，即<code>pop ip</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>至此算是一个函数调用的过程，且无论是在32位平台还是64位平台都是如此，由此可以看出<strong>过程能够递归的调用它们自身</strong>，并且每个过程都有属于自己的栈帧。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/笔记/">笔记</a><a href="/tags/CTF/">CTF</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 MEssa_Rabbit
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>