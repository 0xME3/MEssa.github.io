<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>linux保护机制 | Rabbit hole | We don&#39;t choose who we are, but we do choose who we become.</title>

  
  <meta name="author" content="MEssa_Rabbit">
  

  
  <meta name="description" content="菜狗一个">
  

  
  
  <meta name="keywords" content="笔记,pwn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="linux保护机制"/>

  <meta property="og:site_name" content="Rabbit hole"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rabbit hole" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Rabbit hole</a>
    </h1>
    <p class="site-description">We don&#39;t choose who we are, but we do choose who we become.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>linux保护机制</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/03/08/GCC保护机制/" rel="bookmark">
        <time class="entry-date published" datetime="2022-03-08T13:10:33.000Z">
          2022-03-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>简单介绍Linux下的保护机制。</p>
<span id="more"></span>

<h2 id="地址随机化-ASLR-PIE"><a href="#地址随机化-ASLR-PIE" class="headerlink" title="地址随机化(ASLR/PIE)"></a>地址随机化(ASLR/PIE)</h2><p>在我们之前介绍的ROP攻击中，我们的主要目的是插入一个指向攻击代码的<strong>指针</strong>，这个代码可以是我们输入的(ret2shellcode)，也可以是程序中有的(ret2text、ret2libc)。</p>
<p>而当我们在同一个操作系统版本上运行同一个程序，即使是不同机器，栈的位置也是固定的，这使得栈地址非常容易被预测。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>栈随机化的思想就是使程序每次运行时，都使得栈的位置在变化。它的简单实现方式是：在程序开始时，在栈上分配一个指定的0~n个字节之间的随机大小空间，程序不使用这段空间，但它会导致程序执行时，后续的栈的位置发生了变化。而这个值n不能太大(太大浪费)，也不能太小(太小得到的随机化地址变化太少)，在32位linux中，地址大致分布在<code>0xff7fc59c</code>到<code>0xffffd09c</code>内,范围大约为2^23^；64位linux中，地址大致分布在<code>0x7fff000比98</code>到<code>0x7ffffffaa4a8</code>内，范围大约为2^32^。</p>
<p> 在Linux中，堆栈地址和动态链接库基地址随机化是属于<strong>地址空间布局随机化</strong>技术中的一种(简称ASLR，address-space layout randomization)，而整个ASLR技术比较复杂。采用ASLR技术，使得每次运行时，除了栈外的程序中的其他段也都会被加载到内存中的不同区域，保护性更强。PIE则是再对整个ELF文件的基地址(代码段数据段受影响)进行随机化。</p>
<h3 id="克服方法"><a href="#克服方法" class="headerlink" title="克服方法"></a>克服方法</h3><ul>
<li>泄露地址<ul>
<li>格式化字符串漏洞泄露栈上地址</li>
<li>构造ROPchain调用输出函数，将got表中存储的地址泄露</li>
</ul>
</li>
<li>若不能泄露地址，也能够通过暴力手段克服随机化保护<ul>
<li>若能够执行到我们写入的攻击代码，那么我们可以在有效的攻击代码前插入很长一段<code>nop</code>指令，然后只需要猜中其中一段指令的地址写入，那么在执行时就一定会执行到有效的攻击代码。这样的整个攻击代码称作”空操作雪橇”(“nop sled”)。</li>
</ul>
</li>
</ul>
<h2 id="栈破坏检测-Stack-Canary"><a href="#栈破坏检测-Stack-Canary" class="headerlink" title="栈破坏检测(Stack Canary)"></a>栈破坏检测(Stack Canary)</h2><p>栈破坏检测能有效的防止利用栈溢出漏洞来破坏栈上的结构</p>
<p><em>canary：金丝雀。矿工下矿前会放一只鸟进去，能够提前预知意外。</em></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在栈帧中放入一段canary值，开启了栈破坏检测保护的程序，执行时会随机产生canary。在程序恢复寄存器状态和从函数返回前，程序都会检测canary是否被改变，如果是，那么程序异常结束。</p>
<h3 id="克服方法-1"><a href="#克服方法-1" class="headerlink" title="克服方法"></a>克服方法</h3><p>canary通常存放在栈帧上第一个内存地址中，可以通过调试进行寻找，它的标志是最后一字节为<code>0x00</code>，是为了防止输出下一个内存地址时将其泄露，且该位不属于被检测的部分。</p>
<ul>
<li>泄露canary，之后将其加入payload中的指定位置<ul>
<li>若程序能够输出我们写入的字符串，并且存在栈溢出漏洞，那么能够利用该漏洞将canary的最后一位给覆盖掉，再执行输出时能够泄露。</li>
<li>利用格式化字符串漏洞直接泄露</li>
</ul>
</li>
<li>若不能泄露canary，其实我们能够利用其机制来泄露其他信息，原理是：程序检测canary，实际上是通过调用<code>__stack_chk_fail</code>函数来实现的。在检测到canary异常时，会打印出<code>__libc_argv[0]</code>指针指向的内容，一般为程序名。那么我们利用漏洞，将argv[0]的内容改为其他信息的地址，在执行报错时就会泄露信息。</li>
</ul>
<h2 id="限制可执行代码区域-NX"><a href="#限制可执行代码区域-NX" class="headerlink" title="限制可执行代码区域(NX)"></a>限制可执行代码区域(NX)</h2><p>虚拟内存中，存在’页’的概念，一个页的大小一般是2048或4096个字节。典型的程序保护中，每个页都有一个标志，该标志的每位由硬件检测并指明该页的’可读’、’可写’、’可执行’权限。曾经<code>x86</code>体系将’可读’和’可执行’合并成一个标志位，而栈上数据一定是可读写的，所以会有向栈中写入攻击代码而被执行的危险。虽然有过很多机制，能够限制一些页的可读但是不可执行，却会带来严重的性能损失。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>向内存中引入了’NX’(No-Execute)位，将’可读’和’可执行’权限分开来了，而页依旧由硬盘来检测，效率没有损失。</p>
<h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>read only relocation, 可以分为Full Relro和Partial Relro，其作用主要是禁止.GOT节与其他一些内存的可写权限。</p>
<ul>
<li>GCC的默认编译为partial Relro模式，该模式下，一些节和.GOT节是可写的。</li>
<li>而Full Relro模式下，所有地址都在开始时绑定，然后将.GOT表对应的页设置为不可写的权限。</li>
</ul>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在计算机的大部分需要绑定地址的操作中，都存在一个lazy机制，即需要访问时才会被第一次加载，这样做能极大的提高程序运行的效率。但就是这个lazy binding机制，导致程序需要将进行重定向的.GOT节设置为可写权限，因此黑客可以覆盖该节上的地址为指定目的地址来getshell。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/笔记/">笔记</a><a href="/tags/pwn/">pwn</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 MEssa_Rabbit
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>