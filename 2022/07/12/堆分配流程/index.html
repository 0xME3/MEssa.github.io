<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bigbug_favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.rabb1t.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="以 glibc 2.23 的源码为例">
<meta property="og:type" content="article">
<meta property="og:title" content="堆分配流程">
<meta property="og:url" content="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Rabbit hole">
<meta property="og:description" content="以 glibc 2.23 的源码为例">
<meta property="og:locale">
<meta property="article:published_time" content="2022-07-12T09:38:48.000Z">
<meta property="article:modified_time" content="2022-08-16T08:54:09.820Z">
<meta property="article:author" content="MEssa_Rabbit">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>堆分配流程 | Rabbit hole</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rabbit hole</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">We don't choose who we are, but we do choose who we become.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/links/" rel="section"><i class="fa-links fa-fw"></i>friends</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myavatar.png">
      <meta itemprop="name" content="MEssa_Rabbit">
      <meta itemprop="description" content="菜狗一个">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rabbit hole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          堆分配流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-12 17:38:48" itemprop="dateCreated datePublished" datetime="2022-07-12T17:38:48+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-16 16:54:09" itemprop="dateModified" datetime="2022-08-16T16:54:09+08:00">2022-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>以 glibc 2.23 的源码为例</p>
<span id="more"></span>

<h2 id="分配过程概述"><a href="#分配过程概述" class="headerlink" title="分配过程概述"></a>分配过程概述</h2><ol>
<li><p>进行分配之前主要进行的操作有：检查 hook 并执行；获取 arena；检查 size  并规范化；检查 arena 是否可用</p>
</li>
<li><p>然后进行 fast_bin 相关检查与分配</p>
<ul>
<li><p>检查大小是否属于 fast_chunk 范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br></pre></td></tr></table></figure></li>
<li><p>若 chunk 属于 fast_bin，则依次获取 fast_bin 与 size 对应的 index、该 index 对应 fast bin 处于的 arena 中的位置、该 fast_bin 对应链表的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idx = fastbin_index (nb);</span><br><span class="line">mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">mchunkptr pp = *fb;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历尾指针的 fd 获取 fast_bin 的头指针，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br></pre></td></tr></table></figure></li>
<li><p>若该 fast_bin 不为空，则会最后再检查，被检查的数据包括 arena、chunk_size、index。若通过则返回 mem_chunk 地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">		errout:</span><br><span class="line">		alloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	check_remalloced_chunk (av, victim, nb);</span><br><span class="line">	<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>若不属于 fast_chunk 范围，则进入 small_bins 的相关检查与分配</p>
<ul>
<li><p>检查是否属于 small_chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br></pre></td></tr></table></figure></li>
<li><p>若 chunk 属于 small_bin，则依次获取对应 small_bin 的 index、该 index 所对应的链表的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure></li>
<li><p>获取该 small_bin 的首指针，并判断该 small_bin 是否不为空(为空则<code>last(bin)=bin-&gt;bk=bin</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br></pre></td></tr></table></figure></li>
<li><p>判断该 small_bin 是否存在，不存在则进行初始化(不存在即未初始化，arena 中是空的)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">	malloc_consolidate (av);</span><br></pre></td></tr></table></figure></li>
<li><p>存在则接着会进行一次检测，检测<code>bck-&gt;fd=victim-&gt;bk-&gt;fd==victim</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置该 small_chunk 对应的 inuse 位，并将该 small_chunk 从对应 small_bin 中取出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure></li>
<li><p>接着判断该 arena 是否属于 main_arena，最后再通过一次大小的检查，才会返回 mem_chunk 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若不属于 small_chunk，则一定属于 large_chunk，因此获取对应 index，然后查看 arena 中是否有 fast_chunk，有则调用一次 consolidate(合并空闲 fast_chunks)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	idx = largebin_index (nb);</span><br><span class="line">	<span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">		malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接着进入 unsorted_bin 相关的各种操作，这些操作被放入一个循环中。</p>
<ul>
<li><p>获取 unsorted bin 的头指针，并且判断此时 unsorted bin 是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br></pre></td></tr></table></figure></li>
<li><p>不为空，则进入循环，首先获取 victim 的 bk 指针，接着对 victim 的大小进行检查，通过则获取该大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, hunk2mem (victim), av);</span><br><span class="line">size = chunksize (victim);</span><br></pre></td></tr></table></figure></li>
<li><p>依次判断所申请 chunk_size 是否属于 small_chunk 范围、bck 是否属于 unsorted_bin、victim 是否属于 last_remainder、victim_size 是否大于所申请 chunk_size+MINSIZE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></li>
<li><p>满足，则从 last_remainder 中切割，并将 remainder 重新分配给 small_bin or large_bin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset (victim, nb);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">av-&gt;last_remainder = remainder;</span><br><span class="line">remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">&#123;</span><br><span class="line">	remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若不属于 last_remainder，则从 unsorted_bin 中取出 victim</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></li>
<li><p>接着判断大小是否刚好合适</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == nb)</span><br></pre></td></tr></table></figure></li>
<li><p>合适则直接分配给用户</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_inuse_bit_at_offset (victim, size);</span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>若以上仍未返回 chunk，则会将 unsorted_bin 中剩余的 chunk 分配到 small_bin 和 large_bin 中，先是 small_bin 的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">	victim_index = smallbin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>否则，再是 larege_bin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	victim_index = largebin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure></li>
<li><p>但在这个过程中，比之上一步分配到 small_bin 中的过程有些许不同。相较于 small_chunk， large_chunk 还有两个 next_size 属性。因此若 large_bins 不为空，则还需要将 victim 链表插入到 large_bins 链表中正确的位置。若 victim_size 小于最小的 large_bin_size，则直接插入该 large_bin 前，成为一个新的 large_bin。否则将在 large_bins 中遍历直到某个 large_bin 的大小刚好等于 victim_size，则无需设置 next_size，待之后直接插入该 large_bin 末尾即可；或刚好大于 victim_size，则将 victim 插于其后，成为一个新的 large_bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">	size |= PREV_INUSE;</span><br><span class="line">	<span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">	assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">	&#123;</span><br><span class="line">		fwd = bck;</span><br><span class="line">		bck = bck-&gt;bk;</span><br><span class="line">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">			<span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">			fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			victim-&gt;fd_nextsize = fwd;</span><br><span class="line">			victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">			fwd-&gt;bk_nextsize = victim;</span><br><span class="line">			victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">		&#125;</span><br><span class="line">		bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若该 larege_bin 为空，则直接插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">	victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后插入 victim</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></li>
<li><p>最后设置了这个循环的最大循环次数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">	<span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将 unsorted_bin 中的 chunk 分配到其他 bins 中后，才会从 large_bin 中取出 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取 main_arena 中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure></li>
<li><p>对该 large_bin 进行检查，是否为空或是所申请的 size 大于该 bins 中最大的 chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br></pre></td></tr></table></figure></li>
<li><p>满足条件则从后向前遍历该 bin，直至找出一个 next_size 链表对应的大小大于申请的 size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">victim = victim-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure></li>
<li><p>尽量从链表的末尾取出 chunk，避免多余的变动(最后一个 next_size 链表除外)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Avoid removing the first entry for a size so that the skip list does not have to be rerouted.  */</span></span><br><span class="line"><span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">	victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure></li>
<li><p>获得 remainder_size，同时取出 victim</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure></li>
<li><p>检查 remainder_size 是否小于 MINSIZE，小于则不切割直接分配出去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">&#123;</span><br><span class="line">	set_inuse_bit_at_offset (victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>否则，就对 victim 进行切割，剩余部分划入 unsorted_bin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	remainder = chunk_at_offset (victim, nb);</span><br><span class="line">	<span class="comment">/* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here.  */</span></span><br><span class="line">	bck = unsorted_chunks (av);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	remainder-&gt;bk = bck;</span><br><span class="line">	remainder-&gt;fd = fwd;</span><br><span class="line">	bck-&gt;fd = remainder;</span><br><span class="line">	fwd-&gt;bk = remainder;</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">	&#123;</span><br><span class="line">		remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">		remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot (remainder, remainder_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后，将 victim 分配出去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>若还没将 chunk 分配出去，则在从下一个更大的 large_bin (对应更大的 idx)中获取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>再次进入一个循环，首先检查 bit 的正确性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">	<span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>若 bit 正确，则遍历 binmap，直至遇到不为空的 large_bin，接着获得该 bin 处于 arena 中的位置，并设置 bit 为 1；若都为空，则跳过整个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">		<span class="keyword">goto</span> use_top;</span><br><span class="line">&#125;<span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">bit = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 bit 来确定 map 的最高位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	bin = next_bin (bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	assert (bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取该 bin 的最后一个 chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last (bin);</span><br></pre></td></tr></table></figure></li>
<li><p>若该 bin 为空，则换下一个 bin，bit 也改变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim == bin)</span><br><span class="line">&#123;</span><br><span class="line">	av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">	bin = next_bin (bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不为空，则获取该 chunk_size、remainder_size，并将 victim 取出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">	assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* unlink */</span></span><br><span class="line">	unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure></li>
<li><p>接下来就是将 remainer 分配出去的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">&#123;</span><br><span class="line">	set_inuse_bit_at_offset (victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here.  */</span></span><br><span class="line">	bck = unsorted_chunks (av);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	&#123;</span><br><span class="line">		errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	remainder-&gt;bk = bck;</span><br><span class="line">	remainder-&gt;fd = fwd;</span><br><span class="line">	bck-&gt;fd = remainder;</span><br><span class="line">	fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* advertise as last remainder */</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">		av-&gt;last_remainder = remainder;</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">	&#123;</span><br><span class="line">		remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">		remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot (remainder, remainder_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后返回 mem_chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>至此，整个 bins 的大循环结束，若仍未返回，则会使用 top_chunk 来分出 chunk</p>
<ul>
<li><p>获取 top_chunk 与 top_chunk_size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br></pre></td></tr></table></figure></li>
<li><p>判断 top_chunk，是否满足申请大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></li>
<li><p>满足则进行 remainder 的切割分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset (victim, nb);</span><br><span class="line">av-&gt;top = remainder;</span><br><span class="line">set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>不满足，则会检查是否含有 fast_chunk。并合并 fast_chunks，获取所申请的 chunk_size 对应的 idx</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">&#123;</span><br><span class="line">	malloc_consolidate (av);</span><br><span class="line">	<span class="comment">/* restore original bin index */</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">		idx = smallbin_index (nb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若无 fast_bin 为空，则调用 sysmalloc，再次申请一块内存来分配，并作为新的 top_chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>若分配不成功，则会再次寻找可用 arena，调用 _int_malloc，最后释放 arena。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>申请 chunk 的大小不属于 small_chunk 的范围则会合并空闲 fast_chunks</p>
</li>
<li><p>top_chunk 不满足分配会合并空闲 fast_chunks</p>
</li>
<li><p>unsorted_bin 的循环再被执行时，会将其中的 chunks 分配到 small_bins 和 large_bins 中</p>
</li>
<li><p>unsorted_bin 中分配 chunk，先从 last_remainder 中分配，接着是 small_bins，然后是 unsorted_bin，最后是 large_bins</p>
</li>
<li><p>bins 中以 bin-&gt;fd 为第一个 chunk，bin-&gt;bk 为最后一个 chunk</p>
</li>
<li><p>从 fast_bin 中分配时，会遍历 fd，即从尾开始(FILO)；</p>
<p>从 small_bin 中分配时，会遍历 bk，即从头开始(FIFO)；</p>
<p>从 unsorted_bin 中分配时，会遍历 bk，即从头开始(FIFO)；</p>
<p>从 large_bin 中分配时，会遍历 fd，即从尾开始(FILO)；</p>
</li>
<li><p>从 large_bin 中申请 chunk 时，是从后向前遍历查询，即 next_size 从后向前依次增大</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/pwn/" rel="tag"><i class="fa fa-tag"></i> pwn</a>
              <a href="/tags/heap/" rel="tag"><i class="fa fa-tag"></i> heap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/09/heap/" rel="prev" title="heap 简介">
      <i class="fa fa-chevron-left"></i> heap 简介
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF2022-pwn-wp/" rel="next" title="蓝帽杯2022初赛_pwn_wp">
      蓝帽杯2022初赛_pwn_wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">分配过程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MEssa_Rabbit"
      src="/images/myavatar.png">
  <p class="site-author-name" itemprop="name">MEssa_Rabbit</p>
  <div class="site-description" itemprop="description">菜狗一个</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:messap2001@gmail.com" title="E-Mail → mailto:messap2001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEssa_Rabbit</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
