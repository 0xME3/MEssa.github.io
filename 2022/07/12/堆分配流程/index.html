<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bigbug_favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.rabb1t.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="以glibc 2.23的源码为例，主要查看malloc.c">
<meta property="og:type" content="article">
<meta property="og:title" content="堆分配流程_ptmalloc源码分析">
<meta property="og:url" content="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Rabbit hole">
<meta property="og:description" content="以glibc 2.23的源码为例，主要查看malloc.c">
<meta property="og:locale">
<meta property="article:published_time" content="2022-07-12T09:38:48.000Z">
<meta property="article:modified_time" content="2023-11-19T08:51:16.000Z">
<meta property="article:author" content="MEssa_Rabbit">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>堆分配流程_ptmalloc源码分析 | Rabbit hole</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rabbit hole</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">We don't choose who we are, but we do choose who we become.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/links/" rel="section"><i class="fa-links fa-fw"></i>friends</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://www.rabb1t.xyz/2022/07/12/%E5%A0%86%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myavatar.png">
      <meta itemprop="name" content="MEssa_Rabbit">
      <meta itemprop="description" content="菜狗一个">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rabbit hole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          堆分配流程_ptmalloc源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-12 17:38:48" itemprop="dateCreated datePublished" datetime="2022-07-12T17:38:48+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-19 16:51:16" itemprop="dateModified" datetime="2023-11-19T16:51:16+08:00">2023-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>以glibc 2.23的源码为例，主要查看malloc.c</p>
<span id="more"></span>

<h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://sourceware.org/git/glibc.git</span><br><span class="line">cd glibc</span><br><span class="line">git checkout release/2.23/master</span><br></pre></td></tr></table></figure>

<h2 id="内存管理过程概述"><a href="#内存管理过程概述" class="headerlink" title="内存管理过程概述"></a>内存管理过程概述</h2><p>ptmalloc分配chunk主要是通过5种不同途径，分别是从几个不同容器中获取内存块top chunk, fastbin, unsorted_bin, small_bin以及large_bin。</p>
<p>申请时，访问这些容器顺序是<code>fastbin-&gt;unsorted_bin-&gt;small_bin-&gt;large_bin-&gt;top chunk</code>；释放时，则是通过chunk的大小对chunk进行分类并放入不同容器。</p>
<ul>
<li>Fast bins 是小内存块的高速缓存，当一些大小小于 64 字节的 chunk被回收时，首先会放入 fast bins 中，在分配小内存时，首先会查看 fast bins 中是否有合适的内存块，如果存在，则直接返回 fast bins 中的内存块，以加快分配速度。</li>
<li>Usorted bin 只有一个，回收的非 fast chunk 首先放到 unsorted bin 中，分配内存时会查看 unsorted bin 中是否有合适的 chunk，如果找到满足条件的 chunk，则直接返回给用户，否则将 unsorted bin 的所有 chunk 放入 small bins 或是 large bins 中。</li>
<li>Small bins 用于存放固定大小的 chunk，共 64 个bin，最小的 chunk 大小为 16 字节或 32 字节，每个 bin 的大小相差 8 字节或是 16 字节，当分配小内存块时，采用精确匹配的方式从 small bins 中查找合适的 chunk。</li>
<li>Large bins 用于存储大于等于 512B 或 1024B 的空闲 chunk，这些 chunk 使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从 large bins 中分配 chunk。</li>
<li>Top chunk</li>
</ul>
<h2 id="内存管理过程详述"><a href="#内存管理过程详述" class="headerlink" title="内存管理过程详述"></a>内存管理过程详述</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>用户执行malloc时，实际调用的是<code>__libc_malloc</code>，其中又封装了<code>_int_malloc</code>作为主要的执行函数。然后主要是检查几个容器中是否有合适的chunk。</p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>在进行了一系列相关检查后，首先会查找 fast bins 中是否有所需大小的 chunk 存在(精确查找)，如果存在，就直接返回。</p>
<p>查找的方式是遍历fd指针，直至找到头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast())) &#123;</span><br><span class="line">  idx = fastbin_index(nb);              <span class="comment">// 得到index</span></span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);  <span class="comment">// 得到对应fastbin链表的地址</span></span><br><span class="line">  mchunkptr pp = *fb;</span><br><span class="line">  <span class="keyword">do</span> &#123; <span class="comment">// 遍历该fastbin，找到头结点(FIFO)</span></span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,</span><br><span class="line">                                                      victim)) != victim);</span><br><span class="line">  <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123; <span class="comment">// 检查头结点的**chunk size**</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check_remalloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim); <span class="comment">// 最终得到的内存空间换算为用户空间(mem域)后返回</span></span><br><span class="line">    alloc_perturb(p, bytes); <span class="comment">// 将内容置为perturb_byte^0xff</span></span><br><span class="line">                             <span class="comment">// 默认情况下 perturb_byte 是 0</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>若不属于 fast_chunk 范围，则会进入 small_bins 的相关检查与分配。并且在small bin中寻找chunk也是精确查找。</p>
<p>由于small bin共有62个，所以首先要先找到对应的small bin，然后取出一个即可。</p>
<p>由于<code>Chunk_size=2 * SIZE_SZ * index</code>，所以chunksize右移3(4)位得到index(bins[0]不存在，bins[1]为unsorted_bin)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">  idx = smallbin_index(nb); <span class="comment">// 获取对应 small_bin 的 index</span></span><br><span class="line">  bin = bin_at(av, idx);    <span class="comment">// 获取对应的链表的地址 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 并判断该 small_bin 是否为空或未初始化，同时最后一个chunk</span></span><br><span class="line">  <span class="comment">// (为空时`last(bin)==bin-&gt;bk==bin`(fd和bk指向自己)；</span></span><br><span class="line">  <span class="comment">//  未初始化时`last(bin)==0`)</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">      malloc_consolidate(av); <span class="comment">// small bin未初始化，进行一次初始化</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      set_inuse_bit_at_offset(victim, nb); <span class="comment">// 设置该chunk的in_use位</span></span><br><span class="line">      <span class="comment">// 从small bin中取出chunk</span></span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena) <span class="comment">// 非main_arena需要在标志位上标记</span></span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h4><p>上接判断<code>if (in_smallbin_range(nb))</code>，除了在初始化small bin时会合并fastbin外，从small bin中获取chunk也失败也会执行fastbin的合并，并将这些空闲 chunk 加入 unsorted bin<br>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  idx = largebin_index(nb);</span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入 bins 相关的各种操作(主要是切割chunk和分配chunk到对应bin)，这些操作被放入一个循环中。unsorted bin可以看作是small bin和large bin的cache，这两个bin中的chunk一定都曾位于unsorted bin中。分配时，如果在 unsorted bin 中有合适的 chunk，则直接；若没有合适的，就会把 unsorted bin 中的所有 chunk 分别加入到所属的 bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 反向遍历unsorted bin</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">          __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若申请的chunksize属于small chunk范围，unsorted bin当中只有一个</span></span><br><span class="line"><span class="comment">        chunk同时为last_remainder并且大小还大于待分配chunksize时(拗口)，</span></span><br><span class="line"><span class="comment">        并且能够切割(切割后仍为一个chunk，即符合最小大小)将尝试使用该</span></span><br><span class="line"><span class="comment">        last_remainder进行切割。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        即将unsorted_bin中的chunk重新置入其他bin，直至剩余最后一个chunk时(或者一开始只有一个chunk)时，</span></span><br><span class="line"><span class="comment">        会使用last_remainder尝试分配。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这里重新尝试了分配small bin，因为若前面的smallbin未成功，</span></span><br><span class="line"><span class="comment">        则会合并的fastbin，那么可能会出现适合的smallbin</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 尝试分配last_remainder，这是唯一的从 unsorted bin 中分配 small chunk的情况</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb); <span class="comment">// 获取切割后的位置</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder; <span class="comment">// 取出</span></span><br><span class="line">        <span class="comment">// 更新last_remainder，并重新链入unsorted bin</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置chunk头，只有非best-fit分配时才需要设置chunk头，所以前面都没有</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置last_remainder头和prev_size</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用last_remainder分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">// 取出最后一个chunk</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该chunk大小正好则直接返回 */</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 不是正合适，则会将其放入small bin或large bin中 */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">        <span class="comment">// small chunk直接找到对应bin即可</span></span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            large chunk稍微麻烦一些，找到对应范围的bin后，</span></span><br><span class="line"><span class="comment">            还得在该bin中找到一个比该chunk小的结点，插入其后。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123; <span class="comment">// bin非空</span></span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          <span class="comment">// 由于bin是一个循环双向链表，所以可以直接和bck-&gt;bk(此时bck是bin)进行比较，判断是否可直接插入</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不能快速插入则只能一个一个判断，但因为有fd_nextsize存在，所以可以先范围再精确的比较</span></span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fwd-&gt;size) <span class="comment">// 精准匹配到相同大小，则直接插入(设置fwd/bck指针)</span></span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 没有相同大小，则先插入到xx_nextsize链表中(真插入)，再插入到fd/bk链表中</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// large_bin为空则直接插入</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      <span class="comment">// fd/bk链表的真正插入操作</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的最大次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       非small_chunk则在large_bins中查找，找出最适合或者最小大于nb的chunk</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">      bin = bin_at(av, idx); <span class="comment">// 获取bin指针</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="comment">// 检查该bin是否为空，申请size是否大于该bin中最大的chunk(first(bin)即bin中的第一个chunk)</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">// 后向遍历xx_nextsize链表，找出一个大于申请size的chunk</span></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">            ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size = chunksize(victim)) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)))</span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">           list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="comment">// 尽量避免从链表尾取出chunk，因为从链表中间取出chunk的话，fd和bk都指向另一个chunk，操作上来说，更方便取出(使用unlink宏)。</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="comment">// 检查remainder_size，若切割后不满足剩余部分仍为一个chunk，则不切割，直接分配出去</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset(victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则就切割，剩余部分放入unsorted_bin</span></span><br><span class="line">          remainder = chunk_at_offset(victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">             have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks(av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head(victim,</span><br><span class="line">                   nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// large chunk分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若还没将 chunk 分配出去，则在从bins中找到下一个更大的bin(对应更大的idx)</span></span><br><span class="line"><span class="comment">       中获取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       通过位图能快速地检查bin是否为空，并找到对应bin获取chunk。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">    <span class="comment">// 找到对应block的下标，binmap使用block保存数据，实际上block是一个int数据，</span></span><br><span class="line">    <span class="comment">// 能保存32个chunk的使用情况，并且按大小排了序。</span></span><br><span class="line">    block = idx2block(idx); </span><br><span class="line">    <span class="comment">// 通过下标找到位图</span></span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">    <span class="comment">// 将idx对应的比特位设置为1，其它位为0。</span></span><br><span class="line">    bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="comment">// bit与map比较，bit&gt;map则map中没有比所需大小大的chunk</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 继续遍历，找下一个block，如果不存在，则使用top chunk</span></span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到对应bin</span></span><br><span class="line">        bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="comment">// 找到map中符合条件的最小chunk，并得到对应bin</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        bin = next_bin(bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert(bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      <span class="comment">// 获取该bin中最后一个chunk</span></span><br><span class="line">      victim = last(bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="comment">// bin为空，说明位图出错了，继续找bin</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin(bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 不为空，取出chunk，并继续判断切割条件和切割</span></span><br><span class="line">        size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset(victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">             have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks(av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head(victim,</span><br><span class="line">                   nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配结束</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  use_top:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若bins中实在找不到适合的chunk，连分割都办不到，则会切割top_chunk。</span></span><br><span class="line"><span class="comment">       top_chunk保存av-&gt;top。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       av-&gt;top 的存在条件是`size &gt;= MINSIZE`，因此通过切割top_chunk</span></span><br><span class="line"><span class="comment">       完成分配后，若不满足这个条件了，则会重新补充一个top_chunk。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top_chunk满足分配条件则直接切割并分配</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(victim,</span><br><span class="line">               nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="comment">// top_chunk不满足分配，则合并fast_chunks</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="comment">// 重新获取对应idx(先前获取更大bin时改变了)</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 堆空间不足了，需要重新申请一次内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>chunk 的大小不属于 small_chunk 的范围则会合并空闲 fast_chunks</li>
<li>top_chunk 不满足分配会合并空闲 fast_chunks</li>
<li>unsorted_bin 的循环执行时，会将其中的chunks(last_remainder)分配到 small_bins 和 large_bins 中</li>
<li>unsorted_bin 中分配 chunk，先从last_remainder(unsorted_chunks(av)-&gt;bk)开始，接着是 small_bins，unsorted_bin，最后是 large_bins</li>
<li>bins 中以 bin-&gt;fd 为第一个 chunk，bin-&gt;bk 为最后一个 chunk，并且在large_bin中chunksize是从大到小递减的(fd/fd_nextsize方向)</li>
<li>分配顺序如下:<ul>
<li>从 fast_bin 中分配时，从fd开始(FILO)；</li>
<li>从 small_bin 中分配时，从bk开始(FIFO)；</li>
<li>从 unsorted_bin 中分配时，从bk开始(FIFO)；</li>
<li>从 large_bin 中分配时，会从fd开始，但large_bin中chunk的排序是按照大小排的；</li>
</ul>
</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>同malloc，free也有封装函数__libc_free，命名类似malloc，实际作用的函数是_int_free。</p>
<p>还是先会进行一系列检查，主要是检查待释放地址和其大小是否合法(符号，大小范围和是否对齐)。</p>
<h4 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h4><p>首先进行的还是fast bin的判断，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 判断是否符合fast chunk的大小范围</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast()) </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS </span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">        bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">// 默认TRIM_FASTBINS是0，因此不会执行，</span></span><br><span class="line">      <span class="comment">// 若设置该参数为true，则当fastchunk的下一个邻接chunk为top chunk时</span></span><br><span class="line">      <span class="comment">// 则不将释放的chunk放入fast bin</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个chunk的大小不能小于两倍的SIZE_SZ,并且</span></span><br><span class="line">    <span class="comment">// 下一个chunk的大小不能大于system_mem， 一般为132k</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem,</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock. */</span></span><br><span class="line">      <span class="comment">// 与上锁有关，不深究</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ ||</span><br><span class="line">                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将chunk的mem部分全部设置为perturb_byte</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av); <span class="comment">// 设置fast chunk的标记位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size); <span class="comment">// 获取索引</span></span><br><span class="line">    fb = &amp;fastbin(av, idx); <span class="comment">// 获取对应fastbin的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    <span class="comment">// 将p插入fastbin链表</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="comment">// 检查是否存在double free，通过检查fastbin中的最后一个chunk(old==fastbin(av,idx))与待释放的p是否指向同一个chunk </span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="comment">// 检查锁，并得到idx</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 free 的 chunk 不是通过 mmap()分配的，并且当前还没有获得分配区的锁，获取分配区的锁。</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                             (<span class="keyword">char</span> *)nextchunk &gt;=</span><br><span class="line">                                 ((<span class="keyword">char</span> *)av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="非mmap分配的内存"><a href="#非mmap分配的内存" class="headerlink" title="非mmap分配的内存"></a>非mmap分配的内存</h4><p>非fast_chunk并且也非mmap分配的内存在释放时，会执行合并操作。合并的顺序是先考虑物理低地址空闲块(后向合并)，后考虑物理高地址空闲块(前向合并)，合并后的 chunk 指向合并的 chunk 的低地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个chunk</span></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="comment">// 检查释放的chunk不能为top_chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="comment">// 检查nextchunk不能超过arena的边界(top_chunk)</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                             (<span class="keyword">char</span> *)nextchunk &gt;=</span><br><span class="line">                                 ((<span class="keyword">char</span> *)av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                         <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="comment">// 检查inuse位，防止double free</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取nextchunk_size，并检查大小是否合法(至少2*SIZE_SZ且不大于系统可提供的内存)</span></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面检查结束后，将真正进行合并</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针的mem域设置为perturb_byte</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="comment">// 最后判断上一个chunk的inuse位，若未使用则进行合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize)); <span class="comment">// 重新设置p到低地址处</span></span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下一个chunk是否是top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      <span class="comment">// 获取inuse位</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">// 如果不在使用，则合并</span></span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">// 否则清空待释放chunk的使用状态(inuse)</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将释放并合并后的chunk放入unsorted bin中，直到下一次malloc</span></span><br><span class="line"><span class="comment">        执行bins循环时，才有机会放入对应的bin。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 插入unsorted bin操作</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 若下一个chunk是top chunk，则与top chunk合并</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当合并后的chunksize大于FASTBIN_CONSOLIDATION_THRESHOLD时，会</span></span><br><span class="line">    <span class="comment">// 执行裁剪操作，一般合并到 top chunk 都会执行这部分代码。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">// 合并fastbin</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前为主分配区时，直接判断top chunksize是否大于被裁剪的阈值</span></span><br><span class="line">      <span class="comment">// 达到阈值，则使用systrim进行裁剪，将内存返回给系统</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非主分配区，则使用heap_trim进行裁剪</span></span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">      assert(locked);</span><br><span class="line">      (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="mmap分配的内存"><a href="#mmap分配的内存" class="headerlink" title="mmap分配的内存"></a>mmap分配的内存</h4><p>使用munmap_chunk释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>在上面的代码中频繁出现了unlink，这实际上是一个宏，用来从链表中取出chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD)                                                  \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                \</span></span><br><span class="line"><span class="meta">    <span class="comment">// 检查链中的前后块中是否指向待释放chunks                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    if (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      malloc_printerr(check_action, &quot;corrupted double-linked list&quot;, P, AV);    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    else &#123;                                                                     \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      FD-&gt;bk = BK;                                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      BK-&gt;fd = FD;                                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      // 若非small chunk，那么还需要考虑nextsize双向链表                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (!in_smallbin_range(P-&gt;size) &amp;&amp;                                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          __builtin_expect(P-&gt;fd_nextsize != NULL, 0)) &#123;                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        if (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) ||           \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          malloc_printerr(check_action,                                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">                          &quot;corrupted double-linked list (not small)&quot;, P, AV);  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        if (FD-&gt;fd_nextsize == NULL) &#123;                                         \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          if (P-&gt;fd_nextsize == P)                                             \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                            \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          else &#123;                                                               \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          &#125;                                                                    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        &#125; else &#123; // 否则只需要考虑fd/bk链表                                    \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        &#125;                                                                      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;                                                                        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    &#125;                                                                          \</span></span></span><br><span class="line"><span class="comment"><span class="meta">  &#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>unlink出现在:</p>
<ul>
<li>malloc<ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</li>
<li>依次遍历处理 unsorted bin 时也没有使用 unlink 。</li>
</ul>
</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li>
</ul>
</li>
<li>free<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
<p>由于unlink中存在一个检测<code>if (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))</code>， 因此在利用unlink(一般是合并)时，还需要构造fd与bk。</p>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>tcache是glibc高版本(2.26以后)中出现的新技术，使用的优先级高于fastbin，并且分配过程类似fastbin。</p>
<h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p>在/malloc/malloc.c中声明了两个新的结构体:</p>
<ul>
<li>tcache_entry</li>
<li>tcache_perthread_struct</li>
</ul>
<h5 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>该结构体用于链接空闲的chunk结构体，next指针指向下一个大小相同的chunk;key则指向该线程的tcache_perthread_struct。</p>
<h5 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h5><p>从这个结构体名字可以看出，每个线程都有自己对应的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p>该结构体用于管理tcache bins，counts数组用来计数每个bin中的tcache chunk个数;entries数组则是保存每个bin的链表，类似arena中的fastbinY，指向释放的最后一个chunk。</p>
<p>而空闲的tcache chunk与fastbin chunk相比，二者的结构是有重合的：在tcache chunk释放后，chunk的mem域会被初始化为tcache_entry，那么next指针就与fd重合了。因此tcache chunk的管理可以看作类似fastbin chunk的管理。</p>
<p>与fastbin的差异在于，tcache_perthread_struct也就是管理tcache的结构位于堆的首部；管理tcache的操作也有些许不同。</p>
<h4 id="管理tcache"><a href="#管理tcache" class="headerlink" title="管理tcache"></a>管理tcache</h4><p>管理tcache主要使用两个函数：</p>
<ul>
<li>tcache_get</li>
<li>tcache_put</li>
</ul>
<p>也都在/malloc/malloc.c文件中</p>
<h5 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h5><p>首先查看在__libc_malloc中的改动:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一段代码是在_int_malloc之前执行的，因此优先级是高于其他bin中的内存。</p>
<p>并且获取chunk使用了tcache_get函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查十分简陋，仅仅检查了tc_idx，而没有其他关于tcache_entry结构体的检查。</p>
<h5 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h5><p>再查看在_int_free中的改动:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = tmp-&gt;next)</span><br><span class="line">	      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">		malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">	    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">	       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也是处于_int_free代码的顶部，先于其他bin收集chunk。</p>
<p>会先检查一次tcache_perthread_struct的存在并遍历对应bin，查看其中是否存在待释放的地址，防止了double free。然后又检查了bin中的chunk的数目不能大于总chunk数目。</p>
<p>然后使用tcache_put取出chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也是十分简陋，直接将tcache_entry(chunk2mem代码重用)链入对应bin中。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/pwn/" rel="tag"><i class="fa fa-tag"></i> pwn</a>
              <a href="/tags/heap/" rel="tag"><i class="fa fa-tag"></i> heap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/07/covteamctf-pwn-wp/" rel="prev" title="covteamctf_pwn_wp">
      <i class="fa fa-chevron-left"></i> covteamctf_pwn_wp
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF2022-pwn-wp/" rel="next" title="蓝帽杯2022初赛_pwn_wp">
      蓝帽杯2022初赛_pwn_wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">获取源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">内存管理过程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text">内存管理过程详述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">3.1.</span> <span class="nav-text">malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fast-bin"><span class="nav-number">3.1.1.</span> <span class="nav-text">fast bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#small-bin"><span class="nav-number">3.1.2.</span> <span class="nav-text">small bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bins"><span class="nav-number">3.1.3.</span> <span class="nav-text">bins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">3.2.</span> <span class="nav-text">free</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fast-bin-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">fast bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9Emmap%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">非mmap分配的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">3.2.3.</span> <span class="nav-text">mmap分配的内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink"><span class="nav-number">3.3.</span> <span class="nav-text">unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache"><span class="nav-number">3.4.</span> <span class="nav-text">tcache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.</span> <span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tcache-entry"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">tcache_entry</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tcache-perthread-struct"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">tcache_perthread_struct</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86tcache"><span class="nav-number">3.4.2.</span> <span class="nav-text">管理tcache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tcache-get"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">tcache_get</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tcache-put"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">tcache_put</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MEssa_Rabbit"
      src="/images/myavatar.png">
  <p class="site-author-name" itemprop="name">MEssa_Rabbit</p>
  <div class="site-description" itemprop="description">菜狗一个</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/0xME3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;0xME3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:messap2001@foxmail.com" title="E-Mail → mailto:messap2001@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEssa_Rabbit</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
